
    <!DOCTYPE html>
        <html>
        <head>
            <title>🥥 React.js</title>
            <meta charset="UTF-8">
            <link rel="icon" type="image/png" href="../src/img/favicon.svg">

            <script src="../src/js/utils.js"></script>
            <!-- Own JavaScript -->
            <script src="../@modules/build-react-js.js"></script>
        </head>
        <body>

            <div id="container">
                <div id="menu" :class="{ hide:isHideMenu }">
                    <div id="top">
                        <img
                            width="35px"
                            height="35px"
                            src="../src/img/show.svg"
                            class="img"
                            @click="toggleMenu()"
                        >
                        <a href="#links" class="link" v-html="'🥥 React.js'"></a>
                    </div>
                    <h4>🥥 Реконсиляция</h4><ul>
        <li>
            <a
                class="menu-link"
                id="id__react-js/reconciler/virtual-dom"
                href="#react-js/reconciler/virtual-dom"
            >📑 Virtual DOM (Общее)</a>
        </li>
    
        <li>
            <a
                class="menu-link"
                id="id__react-js/reconciler/virtual-dom-react"
                href="#react-js/reconciler/virtual-dom-react"
            >🍋 Virtual DOM (React)</a>
        </li>
    
        <li>
            <a
                class="menu-link"
                id="id__react-js/reconciler/reconciliation"
                href="#react-js/reconciler/reconciliation"
            >🍋 Reconciliation Algorithm</a>
        </li>
    
        <li>
            <a
                class="menu-link"
                id="id__react-js/reconciler/fiber"
                href="#react-js/reconciler/fiber"
            >🍋 React Fiber</a>
        </li>
    </ul><h4>🥥 Информация</h4><ul>
        <li>
            <a
                class="menu-link"
                id="id__react-js/info/info"
                href="#react-js/info/info"
            >📑 Информация</a>
        </li>
    
        <li>
            <a
                class="menu-link"
                id="id__react-js/info/patterns"
                href="#react-js/info/patterns"
            >📑 Шаблоны проектирования</a>
        </li>
    
        <li>
            <a
                class="menu-link"
                id="id__react-js/info/structure"
                href="#react-js/info/structure"
            >⚡️ Структура</a>
        </li>
    
        <li>
            <a
                class="menu-link"
                id="id__react-js/info/components"
                href="#react-js/info/components"
            >🍪 Компоненты</a>
        </li>
    
        <li>
            <a
                class="menu-link"
                id="id__react-js/info/props"
                href="#react-js/info/props"
            >🍪 Пропсы</a>
        </li>
    </ul><h4>🥥 API</h4><ul>
        <li>
            <a
                class="menu-link"
                id="id__react-js/api/jsx"
                href="#react-js/api/jsx"
            >💥 JSX</a>
        </li>
    
        <li>
            <a
                class="menu-link"
                id="id__react-js/api/children"
                href="#react-js/api/children"
            >💥 Children</a>
        </li>
    
        <li>
            <a
                class="menu-link"
                id="id__react-js/api/context"
                href="#react-js/api/context"
            >💥 Context API</a>
        </li>
    
        <li>
            <a
                class="menu-link"
                id="id__react-js/api/refs"
                href="#react-js/api/refs"
            >💥 Рефы</a>
        </li>
    
        <li>
            <a
                class="menu-link"
                id="id__react-js/api/fragments"
                href="#react-js/api/fragments"
            >💥 Фрагменты</a>
        </li>
    
        <li>
            <a
                class="menu-link"
                id="id__react-js/api/portals"
                href="#react-js/api/portals"
            >💥 Порталы</a>
        </li>
    </ul><h4>🥥 Паттерны</h4><ul>
        <li>
            <a
                class="menu-link"
                id="id__react-js/patterns/higher-order-components"
                href="#react-js/patterns/higher-order-components"
            >🍩 Higher-Order Component</a>
        </li>
    
        <li>
            <a
                class="menu-link"
                id="id__react-js/patterns/render-props"
                href="#react-js/patterns/render-props"
            >🍩 Render Props</a>
        </li>
    
        <li>
            <a
                class="menu-link"
                id="id__react-js/patterns/element-props"
                href="#react-js/patterns/element-props"
            >🍩 Свойства-элементы</a>
        </li>
    
        <li>
            <a
                class="menu-link"
                id="id__react-js/patterns/lifting-state-up"
                href="#react-js/patterns/lifting-state-up"
            >🍩 Подъём состояния</a>
        </li>
    </ul><h4>🥥 Обработка и вывод данных</h4><ul>
        <li>
            <a
                class="menu-link"
                id="id__react-js/processing-data-output/handling-events"
                href="#react-js/processing-data-output/handling-events"
            >🍪 Обработка событий</a>
        </li>
    
        <li>
            <a
                class="menu-link"
                id="id__react-js/processing-data-output/controlled-components"
                href="#react-js/processing-data-output/controlled-components"
            >🍪 Controlled Components</a>
        </li>
    
        <li>
            <a
                class="menu-link"
                id="id__react-js/processing-data-output/uncontrolled-components"
                href="#react-js/processing-data-output/uncontrolled-components"
            >🍪 Uncontrolled Components</a>
        </li>
    
        <li>
            <a
                class="menu-link"
                id="id__react-js/processing-data-output/css"
                href="#react-js/processing-data-output/css"
            >🍪 CSS</a>
        </li>
    
        <li>
            <a
                class="menu-link"
                id="id__react-js/processing-data-output/conditional-rendering"
                href="#react-js/processing-data-output/conditional-rendering"
            >🍪 Условный рендеринг</a>
        </li>
    
        <li>
            <a
                class="menu-link"
                id="id__react-js/processing-data-output/lists-and-keys"
                href="#react-js/processing-data-output/lists-and-keys"
            >🍪 Списки и ключи</a>
        </li>
    
        <li>
            <a
                class="menu-link"
                id="id__react-js/processing-data-output/error-boundaries"
                href="#react-js/processing-data-output/error-boundaries"
            >🍪 Предохранители</a>
        </li>
    </ul><h4>🥥 Жизненный цикл компонентов</h4><ul>
        <li>
            <a
                class="menu-link"
                id="id__react-js/lifecycle/info"
                href="#react-js/lifecycle/info"
            >📑 Информация</a>
        </li>
    
        <li>
            <a
                class="menu-link"
                id="id__react-js/lifecycle/hook-constructor"
                href="#react-js/lifecycle/hook-constructor"
            ><u-menu>constructor()</u-menu></a>
        </li>
    
        <li>
            <a
                class="menu-link"
                id="id__react-js/lifecycle/hook-get-derived-state-from-props"
                href="#react-js/lifecycle/hook-get-derived-state-from-props"
            ><u-menu>getDerivedStateFromProps()</u-menu></a>
        </li>
    
        <li>
            <a
                class="menu-link"
                id="id__react-js/lifecycle/hook-should-component-update"
                href="#react-js/lifecycle/hook-should-component-update"
            ><u-menu>shouldComponentUpdate()</u-menu></a>
        </li>
    
        <li>
            <a
                class="menu-link"
                id="id__react-js/lifecycle/hook-render"
                href="#react-js/lifecycle/hook-render"
            ><u-menu>render()</u-menu></a>
        </li>
    
        <li>
            <a
                class="menu-link"
                id="id__react-js/lifecycle/hook-get-snapshot-before-update"
                href="#react-js/lifecycle/hook-get-snapshot-before-update"
            ><u-menu>getSnapshotBeforeUpdate()</u-menu></a>
        </li>
    
        <li>
            <a
                class="menu-link"
                id="id__react-js/lifecycle/hook-component-did-mount"
                href="#react-js/lifecycle/hook-component-did-mount"
            >🔥 <u-menu>componentDidMount()</u-menu></a>
        </li>
    
        <li>
            <a
                class="menu-link"
                id="id__react-js/lifecycle/hook-component-did-update"
                href="#react-js/lifecycle/hook-component-did-update"
            >🔥 <u-menu>componentDidUpdate()</u-menu></a>
        </li>
    
        <li>
            <a
                class="menu-link"
                id="id__react-js/lifecycle/hook-component-will-unmount"
                href="#react-js/lifecycle/hook-component-will-unmount"
            >🔥 <u-menu>componentWillUnmount()</u-menu></a>
        </li>
    
        <li>
            <a
                class="menu-link"
                id="id__react-js/lifecycle/hook-get-derived-state-from-error"
                href="#react-js/lifecycle/hook-get-derived-state-from-error"
            ><u-menu>getDerivedStateFromError()</u-menu></a>
        </li>
    
        <li>
            <a
                class="menu-link"
                id="id__react-js/lifecycle/hook-component-did-catch"
                href="#react-js/lifecycle/hook-component-did-catch"
            ><u-menu>componentDidCatch()</u-menu></a>
        </li>
    </ul><h4>🥥 Прочее</h4><ul>
        <li>
            <a
                class="menu-link"
                id="id__react-js/other/react-developer-tools"
                href="#react-js/other/react-developer-tools"
            >React Developer Tools</a>
        </li>
    
        <li>
            <a
                class="menu-link"
                id="id__react-js/other/components"
                href="#react-js/other/components"
            >Компоненты</a>
        </li>
    
        <li>
            <a
                class="menu-link"
                id="id__react-js/other/samples"
                href="#react-js/other/samples"
            >Примеры</a>
        </li>
    </ul><h4>🥥 React Plugins</h4><ul>
        <li>
            <a
                class="menu-link"
                id="id__react-js/react-plugins/create-react-app"
                href="#react-js/react-plugins/create-react-app"
            ><u-menu-border>create-react-app</u-menu-border></a>
        </li>
    
        <li>
            <a
                class="menu-link"
                id="id__react-js/react-plugins/classnames"
                href="#react-js/react-plugins/classnames"
            ><u-menu-border>classnames</u-menu-border></a>
        </li>
    </ul>
                </div>

                <div id="wrapper">
                    <div id="links">
                        <ul>
                            <slot v-for="itemLink in linksContent">
                                <li v-if="itemLink">
                                    <a :href="itemLink.page" :class="'theme-'+itemLink.theme" v-html="itemLink.title"></a>
                                </li>
                                <li v-else class="splitter"></li>
                            </slot>
                        </ul>
                    </div>
                    <div id="content"><div id="react-js/reconciler/virtual-dom"><h2>Virtual DOM</h2>

<ul class="list-point">
    <li><u-text-define>DOM (Document Object Model)</u-text-define> - способ представления структурного документа с помощью объектов. Это кроссплатформенное и языко-независимое соглашение для представления и взаимодействия с данными в HTML, XML и т.д. </li>
    <li><b>Проблема:</b> никогда не был рассчитан для создания динамического пользовательского интерфейса (UI)</li>
    <hr>

    <li><u-text-define>Shadow DOM</u-text-define> - Спецификация, описывающая метод объединения нескольких DOM-деревьев в одну иерархию и как эти деревья взаимодействуют друг с другом в пределах документа, что позволяет лучше скомпоновать DOM</li>
    <hr>

	<li><u-text-define>Virtual DOM</u-text-define> - техника и набор библиотек / алгоритмов, которые позволяют нам улучшить производительность на клиентской стороне, избегая прямой работы с DOM путем работы с легким JavaScript-объектом, имитирующем DOM-дерево</li>

	<li>Вместо того, чтобы взаимодействовать с DOM напрямую, мы работаем с его легковесной копией. Мы можем вносить изменения в копию, исходя из наших потребностей, а после этого применять изменения к реальному DOM. При этом происходит сравнение DOM-дерева с его виртуальной копией, определяется разница и запускается перерисовка того, что было изменено</li>

	<li>Virtual DOM не является стандартом и в конечном итоге мы по-прежнему взаимодействуем с DOM, но делаем это как можно реже и более эффективно</li>
</ul>

<!------------------------------------------------------------->
<h4>Два варианта узнать, что данные изменились</h4>
<!------------------------------------------------------------->
<ul class="list-point">
	<li><u-text-underline>«Dirty Checking» (грязная проверка)</u-text-underline> - опрашивать данные через регулярные промежутки времени и рекурсивно проверять все значения в структуре данных</li>
	<li><u-text-underline>«Observable» (наблюдаемый)</u-text-underline> - наблюдение за изменением состояния. Если ничего не изменилось, мы ничего не делаем. Если изменилось, мы точно знаем, что нужно обновить</li>
</ul>
</div><div id="react-js/reconciler/virtual-dom-react"><h2>Virtual DOM (React)</h2>

<ul class="list-point">
    <li>React создает легковесное дерево из JavaScript-объектов для имитации DOM-дерева. Затем он создает из них HTML, который вставляется или добавляется к нужному DOM-элементу, что вызывает перерисовку страницы в браузере</li>
    <li>JS объкты просто строить и сравнивать</li>
	<li>Когда вы рендерите React приложение, дерево елементов, которое описывает приложение генерируется в зарезервированной памяти. Это дерево потом включается в рендеринг окружение — на примере браузерного приложения, оно переводится в набор DOM операций. Когда состояние приложения обновляется (обычно вызовом setState), новое дерево генерируется. Новое дерево сравнивается с предыдущим, чтоб просчитать и включить именно те операции, которые нужны для перерисовки обновленного приложения.</li>
</ul>

<!------------------------------------------------------------->
<h4>1. Первоначальный Render DOM</h4>
<!------------------------------------------------------------->
<ol class="list-num">
<li>Вернули JSX</li>
<v-code lang="js" title="">
class App extends React.Component {
	render(
		return (
			&lt;div&gt;Hello&lt;/div&gt;
		)
	);
}
</v-code>

<li>Транспиляция в React.createElement (Virtual DOM)</li>
<v-code lang="js" title="">
React.createElement('div', null, 'Hello'),
</v-code>

<li>Рендер в браузер DOM (react-dom)</li>
<v-code lang="js" title="">
ReactDOM.render(&lt;App /&gt;, document.getElementById('root'));
</v-code>
</ol>

<!------------------------------------------------------------->
<h4>2. Изменение setState()</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li>При нажатии setState() каждый раз асинхронно (React 16) перестраивается Virtual DOM для компонента и всех его потомков. Но в DOM идут только изменения</li>
</ul>
<ol class="list-num">
	<li>Произошел <u-code-text>setState()</u-code-text> в компонене <u-code-text>App</u-code-text>. Помечаем компонент как "грязный"</li>
	<li>Перестроение Virtual DOM</li>
	<li>Сравнение измененого Virtual DOM и старого Virtual DOM. При нахождении изменений, меняется компонент в реальном DOM</li>
</ol>

<img src="/@img/react/reconciler/virtual-dom-set-state.png" width="450px">
</div><div id="react-js/reconciler/reconciliation"><h2>Reconciliation Algorithm</h2>

<ul class="list-point">
    <li><u-text-define>Reconciliation Algorithm</u-text-define> (алгоритм согласования) - алгоритм сравнения в React</li>
    <li>Вычисление разницы между двумя Virtual DOM. Если компонент в дереве заменен на другой, то всё поддерево считается новым. Дальнейшее сравнение вглубь не происходит</li>
    <li><u>Назначение</u>: отличить одно дерево элементов от другого для определения частей, которые нужно будет заменить.</li>
    <li><u-text-define>Апдейт</u-text-define> - изменение в данных, которые используются для отрисовки React приложения. Обычно это результат вызова метода setState. Это конечный результат отрисовки компонента.</li>
</ul>

<ol class="list-num">
	<b>React реализует эвристический алгоритм O(n), который основывается на двух предположениях:</b>
	<li>Два элемента с разными типами произведут разные деревья</li>
	<li>Разработчик может указать, какие дочерние элементы могут оставаться стабильными между разными рендерами с помощью пропа <u-code-text>key</u-code-text></li>
</ol>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Re-render</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ol class="list-num">
    <li>Reconciler (Сверка). Работает как Call Stack. Вычисляет какие части дерева изменились</li>
    <li>Render (Переписовка): ReactDOM, React Native. Использует информацию из Reconciler, чтобы обновить ранее отрисованное дерево</li>
</ol>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Время обновления</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
    <li>Чтобы изменения происходили плавно, нужно обновлять анимацию 60 раз в секунду, т.е. каждые 16 ms (миллисекунд).</li>
</ul>

<v-code lang="js" title="">
1 секунда = 1000 миллисекунд
1000 миллисекунд / 60 = 16 миллисекунд
</v-code>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Алгоритм сравнения</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
    <li>При сравнении двух деревьев первым делом React сравнивает два корневых элемента. Поведение различается в зависимости от типов корневых элементов</li>
</ul>

<!------------------------------------------------------------->
<h4>1. DOM-элементы различных типов <u-code-text>&lt;div&gt;</u-code-text> и <u-code-text>&lt;span&gt;</u-code-text></h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li>Всякий раз, когда корневые элементы имеют различные типы, <u-text-underline>React уничтожает старое дерево и строит новое с нуля</u-text-underline>. Переходы от <u>&lt;a&gt;</u> к <u>&lt;img&gt;</u>, или от <u>&lt;Article&gt;</u> к <u>&lt;Comment&gt;,</u> или от <u>&lt;Button&gt;</u> к <u>&lt;div&gt;</u> приведут к полному перестроению</li>

    <li>При уничтожении дерева старые DOM-узлы удаляются. Экземпляры компонента получают <u>componentWillUnmount()</u>. При построении нового дерева, новые DOM-узлы вставляются в DOM. Экземпляры компонента получают <u>componentWillMount()</u>, а затем <u>componentDidMount()</u>. Любое состояние, связанное со старым деревом, теряется</li>

    <li>Любые компоненты, лежащие ниже корневого, также размонтируются, а их состояние уничтожится. Например, это произойдёт при таком сравнении: При этом старый Counter уничтожится, а новый — смонтируется</li>
</ul>

<v-two-code type="html;html" comment="Было;Стало">
<template v-slot:first>
&lt;div&gt;
	&lt;Counter /&gt;
&lt;/div&gt;
</template>
<template v-slot:last>
&lt;span&gt;
	&lt;Counter /&gt;
&lt;/span&gt;
</template>
</v-two-code>

<!------------------------------------------------------------->
<h4>2. DOM-элементы одного типа, но разных атрибутов <u-code-text>&lt;div className="before"&gt;</u-code-text> и <u-code-text>&lt;span className="after"&gt;</u-code-text></h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li>При сравнении двух React DOM-элементов одного типа, <u-text-underline>React смотрит на атрибуты обоих, сохраняет лежащий в основе этих элементов DOM-узел и обновляет только изменённые атрибуты</u-text-underline></li>
    <li>После обработки DOM-узла React рекурсивно проходится по дочерним элементам</li>
</ul>

<hr>

<ul class="list-point">
    <li>Сравнивая эти элементы, React знает, что нужно модифицировать только className у лежащего в основе DOM-узла</li>
</ul>

<v-code lang="html" title="">
&lt;div className="before" title="stuff" /&gt;
&lt;div className="after" title="stuff" /&gt;
</v-code>

<hr>

<ul class="list-point">
    <li>Обновляя style, React знает, что нужно обновлять только изменившиеся свойства</li>
    <li>При конвертации между этими элементами, React знает, что нужно модифицировать только стиль color, а fontWeight сохранить</li>
</ul>

<v-code lang="html" title="">
&lt;div style={ {color: 'red', fontWeight: 'bold'} } /&gt;
&lt;div style={ {color: 'green', fontWeight: 'bold'} } /&gt;
</v-code>

<!------------------------------------------------------------->
<h4>3. Компоненты одного типа <u-code-text>&lt;App&gt;</u-code-text> и <u-code-text>&lt;App&gt;</u-code-text></h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li>Когда компонент обновляется, его экземпляр остаётся прежним, поэтому его состояние сохраняется между рендерами. React <u-text-underline>обновляет пропсы базового экземпляра компонента</u-text-underline> для соответствия новому элементу и <u-text-underline>вызывает <u>componentWillUpdate()</u> на базовом экземпляре</u-text-underline></li>
    <li>Далее вызывается метод <u>render()</u> и алгоритм сравнения <u-text-underline>рекурсивно обходит предыдущий и новый результаты</u-text-underline></li>
</ul>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Рекурсия по дочерним элементам и ключи</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<!------------------------------------------------------------->
<h4>Рекурсия по дочерним элементам</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li>По умолчанию при рекурсивном обходе дочерних элементов DOM-узла React проходит по обоим спискам потомков одновременно и создаёт мутацию, когда находит отличие</li>
</ul>

<hr>

<ul class="list-point">
    <li>При добавлении элемента в конец дочерних элементов, преобразование между этими деревьями работает отлично</li>
    <li>React сравнит два дерева <u>&lt;li&gt;первый&lt;/li&gt;</u>, сравнит два дерева <u>&lt;li&gt;второй&lt;/li&gt;</u>, а затем вставит дерево <u>&lt;li&gt;третий&lt;/li&gt;</u></li>
</ul>

<v-two-code type="html;html" comment="Было;Стало">
<template v-slot:first>
&lt;ul&gt;
	&lt;li&gt;первый&lt;/li&gt;
	&lt;li&gt;второй&lt;/li&gt;
&lt;/ul&gt;
</template>
<template v-slot:last>
&lt;ul&gt;
	&lt;li&gt;первый&lt;/li&gt;
	&lt;li&gt;второй&lt;/li&gt;
	&lt;li&gt;третий&lt;/li&gt;
&lt;/ul&gt;
</template>
</v-two-code>

<hr>

<ul class="list-point">
    <li>Преобразование между этими деревьями работает плохо</li>
    <li>React будет мутировать каждого потомка, вместо того чтобы оставить <u>&lt;li&gt;Санкт-Петербург&lt;/li&gt;</u> и <u>&lt;li&gt;Москва&lt;/li&gt;</u> нетронутыми</li>
</ul>

<v-two-code type="html;html" comment="Было;Стало">
<template v-slot:first>
&lt;ul&gt;
	&lt;li&gt;Санкт-Петербург&lt;/li&gt;
	&lt;li&gt;Москва&lt;/li&gt;
&lt;/ul&gt;
</template>
<template v-slot:last>
&lt;ul&gt;
	&lt;li&gt;Ростов-на-Дону&lt;/li&gt;
	&lt;li&gt;Санкт-Петербург&lt;/li&gt;
	&lt;li&gt;Москва&lt;/li&gt;
&lt;/ul&gt;
</template>
</v-two-code>

<!------------------------------------------------------------->
<h4>Ключи</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li>Когда у дочерних элементов есть ключи <u-code-text>key</u-code-text>, React использует их, чтобы сопоставить потомков исходного дерева с потомками последующего дерева</li>
    <li>Ключ должен быть уникальным только среди его соседей, а не глобально</li>
</ul>

<hr>

<ul class="list-point">
    <li>Если добавить key к неэффективному примеру выше, преобразование дерева станет эффективным</li>
    <li>Теперь React знает, что элемент с ключом <u>'2014'</u> — новый, а элементы с ключами <u>'2015'</u> и <u>'2016'</u> только что переместились</li>
</ul>

<v-two-code type="html;html" comment="Было;Стало">
<template v-slot:first>
&lt;ul&gt;
	&lt;li key="2015"&gt;Санкт-Петербург&lt;/li&gt;
	&lt;li key="2016"&gt;Москва&lt;/li&gt;
&lt;/ul&gt;
</template>
<template v-slot:last>
&lt;ul&gt;
	&lt;li key="2014"&gt;Ростов-на-Дону&lt;/li&gt;
	&lt;li key="2015"&gt;Санкт-Петербург&lt;/li&gt;
	&lt;li key="2016"&gt;Москва&lt;/li&gt;
&lt;/ul&gt;
</template>
</v-two-code>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Правила</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ol class="list-num">
    <li>Алгоритм не будет пытаться сопоставить поддеревья компонентов разных типов. Если вы заметите за собой, что пытаетесь чередовать компоненты разных типов с очень схожим выводом, то желательно сделать их компонентами одного типа</li>
    <li>Ключи должны быть стабильными, предсказуемыми и уникальными. Нестабильные ключи (например, произведённые с помощью Math.random()) вызовут необязательное пересоздание многих экземпляров компонента и DOM-узлов, что может вызывать ухудшение производительности и потерю состояния у дочерних компонентов</li>
</ol>
</div><div id="react-js/reconciler/fiber"><h2>React Fiber Architecture</h2>

<u-link-wrapper>
    <a href="https://www.youtube.com/watch?v=4p9ISqIx1zI" target="_blank">YouTube. Лин Кларк. Как Fiber сделал React значительно быстрее</a>
</u-link-wrapper>

<ul class="list-point">
    <li><u-text-define>React Fiber</u-text-define> - переделанная реализация алгоритма reconciliation</li>
    <li>Цель Fiber - позволить React воспользоваться <u>планированием</u></li>

    <hr>
    <li><u-text-define>Планирование</u-text-define> - это процесс, который определяет когда работа должна быть выполнена</li>
    <li><u-text-define>Работа</u-text-define> - любые вычисления, которые должны быть выполнены. Работа – это обычно результат апдейта (например вызов setState)</li>

    <hr>
    <li><u-text-underline>Цель</u-text-underline> в увеличении производительности при разработке таких задач как анимация, организация элементов на странице и движение элементов</li>
    <li><u-text-underline>Главная особенность</u-text-underline> - инкрементный рендеринг: способность разделять работу рендера на единицы и распределять их между множественными фреймами.</li>
</ul>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Сравнение с предыдущим алгоритмом</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
    <li>Предудущий алгоритм обходит всё дерево компонент рекурсивно и вызывает все render-функции в рамках одного тика Event Loop.</li>
</ul>

<hr>

<ol class="list-num">
	<li><u-text-underline>Откладывание вызовов функций render</u-text-underline>. Появляется некоторая асинхронность. Н-р: если часть приложения находится вне экрана, то не нужно стоить ее Virtual DOM сразу</li>
	<li><u-text-underline>Приоритезация рендеринга</u-text-underline> для более приоритетных задач: анимация пользовательских действий. Менее приоритеное: отображение большой части контента, загруженной по сети</li>
</ol>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Возможности</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<!------------------------------------------------------------->
<h4>Планировщик</h4>
<!------------------------------------------------------------->
<i>Инкрементный рендеринг: способность разделять работу рендера на единицы и распределять их между множественными фреймами</i>

<ul class="list-point">
    <li>Остановить работу и вернуться к ней позже</li>
    <li>Приоритизировать разные типы работы</li>
    <li>Переиспользовать результаты предыдущей работы</li>
    <li>Отменить работу, если она больше не нужна</li>
</ul>

<hr>

<ul class="list-point">
    <li>При этом Virtual DOM должен быть разбит на маленькие участки для которых можно выполнять эти действия. Появляется концепция Unit of work.</li>
    <li><u>Идея</u>: реализовать собственную стековую машину на React, не использую Call Stack V8</li>
</ul>

<!------------------------------------------------------------->
<h4>Прочие</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li>Согласование примитивов</li>
</ul>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Приоритеты</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<v-code lang="bash" title="">
Synchronous  # аналогично с Call Stack V8
Task         # before next tick
Animation    # before next frame
High         # наивысший приоритет
Low          # минимальный приоритет
Offscreens   # объекты за пределами экрана
</v-code>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Фазы</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
    <li>Фазу 1 можно прервать</li>
    <li>Фазу 2 нельзя прервать</li>
</ul>

<img src="/@img/react/reconciler/phases.png" width="700px">

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Реализация Fiber</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
    <li>Задача: в компоненте List есть кнопка и список с цифрами. При нажатии на кнопку, каждое число возводится в квадрат.</li>
</ul>

<img src="/@img/react/reconciler/reconciler.png" width="650px">

<ul class="list-point">
    <li><u-text-underline>Fiber - объект</u-text-underline></li>
    <li>У каждого компонента есть свой Fiber</li>
</ul>

<v-code lang="js" title="">
// Для связи с инстансом
{
	stateNode
}
</v-code>

<v-code lang="js" title="">
// Fiber знает про другие Fibers в дереве
// Отношения, которые отслеживает Fiber
{
	child
	return
	sibling
}
</v-code>

</div><div id="react-js/info/info"><h2>Информация</h2>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Документация</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<u-link-wrapper>
	<a href="https://ru.reactjs.org/docs/getting-started.html" target="_blank">Документация</a>
	<a href="https://legacy.gitbook.com/@maxfarseer" target="_blank">GitBook</a>
	<a href="https://habr.com/ru/company/ruvds/blog/447134/" target="_blank">Учебный курс по React</a>
	<a href="https://habr.com/ru/company/ruvds/blog/471040/" target="_blank">ePUB-версия руководства по React</a>
</u-link-wrapper>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Библиотеки</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<u-link-wrapper>
    <a href="https://github.com/gre/gl-react" target="_blank"><em>WebGL Shaders</em></a>
    <a href="https://github.com/Flipboard/react-canvas" target="_blank"><em>Canvas</em></a>
</u-link-wrapper>

<ul class="list-point">
	<li><u-text-define>React</u-text-define> (2013 год) - JavaScript-библиотека для разработки пользовательского интерфейса</li>
	<li>Вместо того, чтобы искусственно разделить технологии, помещая разметку и логику в разные файлы, React разделяет ответственность с помощью слабо связанных единиц, называемых «компоненты», которые содержат и разметку и логику (React - это только представление)</li>
    <li>React создает легковесное дерево из JavaScript-объектов для имитации DOM-дерева. Затем он создает из них HTML, который вставляется или добавляется к нужному DOM-элементу, что вызывает перерисовку страницы в браузере</li>
</ul>

<ol class="list-num">
    <b>Принципы</b>
    <li>Компоненты (модульный принцип, разделение UI на коллекция компонентов)</li>
    <li>Реактивность</li>
    <li>Реализует только View слой, вместо полного стека MVC</li>
</ol>

<ol class="list-num">
    <b>Преимущества</b>
    <li>Меньшая абстракция по сравнению с Angular и Vue. Можно более детально и точечно использовать силу реакта и писать более эффективные приложения</li>
    <li>React-библиотека. Для создания приложения можно использовать любой набор инструментов, не ограничены рамками фреймворка. Позволяет создавать гибкие решения</li>
    <li>Развитое сообщество</li>
</ol>

<ol class="list-num">
    <b>Концепции</b>
    <li>Компоненты</li>
    <li>JSX</li>
    <li>State</li>
    <li>Props</li>
</ol>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>React 16.0</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
    <li><em>Фрагменты</em> - позволяют формировать список дочерних элементов, не создавая лишних узлов в DOM</li>
    <li><em>Обработка ошибок (error boundaries)</em> - специальные компоненты, которые перехватывают ошибки в своём поддереве и позволяют вывести резервный UI</li>
    <li><em>Порталы</em> - рендера дочерних компонентов в DOM-узел, который находится за пределами дерева родительского компонента</li>
    <li><em>Поддержка произвольных DOM-атрибутов</em> - вместо игнорирования неизвестных HTML и SVG атрибутов, теперь React будет просто передавать их в DOM</li>
    <li><em>Улучшения в серверном рендере</em> - поддерживает стриминг, так что вы можете быстрее начинать отправлять байты клиенту. И благодаря новой стратегии сборки, которая убирает из кода обращения к process.env (хотите верьте, хотите — нет, но чтение process.env в Node очень медленное!), вам больше не надо бандлить React для получения хорошей производительности серверного рендеринга</li>
    <li><em>Уменьшенный размер файла</em></li>
</ul>

<hr>
<ul class="list-point">
    <li>React 16 зависит от коллекций Map и Set. Если вы поддерживаете старые браузеры и устройства, в которых нет этого нативно (напр. IE < 11), используйте полифилы, такие как core-js или babel-polyfill</li>
</ul>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Композиция вместо наследования</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
    <li><u-text-define>Композиция</u-text-define> - соединение мальньких или простых частей воедино для создания более крупных частей</li>
    <li>Для переиспользования кода между компонентами рекомендуется использовать композицию вместо наследования</li>
    <li>Если вы хотите переиспользовать не связанную с внешним видом функциональность между компонентами, извлеките её в отдельный JavaScript-модуль. Импортируйте его в компонент и используйте эту функцию, объект или класс, не расширяя их</li>
</ul>
</div><div id="react-js/info/patterns"><h2>Шаблоны проектирования в React</h2>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Шаблоны</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<!------------------------------------------------------------->
<h4>1. Шаблон <u-code-text>«Провайдер»</u-code-text></h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li>API React Context</li>
    <li>Компонент верхнего уровня называется провайдером (provider). Он записывает в контекст какие-то значения. Компонент-потомок, называемый потребителем (consumer), берёт эти значения из контекста.</li>
</ul>

<!------------------------------------------------------------->
<h4>2. Шаблон High Order Component (Компоненты высшего порядка). <u-code-text>«Декоратор?»</u-code-text></h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li>Идея повторного использования кода</li>
    <li>Компонент высшего порядка - это функция, которая принимает входной компонент и возвращает расширенную или изменённую версию этого компонента</li>
</ul>

<!------------------------------------------------------------->
<h4>3. Шаблон «render props»</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li>Шаблон «функция как потомок»</li>
    <li>Позволяет достичь того же самого, что достижимо с помощью компонентов высшего порядка</li>
    <li><u>Идея</u>: передача управления вашей функцией рендеринга другому компоненту, который затем возвращает управление через свойство, являющееся функцией</li>
    <li>Некоторые предпочитают применять для достижения того же эффекта динамические свойства, или просто используют this.props.children.</li>
</ul>

<v-code lang="js" title="">
&lt;div&gt;{() =&gt; { return "hello world!»}()}&lt;/div&gt;
</v-code>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Прочее</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<!------------------------------------------------------------->
<h4>1. Conditional Rendering (Условный рендеринг)</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
return (
	{condition ? (&lt;h1&gt;Hello&lt;/h1&gt;) : null}
)
</v-code>

<!------------------------------------------------------------->
<h4>2. Passing down props (Передача свойств вниз по дереву компонентов)</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
&lt;Layout  title="Hi" name="Alex" /&gt;
</v-code>

<!------------------------------------------------------------->
<h4>3. Destructuring props (Деструктурирование свойств)</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
const Layout = ({ title, name }) => ();
</v-code>

<!------------------------------------------------------------->
<h4>4. Event switch (Переключатель событий)</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li>Для того, чтобы не писать много обработчиков событий, все события объединяют в один</li>
</ul>

<v-code lang="js" title="">
// A lot of methods
handleClick() { ... }
handleMouseEnter() { ... }
handleMouseLeave() { ... }

// One Event switch
handleEvent({ type }) {
    switch(type) {
        case 'click':      return ...
        case 'mouseenter': return ...
        case 'mouseenter': return ...
        default:           return ...
    }
}
</v-code>

<!------------------------------------------------------------->
<h4>5. Array as children (Массив как потомок)</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
const App = ({ children }) => [
    &lt;Navigation key="navigation" /&gt;,
    &lt;Main key="main"&gt;{children}&lt;/Main&gt;,
    &lt;Footer key="footer" /&gt;,
]
</v-code>
</div><div id="react-js/info/structure"><h2>Структура</h2>

<ul class="list-point">
	<li>Один компонент <u-code-text>App</u-code-text> находится на самом верху</li>
	<li>Существует два типа «модели» данных: пропсы <u-code-text>this.props</u-code-text> и состояние <u-code-text>this.state</u-code-text></li>
</ul>

<v-code lang="js" title="Component App">
import React, {Component} from 'react';

export default class App extends Component {
	<u-code-wrapper><u-code-title>Конструктор</u-code-title>
	constructor(props) {
		super(props);
		<u-code>this.state</u-code> = {
			name: 'Tony'
		};
	}
	</u-code-wrapper>

	<u-code-wrapper><u-code-title>Методы</u-code-title>
	changeName(name) {
		// синхронно
		<u-code>this.setState</u-code>({
			name: name
		});
		// асинхронно
		<u-code>this.setState</u-code>((state, props) => ({
			info: state.name + props.age
		}));
	}
	// обработчик события
	handleClick = () => {
		let name = this.state.name;   // обращение к свойству
		this.changeName('Jack');      // обращение к методу
        this.info = 'Start Variable'; // новое свойство (не видно в render)
	}
	</u-code-wrapper>

	<u-code-wrapper><u-code-title>Методы жизненного цикла</u-code-title>
	componentDidMount()    { ... }
	componentWillUnmount() { ... }
	componentDidUpdate()   { ... }
	</u-code-wrapper>

	<u-code-wrapper><u-code-title>Рендер</u-code-title>
	render() {
		return (
			&lt;h2&gt;
				&lt;ComponentA param="data" /&gt;
				{<u-code>this.state</u-code>.name}
				{<u-code>this.props</u-code>.age}
				&lt;button onClick={this.handleClick}&gt;Ok&lt;/button&gt;
			&lt;/h2&gt;
		);
	}
	</u-code-wrapper>
}
</v-code>

<v-code lang="js" title="ReactDOM.render">
ReactDOM.render(
	&lt;App age="25" /&gt;,
	document.getElementById('root')
);
</v-code>

<v-code lang="html" title="html">
&lt;div id="root"&gt;&lt;/div&gt;
</v-code>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Структура проекта</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<img src="/@img/react/tree3.png" class="inline" width="200px">
<img src="/@img/react/tree2.png" class="inline">
<img src="/@img/react/tree1.png" class="inline">

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Пример структуры проекта</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<v-code lang="html" title="./public/index.html">
&lt;div id="root"&gt;&lt;/div&gt;
</v-code>

<v-code lang="js" title="./src/index.js">
import React from 'react';
import ReactDOM from 'react-dom';
import './index.css';
import App from './components/App/App';

ReactDOM.render(&lt;App /&gt;, document.getElementById('root'));
</v-code>

<v-code lang="js" title="./src/components/App/App.js">
import React from 'react';
import logo from '../../assets/logo.svg';

export default class App extends React.Component {
	render() {
		return (
			&lt;div&gt;
				&lt;img src={logo} /&gt;
			&lt;/div&gt;
		);
	}
}
</v-code>
</div><div id="react-js/info/components"><h2>Компоненты</h2>

<ul class="list-point">
	<li><u-text-define>Компоненты</u-text-define> - позволяют разбить интерфейс на независимые части, про которые легко думать в отдельности. Их можно складывать вместе и использовать несколько раз</li>
	<li>Во многом компоненты ведут себя как обычные функции JavaScript. Они принимают произвольные входные данные («<u>пропсы</u>») и возвращают React-элементы, описывающие, что мы хотим увидеть на экране</li>
	<li>Принцип единственной ответственности: каждый компонент по-хорошему должен заниматься какой-то одной задачей</li>
    <li>Всегда называйте компоненты с заглавной буквы. Если компонент начинается с маленькой буквы, React принимает его за DOM-тег. Например, <u-code-text>&lt;div /&gt;</u-code-text> это div-тег из HTML, а <u-code-text>&lt;Welcome /&gt;</u-code-text> это уже наш компонент <u-code-text>Welcome</u-code-text>, который должен быть в области видимости</li>
</ul>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Классовые компоненты: import React</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<v-code lang="js" title="">
import React from 'react';
class App extends <u-code>React.Component</u-code> { ... }
</v-code>

<v-code lang="js" title="">
import { Component } from 'react';
class App extends <u-code>Component</u-code> { ... }
</v-code>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Классовые компоненты: задание state</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
    <li>Использование конструктора в компоненте необходимо когда <u>state зависит от props</u> и для нормализации props нужны дополнительные алгоритмы</li>
</ul>

<v-two-code type="js;js" comment="Свойство;Конструктор">
<template v-slot:first>
class App extends React.Component {
	state = {
	    name: 'Tony'
	}
}
</template>
<template v-slot:last>
class App extends React.Component {
	constructor(props) {
	    super(props);
	    this.state = {
	        name: 'Tony'
	    };
	}
}
</template>
</v-two-code>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Функциональные и классовые компоненты</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<v-two-code type="js;js" comment="Функциональный;Классовый">
<template v-slot:first>
const App = (props) => {
	return &lt;h1&gt;Привет, {props.name}&lt;/h1&gt;;
}
// функция получает данные через props
// возвращает React-элемент
</template>
<template v-slot:last>
class App extends React.Component {
	render() {
		return &lt;h1&gt;Привет, {this.props.name}&lt;/h1&gt;;
	}
}
</template>
</v-two-code>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Компоненты с пропсами</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<v-two-code type="js;js" comment="Классовый компонент;Функциональный компонент">
<template v-slot:first>
class App extends React.Component {
	<u-code>render()</u-code> {
		return (
			&lt;div&gt;
				&lt;Button name="Кнопка" /&gt;
			&lt;/div&gt;
		);
	}
}

class Button extends React.Component {
	<u-code>render()</u-code> {
		return &lt;button&gt;{<u-code>this.props.name</u-code>}&lt;/button&gt;;
	}
}
</template>
<template v-slot:last>
const App = () => {
	return (
		&lt;div&gt;
			&lt;Button name="Кнопка" /&gt;
		&lt;/div&gt;
	);
}

const Button = (props) => {
	return &lt;button&gt;{props.name}&lt;/button&gt;;
}
</template>
</v-two-code>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Импорт и экспорт</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<v-code lang="js" title="">
<u-code>import</u-code> Header from '../Header';

<u-code>export default</u-code> class App extends React.Component { ... }

class App extends React.Component { ... }
<u-code>export default</u-code> App;
</v-code>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Классовые компоненты на jsx и js</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<v-two-code type="js;js" comment="jsx;js">
<template v-slot:first>
class App extends React.Component {
	render() {
		return &lt;button&gt;Кнопка&lt;/button&gt;;
	}
}
ReactDOM.render(
	&lt;App /&gt;,
	document.getElementById('root')
);
</template>
<template v-slot:last>
const e = React.<u-code>createElement</u-code>;
class App extends React.Component {
	render() {
		return <u-code>e</u-code>('button', null, 'Кнопка');
	}
}
ReactDOM.render(
	<u-code>e</u-code>(App),
	document.getElementById('root')
);
</template>
</v-two-code>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Структура классового компонента</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<v-code lang="js" title="">
Component =  {
    state: Object
    props: Object,
    context: undefined,
    refs: Object,
    updater: {
        function isMounted()
        function enqueueForceUpdate()
        function enqueueReplaceState()
        function enqueueSetState()
    }
    &lt;constructor&gt;: "Component"
}
</v-code>
</div><div id="react-js/info/props"><h2>Пропсы (props)</h2>

<ul class="list-point">
    <li><u-text-define>this.props</u-text-define> - содержит свойства, которые были определены тем, кто вызывает этот компонент (способ передачи данных от родителя к потомку)</li>
    <li><u-text-inderline>props только на чтение</u-text-inderline></li>
	<li>Пропсы можно только читать. React-компоненты обязаны вести себя как чистые функции по отношению к своим пропсам (не должен что-то записывать в свои пропсы)</li>
	<li>Компоненты могут принимать произвольные пропсы, включая примитивные значения, React-элементы или функции</li>
	<hr>

    <li>В конструкоре классового компонента <u-code-text>super(props)</u-code-text> - передаём <u-code-text>props</u-code-text> базовому (родительскому) конструктору. Классовые компоненты всегда должны вызывать базовый конструктор с аргументом <u-code-text>props</u-code-text></li>
    <li>Существует специальный проп <u-code-text>this.props.children</u-code-text>, который обычно определяется дочерними тегами в JSX-выражении, а не в самом теге</li>
</ul>
</div><div id="react-js/api/jsx"><h2>JSX</h2>

<ul class="list-point">
	<li>Каждый <u>JSX-элемент</u> - это просто синтаксический сахар для вызова <u-code-text>React.createElement(component, props, ...children)</u-code-text>. Так что всё, что вы можете сделать при помощи JSX, может быть сделано на чистом JavaScript</li>
</ul>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Особенности</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
    <li><u>null</u>, <u>undefined</u>, <u>true</u>, <u>false</u> игнорируются</li>
    <li><u>object</u> нельзя использовать</li>
</ul>

<v-code lang="js" title="">
const arr = [];
{arr.length &amp;&amp; &lt;Component /&gt;} // =&gt; 0
!!arr.length &amp;&amp; &lt;Component /&gt;
</v-code>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Тернарные операторы</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<v-code lang="html" title="">
{active
	? &lt;Typography&gt;Yes&lt;/Typography&gt;
	: &lt;Typography&gt;No&lt;/Typography&gt;
}
</v-code>

<v-code lang="html" title="">
{active
	? (
		&lt;Typography&gt;
			Yes
		&lt;/Typography&gt;
	) : (
		&lt;Typography&gt;
			No
		&lt;/Typography&gt;
	)
}
</v-code>

<v-code lang="js" title="">
return (
    &lt;&gt;
        {isMobile
            ? (&lt;h1&gt;Code Mobile&lt;/h1&gt;)
            : (&lt;ActivityFormPC
                &lt;h1&gt;Code PC&lt;/h1&gt;
            /&gt;)
        }
    &lt;/&gt;
);
</v-code>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Установка babel</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<v-code lang="bash" title="">
npm init -y                                                 # инициализация
npm i babel-cli@6 babel-preset-react-app@3                  # babel
npx babel --watch src --out-dir . --presets react-app/prod  # наблюдение за директорией src
</v-code>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Render</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<v-code lang="html" title="html">
&lt;div id="root"&gt;&lt;/div&gt;
</v-code>

<v-two-code type="js;js" comment="jsx;js">
<template v-slot:first>
const element = &lt;h2&gt;Hi&lt;/h2&gt;;
ReactDOM.render(
	element, 
	document.getElementById('root')
);
</template>
<template v-slot:last>
var element = React.<u-code>createElement</u-code>('h2', null, 'Hi');
ReactDOM.render(
	element, 
	document.getElementById('root')
);
</template>
</v-two-code>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Варианты</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<!------------------------------------------------------------->
<h4>Переменные</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
// переменная
const name = 'Tony';
const element = &lt;h2&gt;Hi, {name}&lt;/h2&gt;;
</v-code>

<v-code lang="js" title="">
// чтобы использовать строковый литерал в качестве атрибута, используются кавычки
const element = &lt;div tabIndex="0"&gt;&lt;/div&gt;;
</v-code>

<v-code lang="js" title="">
// чтобы указать JavaScript-выражение в качестве атрибута, используются фигурные скобки
const path = '../img/1.png';
const element = &lt;img src={path}&gt;&lt;/img&gt;;
</v-code>

<ul class="list-point">
	<li>Не ставьте кавычек вокруг фигурных скобок, когда используете JavaScript-выражение в атрибуте. Следует либо применить кавычки (для строковых литералов), либо фигурные скобки (для выражений), но не то и другое вместе</li>
	<li>Поскольку <u>JSX</u> ближе к JavaScript чем к HTML, <u>React DOM</u> использует стиль именования <u>camelCase</u> для свойств вместо обычных имён HTML-атрибутов. Например, <u-code-text>class</u-code-text> становится <u-code-text>className</u-code-text> в JSX, а <u-code-text>tabindex</u-code-text> становится <u-code-text>tabIndex</u-code-text></li>
</ul>

<!------------------------------------------------------------->
<h4>Результат вызова JavaScript-функции </h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
function getName() {
	return 'Tony';
}
const element = &lt;h2&gt;Hi, {getName()}&lt;/h2&gt;;
</v-code>

<ul class="list-point">
	<li>При разбитии JSX на несколько строк рекомендуется заключать всё выражение целиком в круглые скобки, чтобы избежать проблем, связанных с автоматической вставкой точек с запятой</li>
</ul>

<v-code lang="js" title="">
const element = (
	&lt;h2&gt;
		Hi
	&lt;/h2&gt;
);
</v-code>

<!------------------------------------------------------------->
<h4>Использование внутри выражений</h4>
<!------------------------------------------------------------->
<ul class="list-point">
	<li>После компиляции каждое JSX-выражение становится обычным вызовом JavaScript-функции, результат которого - объект JavaScript</li>
	<li>Из этого следует, что JSX можно использовать внутри выражений if и циклов for, присваивать переменным, передавать функции в качестве аргумента и возвращать из функции</li>
</ul>

<v-code lang="js" title="">
function getGreeting(admin) {
	if (admin) {
		return &lt;h2&gt;Hello&lt;/h2&gt;;
	}
	return &lt;h2&gt;Bye&lt;/h2&gt;;
}
</v-code>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>JSX предотвращает атаки, основанные на инъекции кода</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
	<li>Данные, введённые пользователем, можно безопасно использовать в JSX</li>
	<li>По умолчанию React DOM экранирует все значения, включённые в JSX перед тем как отрендерить их. Это гарантирует, что вы никогда не внедрите чего-либо, что не было явно написано в вашем приложении. Всё преобразуется в строчки, перед тем как быть отрендеренным. Это помогает предотвращать атаки межсайтовым скриптингом (XSS).</li>
</ul>

<v-code lang="js" title="">
const title = response.potentiallyMaliciousInput;
const element = &lt;h1&gt;{title}&lt;/h1&gt;; // этот код безопасен
</v-code>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>JSX представляет собой объекты</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
	<li>Babel компилирует JSX в вызовы <u-code-text>React.createElement()</u-code-text></li>
</ul>


<v-two-code type="js;js" comment="js (babel);js">
<template v-slot:first>
const element = (
	&lt;h1 className="greeting"&gt;
		Hello, world!
	&lt;/h1&gt;
);
</template>
<template v-slot:last>
const element = React.createElement(
	'h1',
	{className: 'greeting'},
	'Привет, мир!'
);
</template>
</v-two-code>

<ul class="list-point">
	<li><u-code-text>React.createElement()</u-code-text> проводит некоторые проверки с целью выявить баги в коде, но главное — создаёт объект похожий на такой</li>
	<li>Эти объекты называются React-элементами. Можно сказать, что они описывают результат, который мы хотим увидеть на экране. React читает эти объекты и использует их, чтобы конструировать и поддерживать DOM</li>
</ul>

<v-code lang="js" title="">
// этот код несколько упрощён
const element = {
	type: 'h1',
	props: {
		className: 'greeting',
		children: 'Привет, мир!'
	}
};
</v-code>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Особенности тегов</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<v-code lang="html" title="">
&lt;input aria-label={} /&gt;    &lt;!-- aria-label --&gt;
&lt;label htmlFor=""&gt;&lt;/label&gt; &lt;!-- for --&gt;
</v-code>
</div><div id="react-js/api/children"><h2>Children</h2>

<div class="v-method-wrapper">
    <v-method before="props." method="children" after="" arg="">
    передаст дочерние элементы сразу на вывод
    </v-method>
</div>

<div class="v-method-wrapper">
    <v-method before="React." method="Children" after="" arg="">
    предоставляет функции для работы с непрозрачной структурой данных this.props.children
    </v-method>
</div>

<div class="v-method-wrapper">
    <v-method before="React." method="Children" after=".map" arg="(children, function[(thisArg)])">
    Вызывает функцию для каждого непосредственного потомка, содержащегося в children передавая их по очереди в thisArg
	<ul class="list-point">
		<li>Если children - массив, он будет пройден, и функция будет вызвана для каждого потомка в массиве</li>
		<li>Если children равен null или undefined, этот метод вернёт null или undefined, а не массив</li>
	    <li>Если children - Fragment, он будет рассматриваться как целый потомок, а элементы внутри не будут пройдены</li>
	</ul>
    </v-method>

	<v-method-arg arg="children">потомок</v-method-arg>
	<v-method-arg arg="function[(thisArg)]">функция по для обработки каждого потомка</v-method-arg>

	<v-method-return>массив / null / undefined</v-method-return>
</div>

<v-code lang="js" title="">
const App = () =&gt; (
	&lt;Child color="blue"&gt;
		&lt;span&gt;item-1&lt;/span&gt;
		&lt;span&gt;item-2&lt;/span&gt;
		&lt;span&gt;item-3&lt;/span&gt;
	&lt;/Child&gt;
);

const Child = (props) =&gt; (
	&lt;&gt;
		{props.color}

		{/* Вывод сразу всех значений */}
		{<u-code>props.children</u-code>}

		{/* Перебор всех значений */}
		{<u-code>React.Children.map</u-code>(props.children, (child, index) =&gt; {
			return &lt;li&gt;{child}&lt;/li&gt;
		})}
	&lt;/&gt;
);
</v-code>

<!------------------------------------------------------------->
<h4>Передача в child массива</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
const App = () =&gt; (
	&lt;Child color="blue"&gt;
		{['First', 'Second', 'Third']}
	&lt;/Child&gt;
);

const Child = (props) =&gt; (
	&lt;&gt;
		{props.children}
	&lt;/&gt;
);
</v-code>

<!------------------------------------------------------------->
<h4>Передача в child функции (Render Props)</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
const App = () =&gt; (
	&lt;Child color="blue"&gt;
		{(element) =&gt; {
			return &lt;h2&gt;{element}&lt;/h2&gt;
		}}
	&lt;/Child&gt;
);

const Child = (props) =&gt; {
	return (
		&lt;&gt;
			{props.children('test')}
		&lt;/&gt;
	);
};
</v-code>
</div><div id="react-js/api/context"><h2>Контекст</h2>

<ul class="list-point">
    <li><u-text-define>Контекст</u-text-define> - позволяет передавать данные через дерево компонентов без необходимости передавать пропсы на промежуточных уровнях</li>
    <li>Контекст разработан для передачи данных, которые можно назвать «глобальными» для всего дерева React-компонентов</li>
    <li>В типичном React-приложении данные передаются сверху вниз (от родителя к дочернему компоненту) с помощью пропсов. Однако, этот способ может быть чересчур громоздким для некоторых типов пропсов (например, выбранный язык, UI-тема), которые необходимо передавать во многие компоненты в приложении. Контекст предоставляет способ делиться такими данными между компонентами без необходимости явно передавать пропсы через каждый уровень дерева</li>
    <li>Усложняет переиспользование компонентов</li>
</ul>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>API</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<!------------------------------------------------------------->
<h4>1. React.createContext</h4>
<!------------------------------------------------------------->

<div class="v-method-wrapper">
    <v-method before="React." method="createContext" after="" arg="(defaultValue)">
    создание объекта Context. Когда React рендерит компонент, который подписан на этот объект, React получит текущее значение контекста из ближайшего подходящего <u>Provider</u> выше в дереве компонентов
    </v-method>
    <v-method-arg arg="defaultValue">аргумент используется только в том случае, если для компонента нет подходящего <u>Provider</u> выше в дереве. Если передать <u>undefined</u> как значение <u>Provider</u>, компоненты, использующие этот контекст, не будут использовать <u>defaultValue</u></v-method-arg>
	<v-method-return>Объект Context</v-method-return>
</div>


<v-code lang="js border" title="">
const MyContext = React.createContext(defaultValue);
</v-code>


<!------------------------------------------------------------->
<h4>2. Context.Provider (в JSX)</h4>
<!------------------------------------------------------------->
<div class="v-method-wrapper">
    <v-method before="<MyContext." method="Provider" after="" arg=" value={} >">
	Компонент используется для передачи текущего значения по дереву. Любой дочерний компонент может использовать этот контекст
    </v-method>
    <v-method-arg arg="MyContext">объект Context</v-method-arg>
    <v-method-arg arg="value">некоторое значение</v-method-arg>
</div>

<ul class="list-point">
    <li>Один Provider может быть связан с несколькими компонентами, потребляющими контекст. Так же Provider компоненты могут быть вложены друг в друга, переопределяя значение контекста глубже в дереве</li>
    <li>Все потребители, которые являются потомками <u>Provider</u>, будут повторно рендериться, как только проп <u>value</u> у <u>Provider</u> изменится. Потребитель перерендерится при изменении контекста, даже если его родитель, не использующий данный контекст, блокирует повторные рендеры с помощью <u>shouldComponentUpdate</u></li>
    <ul class="list-point">
        <li><u-code-text>value</u-code-text> - значение контекста. Проп <u>value</u> будут передан во все компоненты, использующие этот контекст и являющиеся потомками этого <u>Provider</u> компонента</li>
    </ul>
</ul>

<!------------------------------------------------------------->
<h4>3. Class.contextType</h4>
<!------------------------------------------------------------->
<div class="v-method-wrapper">
    <v-method before="Class." method="contextType" after="" arg="(defaultValue)">
	Определяет <u>contextType</u>, чтобы получить значение контекста. React найдёт (выше по дереву) ближайший <u>Provider-компонент</u>, предоставляющий этот контекст, и использует его значение
    </v-method>
</div>

<ul class="list-point">
    <li>В свойство класса <u>contextType</u> может быть назначен объект контекста, созданный с помощью <u>React.createContext()</u>. Это позволяет использовать ближайшее и актуальное значение указанного контекста при помощи <u>this.context</u>. В этом случае вы получаете доступ к контексту, как во всех методах жизненного цикла, так и в рендер методе</li>
    <li>Можно подписаться только на один контекст, используя этот API</li>
</ul>

<v-code lang="js border" title="">
class MyClass extends React.Component {
	static contextType = MyContext;
	render() {
		{this.context}
	}
}
</v-code>

<!------------------------------------------------------------->
<h4>4. Context.Consumer</h4>
<!------------------------------------------------------------->
<div class="v-method-wrapper">
    <v-method before="<MyContext." method="Consumer" after=">" arg="">
	React-компонент, который подписывается на изменения контекста. В свою очередь, это позволяет вам подписаться на контекст в функциональном компоненте
    </v-method>
</div>

<ul class="list-point">
    <li><u>Consumer</u> принимает функцию в качестве дочернего компонента. Эта функция принимает текущее значение контекста и возвращает React-компонент. Передаваемый аргумент <u>value</u> будет равен ближайшему (вверх по дереву) значению этого контекста, а именно пропу <u>value Provider</u> компонента. Если такого <u>Provider</u> компонента не существует, аргумент <u>value</u> будет равен значению <u>defaultValue</u>, которое было передано в <u>createContext()</u></li>
</ul>

<v-code lang="html border" title="">
&lt;MyContext.Consumer&gt;
	{value =&gt; /* отрендерить что-то, используя значение контекста */}
&lt;/MyContext.Consumer&gt;
</v-code>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Пример</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<v-code lang="js" title="">
import React, { Component } from 'react';

const ThemeContext = <u-code>React.createContext</u-code>('light');

export default class App extends Component {
	render() {
		return (
			<u-code>&lt;ThemeContext.Provider value="dark"&gt;</u-code>
				&lt;Toolbar /&gt;
			<u-code>&lt;/ThemeContext.Provider&gt;</u-code>
		);
	}
}
</v-code>

<v-code lang="js" title="">
// Компонент, который находится в середине,
// теперь не должен явно передавать UI-тему вниз
class Toolbar extends Component {
	render() {
		return (
			&lt;div&gt;
				&lt;ThemedButton /&gt;
			&lt;/div&gt;
		);
	}
}
</v-code>

<v-code lang="js" title="">
// 1. Используя contextType
class ThemedButton extends Component {
	<u-code>static contextType = ThemeContext;</u-code>
	render() {
		return (
			&lt;div&gt;
				<u-code>{this.context}</u-code>
			&lt;/div&gt;
		);
	}
}

// 2. Используя Context.Consumer
class ThemedButton extends Component {
	render() {
		return (
			&lt;div&gt;
				<u-code-wrapper>
				&lt;ThemeContext.Consumer&gt;
					{value =&gt; &lt;h2&gt;{value}&lt;/h2&gt;}
				&lt;/ThemeContext.Consumer&gt;
				</u-code-wrapper>
			&lt;/div&gt;
		);
	}
}
</v-code>



</div><div id="react-js/api/refs"><h2>Рефы и DOM</h2>

<div class="v-method-wrapper">
    <v-method before="React." method="createRef" after="" arg="()">
    Создаёт реф, который можно прикрепить к React-элементам через атрибут ref
    </v-method>
	<v-method-return>Реф</v-method-return>
</div>

<div class="v-method-wrapper">
    <v-method before="React." method="forwardRef" after="" arg="()">
    Создаёт React компонент, который перенаправляет атрибут ref, что он получает, другому компоненту ниже в дереве
    </v-method>
	<v-method-return>React компонент</v-method-return>
</div>

<ul class="list-point">
    <li><u-text-define>Рефы</u-text-define> дают возможность получить доступ к DOM-узлам или React-элементам, созданным в рендер-методе. Используется когда требуется императивно изменить дочерний элемент, обойдя обычный поток данных</li>

    <li><b>Примеры использования</b></li>
    <ul class="list-point">
        <li>Управление фокусом, выделение текста или воспроизведение медиа</li>
        <li>Императивный вызов анимаций</li>
        <li>Интеграция со сторонними DOM-библиотеками</li>
    </ul>
	
	<b>Значение рефа отличается в зависимости от типа узла:</b>
	<ol class="list-num">
	    <li><u-text-underline>HTML-элемент</u-text-underline> - свойство <u-code-text>current</u-code-text> созданного рефа в конструкторе с помощью <u-code-text>React.createRef()</u-code-text> получает соответствующий DOM-элемент. React присвоит DOM-элемент свойству <u-code-text>current</u-code-text> при монтировании компонента и присвоит обратно значение <u-code-text>null</u-code-text> при размонтировании. Обновление свойства <u-code-text>ref</u-code-text> происходит перед вызовом методов <u-code-text>componentDidMount</u-code-text> и <u-code-text>componentDidUpdate</u-code-text></li>

	    <li><u-text-underline>Классовый компонент</u-text-underline> - свойство <u-code-text>current</u-code-text> объекта-рефа получает экземпляр смонтированного компонента</li>

	    <li><u-text-underline>Функциональный компонент</u-text-underline> - нельзя использовать. Для них не создаётся экземпляров. Можно использовать атрибут ref внутри функционального компонента при условии, что он ссылается на DOM-элемент или классовый компонент</li>
	</ol>
</ul>

<!------------------------------------------------------------->
<h4>Создание рефов</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li>Рефы создаются с помощью <u-code-text>React.createRef()</u-code-text> и прикрепляются к React-элементам через <u-code-text>ref</u-code-text> атрибут. Обычно рефы присваиваются свойству экземпляра класса в конструкторе, чтобы на них можно было ссылаться из любой части компонента</li>
</ul>

<v-code lang="js" title="">
class MyComponent extends React.Component {
	constructor(props) {
		super(props);
		this.myRef = <u-code>React.createRef();</u-code>
	}
	render() {
		return &lt;div <u-code>ref={this.myRef}</u-code> /&gt;;
	}
}
</v-code>

<!------------------------------------------------------------->
<h4>Доступ к рефам</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li>Когда реф передаётся элементу в методе <u-code-text>render</u-code-text>, ссылка на данный узел доступна через свойство рефа <u-code-text>current</u-code-text></li>
</ul>

<v-code lang="js" title="">
const node = <u-code>this.myRef.current;</u-code>
</v-code>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Добавление рефа к DOM-элементу и классовому компоненту</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<v-code lang="js" title="">
import React, { Component } from 'react';

export default class App extends Component {
	constructor(props) {
		super(props);
		this.domElement     = <u-code>React.createRef()</u-code>; // ref для dom элемента
		this.classComponent = <u-code>React.createRef()</u-code>; // ref для классового компонента
	}
	handleClick = () =&gt; {
		const nodeDom       = <u-code>this.domElement.current</u-code>;
		const nodeComponent = <u-code>this.classComponent.current</u-code>;
		console.log(nodeDom, nodeComponent);
	}
	render() {
		return (
			&lt;div&gt;
				&lt;div <u-code>ref={this.domElement}</u-code>&gt;DOM element&lt;/div&gt;
				&lt;Child <u-code>ref={this.classComponent}</u-code> /&gt;
				&lt;button onClick={this.handleClick}&gt;Button&lt;/button&gt;
			&lt;/div&gt;
		);
	}
}
</v-code>

<v-two-code type="js;js" comment="Доступ к экземпляру смонтированного компонента;Доступ к DOM-элементу компонента (Перенаправление рефов)">
<template v-slot:first>
class Child extends Component {
	render() {
		return (&lt;div&gt;Class Component&lt;/div&gt;);
	}
}
</template>
<template v-slot:last>
const Child = <u-code>React.forwardRef</u-code>((props, ref) =&gt; (
	&lt;div <u-code>ref={ref}</u-code>&gt;Class Component&lt;/div&gt;
));
</template>
</v-two-code>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Пример на useRef</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<v-code lang="js red" title="">
const Component = () =&gt; {
    const valueRef = useRef(null);

    const handleClick = () =&gt; {
		// flow будет ругаться на несоответствие типов null и dom-узел
		const value = valueRef.current.querySelector('input').value;
    };

    return (
		&lt;&gt;
			&lt;div ref={valueRef}&gt;
				&lt;input type='text' value='Some message' /&gt;
			&lt;/div&gt;

			&lt;button onClick={handleClick}&gt;Click&lt;/button&gt;
		&lt;/&gt;
    );
};
</v-code>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Перенаправление рефов</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
    <li><u-text-define>Перенаправление рефов</u-text-define> позволяет автоматически передавать реф компонента одному из его дочерних элементов</li>
    <li>Перенаправление рефов позволяет взять ref из атрибутов компонента, и передать («перенаправить») его одному из дочерних компонентов</li>
    <li><b>Применение:</b> для написания библиотек</li>
</ul>

<div class="v-method-wrapper">
    <v-method before="React." method="forwardRef" after="" arg="(props, ref)">
    Получить <u>ref</u> и передать его в дочерний DOM-элемент компонента
    </v-method>

	<v-method-arg arg="props">пропсы</v-method-arg>
	<v-method-arg arg="ref">существует только в том случае, если создавать компонент через функцию React.forwardRef. Обычные функциональные или классовые компоненты не получают <u>ref</u> в качестве аргумента или пропа</v-method-arg>
</div>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Колбэк-рефы</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
    <li><u-text-define>Колбэк-рефы</u-text-define> - предоставляет более полный контроль над их присвоением и сбросом</li>
    <li>React вызовет ref колбэк с DOM-элементом при монтировании компонента, а также вызовет его со значением <u-code-text>null</u-code-text> при размонтировании. Рефы будут хранить актуальное значение перед вызовом методов <u-code-text>componentDidMount</u-code-text> или <u-code-text>componentDidUpdate</u-code-text></li>
</ul>

<v-code lang="js" title="">
import React, { Component } from 'react';

export default class App extends Component {
	constructor(props) {
		super(props);
		<u-code>this.domElement = null;</u-code>
		<u-code-wrapper>
		this.setDomElement = element =&gt; {
			this.domElement = element;
		}
		this.handleClick = () =&gt; {
			if (this.domElement) {
				console.log(this.domElement);
			}
		}
		</u-code-wrapper>
	}
	componentDidMount() {
		<u-code>this.handleClick();</u-code>
	}
	render() {
		return (
			&lt;div&gt;
				&lt;div <u-code>ref={this.setDomElement}</u-code>&gt;DOM element&lt;/div&gt;
				&lt;button onClick={this.handleClick}&gt;Button&lt;/button&gt;
			&lt;/div&gt;
		);
	}
}
</v-code>
</div><div id="react-js/api/fragments"><h2>Фрагменты</h2>

<ul class="list-point">
    <li><u-text-define>Фрагменты</u-text-define> - позволяют формировать список дочерних элементов, не создавая лишних узлов в DOM</li>
</ul>

<v-two-code type="js;js" comment="Полная запись;Сокращенная запись">
<template v-slot:first>
render() {
	return (
		<u-code>&lt;React.Fragment&gt;</u-code>
			&lt;p&gt;Привет&lt;/p&gt;
			&lt;p&gt;Мир&lt;/p&gt;
		<u-code>&lt;/React.Fragment&gt;</u-code>
	);
}
</template>
<template v-slot:last>
render() {
	return (
		<u-code>&lt;&gt;</u-code>
			&lt;p&gt;Привет&lt;/p&gt;
			&lt;p&gt;Мир&lt;/p&gt;
		<u-code>&lt;/&gt;</u-code>
	);
}
</template>
</v-two-code>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Фрагменты с ключами</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
	<li>Фрагменты, объявленные с помощью <u-code-text>&lt;React.Fragment&gt;</u-code-text>, могут иметь ключи. Например, их можно использовать при создании списка определений, преобразовав коллекцию в массив фрагментов</li>
	<li><u-code-text>key</u-code-text> - единственный атрибут, допустимый у <u-code-text>Fragment</u-code-text></li>
    <li><u>Сокращенная запись</u> не поддерживает ключи или атрибуты</li>
</ul>

<v-code lang="js" title="">
export default class App extends Component {
	constructor(props) {
		super(props);
		this.state = {
			arr: [
				{id:1, name:'Tony'},
				{id:2, name:'Steve'},
			]
		};
	}
	render() {
		return (
			&lt;div&gt;
				{this.state.arr.map(item =&gt; (
					&lt;React.Fragment <u-code>key={item.id}</u-code>&gt;
						&lt;div&gt;{item.id}&lt;/div&gt;
						&lt;div&gt;{item.name}&lt;/div&gt;
					&lt;/React.Fragment&gt;
				))}
			&lt;/div&gt;
		);
	}
}
</v-code>
</div><div id="react-js/api/portals"><h2>Порталы</h2>


<div class="v-method-wrapper">
    <v-method before="ReactDOM." method="createPortal" after="" arg="(child, container)">
    порталы позволяют рендерить дочерние элементы в DOM-узел, который находится вне DOM-иерархии родительского компонента
    </v-method>

	<v-method-arg arg="child">любой React-компонент, который может быть отрендерен, такой как элемент, строка или фрагмент</v-method-arg>
	<v-method-arg arg="container">DOM-элемент</v-method-arg>
</div>

<ul class="list-point">
    <li><u>Применение</u> - когда в родительском компоненте заданы стили <u-code-text>overflow: hidden</u-code-text> или <u-code-text>z-index</u-code-text>, но вам нужно чтобы дочерний элемент визуально выходил за рамки своего контейнера. Например, диалоги, всплывающие карточки и всплывающие подсказки</li>
    <li><u>Событие</u>, сгенерированное изнутри портала, будет распространяться к родителям в содержащем React-дереве, даже если эти элементы не являются родительскими в DOM-дереве</li>
</ul>

<hr>

<ul class="list-point">
    <li>Обычно, когда вы возвращаете элемент из рендер-метода компонента, он монтируется в DOM как дочерний элемент ближайшего родительского узла</li>
    <li>Но иногда требуется поместить потомка в другое место в DOM</li>
</ul>
<v-code lang="js" title="">
render() {
	// React *не* создаёт новый div. Он рендерит дочерние элементы в `domNode`.
	// `domNode` — это любой валидный DOM-узел, находящийся в любом месте в DOM.
	return ReactDOM.createPortal(
		this.props.children,
		domNode
	);
}
</v-code>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Пример</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<v-code lang="js" title="component">
import React, {Component} from 'react';
<u-code>import ReactDOM from 'react-dom';</u-code>

export default class App extends Component {
	render() {
		return (&lt;Child /&gt;);
	}
}

class Child extends Component {
	render() {
		<u-code-wrapper>
		return ReactDOM.createPortal(
			&lt;div&gt;Portal&lt;/div&gt;,
			document.getElementById('portal')
		);
		</u-code-wrapper>
	}
}

<u-code>ReactDOM.render(&lt;App /&gt;, document.getElementById('root'));</u-code>
</v-code>

<v-code lang="html" title="index.html">
&lt;div id="root"&gt;&lt;/div&gt;
&lt;div id="portal"&gt;&lt;/div&gt;
</v-code></div><div id="react-js/patterns/higher-order-components"><h2>Компоненты высшего порядка</h2>

<!------------------------------------------------------------->
<h4>Теория</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li><u-text-define>Компонент высшего порядка</u-text-define> (Higher-Order Component, HOC) - функция, расширяющая функционал компонента без изменение его исходного кода</li>
	<li><u-text-underline>Основано на принцике "Композиция"</u-text-underline></li>
    <li>HOC не наследует поведение оборачиваемого компонента</li>
    <li>HOC является чистой функцией без побочных эффектов</li>
	<li>Это один из продвинутых способов для повторного использования логики. HOC не являются частью API React, но часто применяются из-за композиционной природы компонентов</li>
    <li>HOC часто встречаются в сторонних библиотеках, например <u-code-text>connect</u-code-text> в Redux и <u-code-text>createFragmentContainer</u-code-text> в Relay</li>
    <li>Если обычный компонент преобразует <u>пропсы в UI</u>, то компонент высшего порядка преобразует <u>компонент в другой компонент</u>
</ul>

<!------------------------------------------------------------->
<h4>Действия</h4>
<!------------------------------------------------------------->
<ol class="list-num">
	<li>Принимает оборачиваемый компонент (оборачивает оригинальный компонент в контейнер посредством композиции)</li>
	<li>Через пропсы передает ему новые данные</li>
	<li>Возвращает новый компонент с расширенной логикой</li>
</ol>

<!------------------------------------------------------------->
<h4>Применение</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li>Переиспользование логики</li>
    <li>Есть 2 или несколько компонентов, логика которых совпадает. Чтобы не дублировать логику, можно использовать HOC</li>
    <li><b>Применение: </b>данные для аналитики</li>
</ul>

<!------------------------------------------------------------->
<h4>Предостережения</h4>
<!------------------------------------------------------------->
<ul class="list-point">
	<li>Не используйте HOC внутри рендер-метода. Происходит повторное монтирование компонента обнуляет его состояние, а также состояние его дочерних компонентов</li>
	<li>Копируйте статические методы</li>
	<li>Рефы не передаются. По соглашению компоненты высшего порядка передают оборачиваемому компоненту все пропсы, кроме рефов. ref на самом деле не проп, как, например, key, и поэтому иначе обрабатывается React. Реф элемента, созданного компонентом из HOC, будет указывать на экземпляр ближайшего в иерархии контейнера, а не на оборачиваемый компонент</li>
</ul>

<!------------------------------------------------------------->
<h4>Основано на паттерне "return function"</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
const func = (a) => {
	return (b) => {
		console.log(a + b); // 3
	}
}

func(1)(2);
</v-code>


<img src="/@img/react/hoc-elements.png" width="600px">


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Отличие "Higher-Order Component" от паттрена "Декоратор"</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
	<li>После добавления декоратора свойство/класс можно использовать только в его оформленной форме. HOC шаблон оставляет более высокий порядок, а также компоненты более низкого порядка, доступные для использования.</li>
	<li>Дектораторы используются для мутации переменной в то время как HOC рекомендуется не делать</li>
	<li>HOC должны отображать компонент, в то время как декораторы могут возвращать разные вещи в зависимости от реализации</li>
</ul>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Примеры</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<!------------------------------------------------------------->
<h4>1. Минимальный пример</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li><u-code-text>withData</u-code-text> - функция, возвращающая компонент, оборачивающий основной компонент</li>
    <li><u>withData</u> может содержать дополнительную логику</li>
    <li><u>withData</u> - пустой компонент-обертка, который вызывает компонент App и передает все свойства, которые он получил сам</li>
    <li><u>App</u> - отвечает за отображение. <u>withData</u> - отвечает за логику, можно вынести в отдельный файл и переиспользовать</li>
</ul>

<v-code lang="js border" title="">
// Оборачиваемый компонент
class App extends Component {
    render() {
      return &lt;h1&gt;Hello&lt;/h1&gt;
    }
}

// Higher-Order Component
const withData = (Wrapped) =&gt; {
    return class extends Component {
        render() {
            return &lt;Wrapped {...this.props} /&gt;
        } 
    }
}

// Компонент, обернутый в HOC
const EnhancedComponent = withData(App);

// Компонент, обернутый в HOC (на экспорт)
export default withData(App);
</v-code>

<!------------------------------------------------------------->
<h4>2. Counter</h4>
<!------------------------------------------------------------->
<u-link-wrapper>
	<a href="https://www.youtube.com/watch?v=B6aNv8nkUSw&list=PLC3y8-rFHvwgg3vaYJgHGnModB54rxOk3&index=34" target="_blank">YouTube PlayList</a>
</u-link-wrapper>

<v-code lang="js" title="">
import React, { Component } from 'react';

export default class App extends Component {
	render() {
		return (
			&lt;div&gt;
				&lt;EnhancedComponent <u-code>name="Tony"</u-code> /&gt;
			&lt;/div&gt;
		);
	}
}
</v-code>

<v-code lang="js" title="">
class WrappedComponent extends Component {
	render() {
		return (
			&lt;div&gt;
				{this.props.count}
				<u-code>{this.props.name}</u-code>
				&lt;button onClick={this.props.increment}&gt;Ok&lt;/button&gt;
			&lt;/div&gt;
		);
	}	
}
</v-code>

<v-code lang="js" title="">
const higherOrderComponent = (WrappedComponent, incrementNumber) =&gt; {
	return class extends Component {
		constructor(props) {
			super(props);
			this.state = {
				count: 0
			};
		}
		increment = () =&gt; {
			this.setState(state =&gt; ({
				count: state.count + incrementNumber
			}));
		}
		render() {
			//console.log(this.props.name);
			return (
				&lt;WrappedComponent 
					count={this.state.count} 
					increment={this.increment} 
					<u-code>{ ...this.props }</u-code>
				/&gt;
			);
		}		
	}
}
</v-code>

<v-code lang="js" title="">
const EnhancedComponent = higherOrderComponent(WrappedComponent, 5);
</v-code>

<!------------------------------------------------------------->
<h4>3. withStyles из Material-UI</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="component">
import React from 'react';
import { withStyles } from '@material-ui/core/styles';
import styles from './ComponentStyles';

const Component = ({ classes }) =&gt; {
	return (
		&lt;h1 className={classes.header}&gt;Desktop&lt;/h1&gt;
	);
};

export default withStyles(styles)(Component);
</v-code>

<v-code lang="js" title="styles">
const ComponentStyles = ({ spacing }: Object) => ({
	header: {}
});

export default ComponentStyles;
</v-code>

<!------------------------------------------------------------->
<h4>4. connect из Redux</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
import { connect } from 'react-redux';

const mapStateToProps = state => ({
	myValue: state.myReducer
})
const mapDispatchToProps = {
	getMethod: getMethod
}
export default <u-code>connect</u-code>(
	mapStateToProps,
	mapDispatchToProps
)(Component);
</v-code>
</div><div id="react-js/patterns/render-props"><h2>Рендер-пропсы</h2>

<ul class="list-point">
    <li><u-text-define>Рендер-проп</u-text-define> - относится к возможности компонентов React разделять код между собой с помощью пропа, значение которого является функцией</li>

    <li><u-text-define>Рендер-функция</u-text-define> - паттерн React, когда в React-компонент передается функция, которая занимается рендерингом части компонента или всего компонента. Такая функция обычно возвращает строку или React-элемент</li>

    <li>Рендер-проп - функция, которая сообщает компоненту что необходимо рендерить</li>
    <li>Любой проп, который используется компонентом и является функцией рендеринга, технически является и «рендер-пропом».</li>
    <li>Применяется в библиотеке React Router</li>
    <li><u>Цель:</u> инкапсулировать поведение с возможностью повторного использования</li>
    <li>Использование рендер-пропа может свести на нет преимущество, которое даёт <u>React.PureComponent</u>, если вы создаёте функцию внутри метода <u>render</u>. Это связано с тем, что поверхностное сравнение пропсов всегда будет возвращать false для новых пропсов и каждый render будет генерировать новое значение для рендер-пропа</li>
</ul>

<hr>

<ul class="list-point">
    <li>Компонент с рендер-пропом берёт функцию, которая возвращает React-элемент, и вызывает её вместо реализации собственного рендера</li>
</ul>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Примеры</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<!------------------------------------------------------------->
<h4>Простой пример</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
const App = () =&gt; (
	&lt;Child
		<u-code>render</u-code>={(name) =&gt; {
			return &lt;h2&gt;{name}&lt;/h2&gt;
		}}
	/&gt;
)
</v-code>

<v-code lang="js" title="">
const Child = ({ render }) =&gt; (
	&lt;&gt;
		{<u-code>render</u-code>('Tony')}
	&lt;/&gt;
)
</v-code>

<v-code lang="js" title="">
// => &lt;h2&gt;Tony&lt;/h2&gt;
</v-code>
</div><div id="react-js/patterns/element-props"><h2>Свойства-элементы</h2>

<ul class="list-point">
    <li>В prop может передаваться JSX</li>
    <li>В prop может передаваться объект, который представляет из себя React-элемент</li>
</ul>

<!------------------------------------------------------------->
<h4>1. Указание функции</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
const App = () =&gt; {
	return (
		&lt;&gt;
			{Sample()}
		&lt;/&gt;
	);
};

const Sample = () =&gt; {
	return (&lt;h1&gt;Sample&lt;/h1&gt;);
};
</v-code>

<!------------------------------------------------------------->
<h4>2. Указание объекта</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
const App = () =&gt; {
	return (
		&lt;&gt;
			{element}
		&lt;/&gt;
	);
};

const element = (&lt;h1&gt;Hello&lt;/h1&gt;);
</v-code>

<!------------------------------------------------------------->
<h4>3. Передача в компонент</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
const App = () =&gt; {
	const element = (&lt;h1&gt;Hello&lt;/h1&gt;);
	return &lt;Child elementObject={element} elementJsx={&lt;h1&gt;Hello&lt;/h1&gt;} /&gt;
};

const Child = (props) =&gt; {
	return (
		&lt;&gt;
			{props.elementObject}
			{props.elementJsx}
		&lt;/&gt;
	);
}
</v-code>

<!------------------------------------------------------------->
<h4>4. Передача компонета в props</h4>
<!------------------------------------------------------------->
<ul class="list-point">
	<li>В React нет никаких ограничений на то, что можно передать в качестве пропсов</li>
</ul>

<v-code lang="js" title="parent js">
// ReactDOM.render
class ComponentParent extends React.Component {
	render() {
		return (<u-code>&lt;ComponentChild small={&lt;ComponentSmall /&gt;} /&gt;</u-code>);
	}
}
</v-code>

<v-code lang="js" title="small js">
class ComponentSmall extends React.Component {
	render() {
		return (&lt;div&gt;ComponentSmall&lt;/div&gt;);
	}
}
</v-code>

<v-code lang="js" title="child js">
class ComponentChild extends React.Component {
	constructor(props) {
		super(props);
	}
	render() {
		return (&lt;div&gt;{<u-code>this.props.small</u-code>}&lt;/div&gt;);
	}
}
</v-code>

</div><div id="react-js/patterns/lifting-state-up"><h2>Подъём состояния</h2>

<ul class="list-point">
	<li><u-text-define>Подъём состояния</u-text-define> - совместное использование состояния, которое достигается перемещением его до ближайшего предка компонентов, которым оно требуется</li>
	<li>Рекомендуется поднимать общее состояние до ближайшего общего предка</li>

	<hr>
	<li>Создания «управляемого» компонента. Точно так же, как DOM-элемент <u-code-text>&lt;input&gt;</u-code-text> принимает атрибуты <u-code-text>value</u-code-text> и <u-code-text>onChange</u-code-text>, так и пользовательский <u-code-text>ComponentChild</u-code-text> принимает <u-code-text>emitHandleParent</u-code-text> от своего родителя <u-code-text>ComponentParent</u-code-text></li>
</ul>

<v-code lang="js" title="child js">
class ComponentChild extends React.Component {
	handleChild = () =&gt; {
		<u-code>this.props.emitHandleParent('Jack');</u-code>
	}
	render() {
		return (
			&lt;button onClick={<u-code>this.handleChild</u-code>}&gt;Ok&lt;/button&gt;
		);
	}
}
</v-code>

<v-code lang="js" title="parent js">
class ComponentParent extends React.Component {
	constructor(props) {
		super(props);
		this.state = { name: 'Tony' };
	}
	handleParent = (name) =&gt; {
		<u-code>this.setState({ name: name });</u-code>
	}
	render() {
		return (
			&lt;div&gt;
				<u-code>&lt;ComponentChild emitHandleParent={this.handleParent} /&gt;</u-code>
				{this.state.name}
			&lt;/div&gt;
		);
	}
}
</v-code>

</div><div id="react-js/processing-data-output/handling-events"><h2>Обработка событий</h2>

<ul class="list-point">
	<li>События в React именуются в стиле camelCase вместо нижнего регистра</li>
	<li>С JSX передается функция как обработчик события вместо строки</li>
</ul>

<v-two-code type="html;html" comment="react jsx;html">
<template v-slot:first>
&lt;button onClick={methodName}&gt;&lt;/button&gt;
</template>
<template v-slot:last>
&lt;button onclick="methodName()"&gt;&lt;/button&gt;
</template>
</v-two-code>

<ul class="list-point">
	<li>В React нельзя предотвратить обработчик события по умолчанию, вернув <u-code-text>false</u-code-text>. Нужно явно вызвать <u-code-text>preventDefault</u-code-text></li>
	<li>В приведённом выше коде <u-code-text>e</u-code-text> - это синтетическое событие</li>
</ul>

<v-two-code type="js;html" comment="react jsx;html">
<template v-slot:first>
function ActionLink() {
	function handleClick(e) {
		e.preventDefault();
		console.log('ok');
	}
	return (
		&lt;a href="#" onClick={handleClick}&gt;&lt;/a&gt;
	);
}
</template>
<template v-slot:last>
&lt;a href="#" onclick="console.log('ok'); return false"&gt;&lt;/a&gt;
</template>
</v-two-code>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Потеря контекста</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
    <li><u-text-underline>Функция получает свой контекст от того, где он вызывается</u-text-underline></li>
</ul>

<!------------------------------------------------------------->
<h4>1. Привязка с помощью bind</h4>
<!------------------------------------------------------------->
<ul class="list-point">
	<li>При обращении к <u-code-text>this</u-code-text> в JSX-колбэках необходимо учитывать, что методы класса в JavaScript по умолчанию не привязаны к контексту. Если вы забудете привязать метод <u-code-text>this.handleClick</u-code-text> и передать его в <u-code-text>onClick</u-code-text>, значение <u-code-text>this</u-code-text> будет undefined в момент вызова функции. Это часть того, как работают функции в JavaScript. Обычно, если ссылаться на метод без <u-code-text>()</u-code-text> после него, например, <u-code-text>onClick={this.handleClick}</u-code-text>, этот метод нужно привязать</li>
</ul>

<v-code lang="js" title="">
class App extends React.Component {
	constructor(props) {
		super(props);
		this.state = {
			name: 'Tony'
		};
		// привязка обязательна для работы `this` в колбэке
		<u-code>this.handleClick = this.handleClick.bind(this);</u-code>
	}
	handleClick() {
		// без привязки в constructor не будет работать
		<u-code>alert(this.state.name);</u-code>
	}
	render() {
		return (
			&lt;button <u-code>onClick={this.handleClick}</u-code>&gt;Ok&lt;/button&gt;
		);
	}
}
</v-code>

<!------------------------------------------------------------->
<h4>2. Эспериментальный синтаксис общедоступных полей классов</h4>
<!------------------------------------------------------------->
<ul class="list-point">
	<li>Такой синтаксис доступен в Create React App по умолчанию</li>
	<li>Такой синтаксис гарантирует, что <u-code-text>this</u-code-text> привязан к <u-code-text>handleClick</u-code-text></li>
	<li><b>Предупреждение</b>: это экспериментальный синтаксис</li>
	<li><u>Не воссоздает функцию каждый раз</u>, но связывает контекст с компонентом один раз при создании экземпляра класса. Передает ссылку на уже существующий экземпляр</li>
</ul>

<v-code lang="js" title="">
class App extends React.Component {
	constructor(props) {
		super(props);
		this.state = {
			name: 'Tony'
		};
	}
	<u-code>handleClick = () =&gt;</u-code> {
		alert(this.state.name);
	}
	render() {
		return (
			&lt;button <u-code>onClick={this.handleClick}</u-code>&gt;Ok&lt;/button&gt;
		);
	}
}
</v-code>

<!------------------------------------------------------------->
<h4>3. Стрелочные функции в колбэке</h4>
<!------------------------------------------------------------->
<ul class="list-point">
	<li>Такой синтаксис гарантирует, что <u-code-text>this</u-code-text> привязан к <u-code-text>handleClick</u-code-text></li>
	<li><b>Проблема:</b> <u>при каждом рендере компонента создаётся новый колбэк (новый экземпляр)</u>, вызывается <u-code-text>this.onClick</u-code-text>. Чаще всего это не страшно. Однако, если этот колбэк попадает как проп в дочерние компоненты, эти компоненты могут быть отрендерены снова</li>
	<li>Рекомендуется делать привязку в конструкторе или использовать синтаксис полей классов, чтобы избежать <u>проблем с производительностью</u></li>
</ul>

<v-code lang="js" title="">
class App extends React.Component {
	constructor(props) {
		super(props);
		this.state = {
			name: 'Tony'
		};
	}
	handleClick() {
		alert(this.state.name);
	}
	render() {
		return (
			&lt;button <u-code>onClick={(e) =&gt; this.handleClick(e)}</u-code>&gt;Ok&lt;/button&gt;
		);
	}
}
</v-code>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Передача аргументов в обработчики событий</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
	<li>В обоих случаях аргумент <u-code-text>e</u-code-text>, представляющий событие React, будет передан как второй аргумент после идентификатора. Используя стрелочную функцию, необходимо передавать аргумент явно, но с <u-code-text>bind</u-code-text> любые последующие аргументы передаются автоматически</li>
</ul>

<v-code lang="html" title="">
&lt;!-- стрелочные функции --&gt;
&lt;button onClick={(e) =&gt; this.deleteRow(id, e)}&gt;Удалить строку&lt;/button&gt;
&lt;!-- Function.prototype.bind --&gt;
&lt;button onClick={this.deleteRow.bind(this, id)}&gt;Удалить строку&lt;/button&gt;
</v-code></div><div id="react-js/processing-data-output/controlled-components"><h2>Controlled Components</h2>

<ul class="list-point">
	<li><u-text-define>Controlled Components</u-text-define> (Контролируемые / управляемые компоненты) - данные формы обрабатываются React-компонентом. <u-code-text>value</u-code-text> элемента устанавливается из <u-code-text>state</u-code-text> компонента</li>

	<li>У элементов формы изначально есть внутреннее состояние</li>
	<li>В HTML элементы формы, такие как <u-code-text>&lt;input&gt;</u-code-text>, <u-code-text>&lt;textarea&gt;</u-code-text>, <u-code-text>&lt;select&gt;</u-code-text>, обычно сами управляют своим состоянием и обновляют его когда пользователь вводит данные. В React мутабельное состояние обычно содержится в свойстве компонентов state и обновляется только через вызов <u-code-text>setState()</u-code-text>. Мы можем скомбинировать оба подхода и сделать состояние React-компонента <u>«единственным источником правды»</u>. Тогда React-компонент будет рендерить форму и контролировать её поведение в ответ на пользовательский ввод. Значение элемента формы <u-code-text>input</u-code-text> в этом случае будет контролировать React, а сам элемент будет называться управляемый компонент»</li>
</ul>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>input, submit</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<v-code lang="js" title="Хуки">
import React, { useState } from 'react'

const App = () =&gt; {
	const [value, setValue] = useState('')

	const onChange = e =&gt; setValue(e.target.value)

	return (
		&lt;&gt;
			&lt;input type="text" value={value} onChange={onChange} /&gt;
			&lt;h1&gt;{value}&lt;/h1&gt;
		&lt;/&gt;
	)
}
</v-code>

<v-code lang="js" title="Классовые">
class App extends React.Component {
	constructor(props) {
		super(props);
		this.state = { value: '' };
	}
	handleChange = (event) =&gt; {
		this.setState({value: <u-code>event.target.value</u-code>.toUpperCase()});
	}
	handleSubmit = (event) =&gt; {
		alert(this.state.value);
		<u-code>event.preventDefault();</u-code>
	}
	render() {
		return (
			&lt;form <u-code>onSubmit</u-code>={this.handleSubmit}&gt;
				&lt;input type="text" <u-code>value={this.state.value}</u-code> <u-code>onChange</u-code>={this.handleChange} /&gt;
				&lt;input type="submit" value="Отправить" /&gt;
			&lt;/form&gt;
		);
	}
}
</v-code>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>textarea</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<v-code lang="html" title="">
&lt;textarea value={this.state.value} onChange={this.handleChange}&gt;&lt;/textarea&gt;
</v-code>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>select</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
	<li>Пункт списка «Кокос» выбран по умолчанию из-за установленного атрибута <u-code-text>selected</u-code-text>. React вместо этого атрибута использует <u-code-text>value</u-code-text> в корневом теге <u-code-text>select</u-code-text>. В управляемом компоненте так удобнее, потому что обновлять значение нужно только в одном месте (<u-code-text>state</u-code-text>)</li>
</ul>

<v-code lang="js" title="">
constructor(props) {
	this.state = {value: 'coconut'};
}
</v-code>

<v-code lang="html" title="">
&lt;form onSubmit={this.handleSubmit}&gt;
	&lt;select value={this.state.value} onChange={this.handleChange}&gt;
		&lt;option value="lime"&gt;Лайм&lt;/option&gt;
		&lt;option value="coconut"&gt;Кокос&lt;/option&gt;
		&lt;option value="mango"&gt;Манго&lt;/option&gt;
	&lt;/select&gt;
	&lt;input type="submit" value="Отправить" /&gt;
&lt;/form&gt;
</v-code>

<ul class="list-point">
	<li>В атрибут <u-code-text>value</u-code-text> можно передать массив, что позволит выбрать несколько опций в теге <u-code-text>select</u-code-text></li>
</ul>

<v-code lang="html" title="">
&lt;select multiple={true} value={['Б', 'В']}&gt;
</v-code>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Обработка нескольких элементов input</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
	<li>Если нужны несколько управляемых элементов <u-code-text>input</u-code-text>, можно назначить каждому из них атрибут name, что позволит функции-обработчику решать, что делать, основываясь на значении <u-code-text>event.target.name</u-code-text></li>
</ul>

<v-code lang="js" title="">
class App extends React.Component {
	constructor(props) {
		super(props);
		this.state = {
			isGoing: true,
			numberOfGuests: 2
		  };
	}
	handleInputChange = (event) =&gt; {
		const target = event.target;
		const value = target.type === 'checkbox' ? target.checked : target.value;
		<u-code>const name = target.name;</u-code>
		this.setState({
			<u-code>[name]: value</u-code>
		});
	}
	render() {
		return (
			&lt;div&gt;
				&lt;input <u-code>name="isGoing"</u-code> type="checkbox" checked={this.state.isGoing} onChange={this.handleInputChange} /&gt;
				&lt;input <u-code>name="numberOfGuests"</u-code> type="number" value={this.state.numberOfGuests} onChange={this.handleInputChange} /&gt;
			&lt;/div&gt;
		);
	}
}
</v-code>

<!------------------------------------------------------------->
<h4>Вычисляемые имена свойств</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
this.setState({
	[name]: value
});
</v-code>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Значение null управляемого компонента</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
	<li>Если установить управляемому компоненту проп <u-code-text>value</u-code-text>, то пользователь не сможет изменить его значение без вашего желания. Если вы установили <u-code-text>value</u-code-text>, а поле ввода по-прежнему можно редактировать, то, возможно, вы случайно задали <u-code-text>value</u-code-text>, равный <u-code-text>undefined</u-code-text> или <u-code-text>null</u-code-text></li>
	<li>Пример: изначально заблокированный <u-code-text>input</u-code-text> становится редактируемым спустя 1с</li>
</ul>

<v-code lang="js" title="">
ReactDOM.render(&lt;input value="Привет" /&gt;, mountNode);

setTimeout(function() {
	ReactDOM.render(&lt;input value={null} /&gt;, mountNode);
}, 1000);
</v-code>
</div><div id="react-js/processing-data-output/uncontrolled-components"><h2>Uncontrolled Components</h2>

<ul class="list-point">
	<li><u-text-define>Uncontrolled Components</u-text-define> (Неконтролируемые / неуправляемые компоненты) - хранят данные формы в DOM, которые можно читать через <u-code-text>ref</u-code-text></li>

    <li>Неуправляемые компоненты опираются на DOM в качестве источника данных и могут быть удобны при интеграции React с кодом, не связанным с React. Количество кода может уменьшиться, правда, за счёт потери в его чистоте. Поэтому в обычных ситуациях рекомендуется использовать управляемые компоненты</li>
</ul>

<v-two-code type="js;js" comment="createRef (класс);useRef (функция)">
<template v-slot:first>
class App extends Component {
	constructor(props) {
		super(props);
		<u-code>this.input = React.createRef();</u-code>
	}
	handleClick = () =&gt; {
		alert(<u-code>this.input.current.value</u-code>);
	}
	render() {
		return (
			&lt;div&gt;
				&lt;input type="text" <u-code>ref={this.input}</u-code> /&gt;
				&lt;button onClick={this.handleClick}&gt;Ok&lt;/button&gt;
			&lt;/div&gt;
		);
	}
}
</template>
<template v-slot:last>
import { useRef } from 'react';

const App = () =&gt; {
    const inputRef = <u-code>useRef(null)</u-code>;

    const handleClick = () =&gt; {
        alert(<u-code>inputRef.current.value</u-code>);
    }

    return (
        &lt;div&gt;
            &lt;input type="text" <u-code>ref={inputRef}</u-code> /&gt;
            &lt;button onClick={handleClick}&gt;Ok&lt;/button&gt;
        &lt;/div&gt;
    )
}
</template>
</v-two-code>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Значения по умолчанию</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
    <li>На этапе рендеринга атрибут <u-code-text>value</u-code-text> полей ввода переопределяет значение в DOM. С неуправляемым компонентом зачастую нужно, чтобы React определил первоначальное значение, но впоследствии ничего не делал с ним. В этом случае необходимо определить атрибут <u-code-text>defaultValue</u-code-text> вместо <u-code-text>value</u-code-text></li>
    <li>Аналогично, <u-code-text>&lt;input type="checkbox"&gt;</u-code-text> и <u-code-text>&lt;input type="radio"&gt;</u-code-text> используют <u-code-text>defaultChecked</u-code-text>, а <u-code-text>&lt;select&gt;</u-code-text> и <u-code-text>&lt;textarea&gt;</u-code-text> - <u-code-text>defaultValue</u-code-text></li>
</ul>

<v-code lang="js" title="">
render() {
	return (
		&lt;input <u-code>defaultValue</u-code>="Tony" type="text" ref={this.input} /&gt;
	);
}
</v-code>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Тег поля загрузки файла</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
    <li>В React <u-code-text>&lt;input type="file"&gt;</u-code-text> всегда является неуправляемым компонентом, потому что его значение может быть установлено только пользователем, а не программным путём</li>
    <li>Для взаимодействия с файлами следует использовать File API. В примере показано, как создать реф на DOM-узел, чтобы затем получить доступ к файлам в обработчике отправки формы</li>
</ul>

<v-code lang="js" title="">
class FileInput extends React.Component {
	constructor(props) {
		super(props);
		this.handleSubmit = this.handleSubmit.bind(this);
		<u-code>this.fileInput = React.createRef();</u-code>
	}
	handleSubmit(event) {
		event.preventDefault();
		alert(<u-code>this.fileInput.current.files[0].name</u-code>);
	}
	render() {
		return (
		&lt;form onSubmit={this.handleSubmit}&gt;
			&lt;input type="file" <u-code>ref={this.fileInput}</u-code> /&gt;
			&lt;button type="submit"&gt;Submit&lt;/button&gt;
		&lt;/form&gt;
		);
	}
}
</v-code>

</div><div id="react-js/processing-data-output/css"><h2>Стилизация компонентов</h2>

<u-link-wrapper>
    <a href="https://medium.com/@stasonmars/руководство-по-трём-способам-стилизации-в-react-2ca5c0c7464b" target="_blank">Руководство по трём способам стилизации в React</a>
</u-link-wrapper>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Методы стилизации</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<!------------------------------------------------------------->
<h4>1. Отдельный CSS файл</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
import './index.css';

render() {
	return (&lt;div className="header"&gt;&lt;/div&gt;);
}
</v-code>

<!------------------------------------------------------------->
<h4>2. Инлайновая стилизация</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
const style = {
	width: '200px',
	height: '200px',
	background: 'yellowgreen'
}

export default class App extends React.Component {
	render() {
		return (
            &lt;div style={style}&gt;&lt;/div&gt;
        );
	}
}
</v-code>

<!------------------------------------------------------------->
<h4>3. CSS Modules</h4>
<!------------------------------------------------------------->
<u-link-wrapper>
    <a href="https://github.com/css-modules/css-modules" target="_blank">CSS Modules</a>
</u-link-wrapper>

<v-code lang="js" title="">
import classes from './Component.css';

render() {
	return (&lt;div className={classes.headerItem}&gt;&lt;/div&gt;);
}
</v-code>

<!------------------------------------------------------------->
<h4>4. CSS in JS</h4>
<!------------------------------------------------------------->
<u-link-wrapper>
    <a href="https://cssinjs.org/" target="_blank">JSS</a>
    <a href="https://www.styled-components.com/" target="_blank">Styled Components</a>
    <a href="https://github.com/threepointone/glamor" target="_blank">Glamor</a>
    <a href="https://emotion.sh/docs/introduction" target="_blank">Emotion</a>
    <a href="https://linaria.now.sh/" target="_blank">Linaria (CSS Custom Properties)</a>
</u-link-wrapper>

<b>Реализация CSS in JS</b>

<v-code lang="html" title="HTML">
&lt;div id="app"&gt;&lt;/div&gt;
</v-code>

<v-code lang="js" title="JavaScript">
const styles = `
    #app {
        width: 200px;
        height: 200px;
        background: yellowgreen;
    }
`;

const stylesElement = document.createElement('style');
stylesElement.appendChild(document.createTextNode(styles));
document.body.appendChild(stylesElement);
</v-code>

<ul class="list-point">
    <li>Добавление <u-code-text>&lt;style&gt;</u-code-text> происходит во время монтирования компонента во всех библиотеках, за исключением <u>Linaria</u>, где работа с CSS Custom Properties</li>
</ul>

<v-code lang="html" title="Результат">
&lt;html&gt;
&lt;head&gt;
    &lt;style&gt;
        #app {
            width: 200px;
            height: 200px;
            background: yellowgreen;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="app"&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</v-code>
</div><div id="react-js/processing-data-output/conditional-rendering"><h2>Условный рендеринг</h2>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Переменные-элементы</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<v-code lang="js" title="">
class App extends React.Component {
	constructor(props) {
		super(props);
		this.state = { status: true };
	}
	render() {
		<u-code-wrapper>
		const status = this.state.status;
		let text;
		if (status) {
			text = &lt;h2&gt;Yes&lt;/h2&gt;;
		} else {
			text = &lt;h2&gt;No&lt;/h2&gt;;
		}
		return (text);
		</u-code-wrapper>
	}
};
</v-code>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Встроенные условия if с логическим оператором &&</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
	<li>Можно внедрить любое выражение в JSX, заключив его в фигурные скобки. Это правило распространяется и на логический оператор <u-code-text>&&</u-code-text> языка JavaScript, которым можно удобно вставить элемент в зависимости от условия</li>
	<li>В JavaScript выражение <u-code-text>true && expression</u-code-text> всегда вычисляется как <u-code-text>expression</u-code-text>, а выражение <u-code-text>false && expression</u-code-text> - как <u-code-text>false</u-code-text></li>
</ul>

<v-code lang="js" title="">
render() {
	return (
		&lt;div&gt;
			{this.state.status &amp;&amp; &lt;h2&gt;Yes&lt;/h2&gt;}
		&lt;/div&gt;
	);
}
</v-code>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Встроенные условия if-else с тернарным оператором</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
	<li>Можно использовать тернарный оператор <u-code-text>condition ? true : false</u-code-text></li>
</ul>

<!------------------------------------------------------------->
<h4>Вариант 1</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
render() {
	return (
		&lt;div&gt;
			{this.state.status ? &lt;h2&gt;Yes&lt;/h2&gt; : &lt;h2&gt;No&lt;/h2&gt;}
		&lt;/div&gt;
	);
}
</v-code>

<!------------------------------------------------------------->
<h4>Вариант 2</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
render() {
	return (
		&lt;div&gt;
			{this.state.status ? (
				&lt;h2&gt;Yes&lt;/h2&gt;
			) : ( 
				&lt;h2&gt;No&lt;/h2&gt;
			)}
		&lt;/div&gt;
	);
}
</v-code>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Предотвращение рендеринга компонента</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
	<li>В редких случаях может потребоваться позволить компоненту спрятать себя, хотя он уже и отрендерен другим компонентом. Чтобы этого добиться, верните <u-code-text>null</u-code-text> вместо того, что обычно возвращается на рендеринг</li>
	<li>Сам факт возврата <u-code-text>null</u-code-text> из метода <u-code-text>render</u-code-text> компонента никак не влияет на срабатывание методов жизненного цикла компонента. Например, <u-code-text>componentDidUpdate</u-code-text> будет всё равно вызван</li>
</ul>

<v-code lang="js" title="">
render() {
	if (!this.state.status) {
		return null;
	}
	return (&lt;h2&gt;Yes&lt;/h2&gt;);
}
</v-code>
</div><div id="react-js/processing-data-output/lists-and-keys"><h2>Списки и ключи</h2>

<ul class="list-point">
	<li>У каждого элемента массива должен быть <u>ключ (key)</u>. «Ключ» - это специальный строковый атрибут, который нужно указывать при создании списка элементов. Ключи помогают React определять, какие элементы были изменены, добавлены или удалены. Их необходимо указывать, чтобы React мог сопоставлять элементы массива с течением времени</li>

	<li>Ключи внутри массива должны быть уникальными только среди своих соседних элементов. Им не нужно быть уникальными глобально. Можно использовать один и тот же ключ в двух разных массивах</li>

	<li>Когда у дочерних элементов есть ключи, React использует их, чтобы сопоставить потомков исходного дерева с потомками последующего дерева</li>

    <hr>
    <li>Когда у вас нет заданных ID для списка, то в крайнем случае можно использовать <u>индекс элемента как ключ</u>. Не рекомендуется использовать индексы как ключи, если порядок элементов может поменяться. Это негативно скажется на производительности и может вызвать проблемы с состоянием компонента. Если вы опустите ключ для элемента в списке, то React по умолчанию будет использовать индексы как ключи</li>
</ul>

<v-code lang="js" title="">
const arr = [1, 2, 3, 4, 5];
const items = arr.map((item) =&gt;
	&lt;li <u-code>key</u-code>={item.id}&gt;
		{item.text}
	&lt;/li&gt;
);
</v-code>

<v-two-code type="js;js" comment="Запись в переменную;Встраивание map() в JSX">
<template v-slot:first>
render() {
    const arr = [1, 2, 3, 4, 5];
    const items = arr.map((item) =&gt;
        &lt;li key={item.toString()}&gt;
            {item}
        &lt;/li&gt;
    );
    <u-code>return</u-code> (&lt;ul&gt;{items}&lt;/ul&gt;);
}
</template>
<template v-slot:last>
render() {
    const arr = [1, 2, 3, 4, 5];
    <u-code>return</u-code> (
        &lt;ul&gt;
            {arr.map((item) =&gt;
                &lt;li key={item.toString()}&gt;
                    {item}
                &lt;/li&gt;
            )}
        &lt;/ul&gt;
    );
}
</template>
</v-two-code>


</div><div id="react-js/processing-data-output/error-boundaries"><h2>Предохранители</h2>

<ul class="list-point">
    <li><u-text-define>Предохранители</u-text-define> - компоненты React, которые отлавливают ошибки JavaScript в любом месте деревьев их дочерних компонентов, сохраняют их в журнале ошибок и выводят запасной UI вместо рухнувшего дерева компонентов. Предохранители отлавливают ошибки при рендеринге, в методах жизненного цикла и конструкторах деревьев компонентов, расположенных под ними</li>

    <li>Предохранители работают как JavaScript-блоки <u-code-text>catch {}</u-code-text>, но только для компонентов. На практике чаще всего целесообразным будет один раз описать предохранитель и дальше использовать его по всему приложению</li>
    <li>Если предохранителю не удаётся отрендерить сообщение об ошибке, то ошибка всплывает до ближайшего предохранителя, расположенного над ним в дереве компонентов. Этот аспект их поведения тоже напоминает работу блоков <u-code-text>catch {}</u-code-text> в JavaScript</li>
	
    <hr><li><b>Идея: </b> Ошибка JavaScript где-то в коде UI не должна прерывать работу всего приложения</li>

	<hr><li><b>Где размещать:</b></li>
	<ul class="list-point">
		<li>защитить навигационные (route) компоненты верхнего уровня</li>
		<li>охватить индивидуальными предохранителями отдельные виджеты</li>
	</ul>

	<hr><li><b>Предохранители не поймают ошибки в:</b></li>
    <ul class="list-point">
        <li>обработчиках событий</li>
        <li>асинхронном коде</li>
        <li>серверном рендеринге</li>
        <li>самом предохранителе (а не в его дочерних компонентах)</li>
    </ul>
</ul>

<hr>
<ul class="list-point">
    <li><u-text-underline>Только классовые компоненты</u-text-underline> могут выступать в роли предохранителей, если они включают хотя бы один из следующих методов жизненного цикла: <u>static getDerivedStateFromError()</u> или <u>componentDidCatch()</u></li>
    <ul class="list-point">
    	<li><u-code-text>static getDerivedStateFromError()</u-code-text> при рендеринге запасного UI в случае отлова ошибки</li>
	    <li><u-code-text>componentDidCatch()</u-code-text> при написании кода для журналирования информации об отловленной ошибке</li>
    </ul>
</ul>

<hr>
<ul class="list-point">
    <li>Начиная с React 16, ошибки, не отловленные ни одним из предохранителей, будут приводить к размонтированию всего дерева компонентов React</li>
    <li>Бо́льшим злом будет вывести некорректный UI, чем удалить его целиком</li>
</ul>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Пример</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<v-code lang="js" title="">
import React, { Component } from 'react';

export default class App extends Component {
	constructor(props) {
		super(props);
		this.state = { hasError: false };
	}
	<u-code>static getDerivedStateFromError</u-code>(error) {
		// Обновить состояние с тем, чтобы следующий рендер показал запасной UI
		return { hasError: true };
	}
	<u-code>componentDidCatch</u-code>(error, info) {
		// Можно также сохранить информацию об ошибке в соответствующую службу журнала ошибок
		logErrorToMyService(error, info);
	}
	render() {
		if (this.state.hasError) {
			return &lt;h1&gt;Запасной UI&lt;/h1&gt;;
		}
		return &lt;div&gt;Основной UI&lt;/div&gt;; 
	}
}
</v-code>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>try/catch</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
    <li><u-code-text>try / catch</u-code-text> работает исключительно в <u>императивном коде</u>, в то время, как компоненты React являются <u>декларативными</u>, указывая что должно быть отрендерено</li>
    <li>Предохранители сохраняют декларативную природу React. Например, если ошибка, произошедшая в методе <u-code-text>componentDidUpdate</u-code-text>, будет вызвана <u-code-text>setState</u-code-text> где-то в глубине дерева компонентов, она всё равно корректно всплывёт к ближайшему предохранителю</li>
</ul>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Обработчики событий</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
    <li>React не нуждается в предохранителях, чтобы корректно обработать ошибки в обработчиках событий. В отличие от метода render и методов жизненного цикла, обработчики событий не выполняются во время рендеринга. Таким образом, даже если они сгенерируют ошибку, React всё равно знает, что нужно выводить на экран</li>
    <li>Чтобы отловить ошибку в обработчике событий, пользуйтесь обычной JavaScript-конструкцией try / catch. Приведённый выше пример демонстрирует стандартное поведение JavaScript и не использует предохранителей</li>
</ul>

<v-code lang="js" title="">
import React, { Component } from 'react';

export default class App extends Component {
	constructor(props) {
		super(props);
		this.state = { error: null };
	}
	handleClick = () =&gt; {
		<u-code-wrapper>
		try {
			// Делаем что-то, что сгенерирует ошибку
		} catch (error) {
			this.setState({ error });
		}
		</u-code-wrapper>
	}
	
	render() {
		<u-code-wrapper>
		if (this.state.error) {
			return &lt;h1&gt;Отловил ошибку&lt;/h1&gt;
		}
		return &lt;button onClick={this.handleClick}&gt;Нажми на меня&lt;/button&gt;
		</u-code-wrapper>
	}
}
</v-code>
</div><div id="react-js/lifecycle/info"><h2>Жизненный цикл React-компонентов</h2>

<u-link-wrapper>
	<a href="http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/" target="_blank">Схема</a>
</u-link-wrapper>

<img src="/@img/react/component-lifecycle.png" width="800px" class="center">

<ul class="list-point">
    <li><u-text-define>Lifecycle Methods</u-text-define> - Методы жизненного цикла</li>
    <li><u-text-define>Lifecycle Hooks</u-text-define> - Функции, вызываемые на каждом этапе жизненного цикла</li>
</ul>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Server Side Rendering</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
    <li>У React 2 рендеринга: клиентский и серверный</li>
</ul>

<ul class="list-point">
    <li>Метод <u>render()</u> был заменен на <u>hydrate()</u></li>
</ul>

<v-code lang="js" title="">
hydrate(&lt;App/&gt;, document.getElementById("root"));
</v-code>

<ul class="list-point">
    <li><u>componentDidMount()</u> не используется</li>
    <li class="red">При <u>SSR</u> не нужно обновление компонента</li>
</ul>
</div><div id="react-js/lifecycle/hook-constructor"><h2>React.Component.constructor()</h2>

<div class="v-method-wrapper">
    <v-method before="" method="constructor" after="" arg="(props)">
   	вызывается при создании компонента
    </v-method>

	<v-method-arg arg="props">props</v-method-arg>
</div>

<ul class="list-point">
    <li>Вы можете <u>не использовать</u> конструктор в React-компоненте, если вы не определяете состояние или не привязываете методы</li>
    <li>Конструктор компонента React вызывается до того, как компонент будет примонтирован. В начале конструктора необходимо вызывать <u-code-text>super(props)</u-code-text>. Если это не сделать, <u-code-text>this.props</u-code-text> не будет определён. Это может привести к багам</li>
    <li><u>Не использовать</u> <u-code-text>setState()</u-code-text> в constructor(). Начальное состояние сразу присваивается в конструкторе. Конструктор - единственное место, где можно напрямую изменять <u-code-text>this.state</u-code-text>. В остальных методах необходимо использовать <u-code-text>this.setState()</u-code-text></li>
    <li><u>Не использовать</u> побочные эффекты или подписки в конструкторе. Вместо этого используйте <u-code-text>componentDidMount()</u-code-text></li>
</ul>
<ul class="list-point">
	<b>Обычно используют для двух целей:</b>
    <li>Инициализация внутреннего состояния через присвоение объекта <u-code-text>this.state</u-code-text></li>
    <li>Привязка обработчиков событий к экземпляру</li>
</ul>
</div><div id="react-js/lifecycle/hook-get-derived-state-from-props"><h2>getDerivedStateFromProps()</h2>


<div class="v-method-wrapper">
    <v-method before="static " method="getDerivedStateFromProps" after="" arg="(props, state)">
    вызывается непосредственно перед вызовом метода render, как при начальном монтировании, так и при последующих обновлениях. Он должен вернуть объект для обновления состояния или null, чтобы ничего не обновлять. Существует для редких случаев, <u-text-underline>когда состояние зависит от изменений в пропсах</u-text-underline>. Например, это подойдёт для реализации компонента &lt;Transition&gt;, который сравнивает свои предыдущие и следующие дочерние компоненты, чтобы решить, какой из них нужно анимировать. Метод запускается при каждом рендере, независимо от причины
    </v-method>

	<v-method-arg arg="props">props</v-method-arg>
	<v-method-arg arg="state">state</v-method-arg>
</div>
</div><div id="react-js/lifecycle/hook-should-component-update"><h2>shouldComponentUpdate()</h2>

<div class="v-method-wrapper">
    <v-method before="" method="shouldComponentUpdate" after="" arg="(nextProps, nextState)">
    для указания необходимости следующего рендера на основе изменений состояния и пропсов. По умолчанию происходит повторный рендер при любом изменении состояния. Вызывается перед рендером, когда получает новые пропсы или состояние. Необходим только для <u>повышения производительности</u>
    </v-method>

	<v-method-arg arg="nextProps">nextProps</v-method-arg>
	<v-method-arg arg="nextState">nextState</v-method-arg>

    <v-method-return><u-text-underline>true</u-text-underline> (перерендер) / <u-text-underline>false</u-text-underline> (нет перерендера)</v-method-return>
</div>
</div><div id="react-js/lifecycle/hook-render"><h2>React.Component.render()</h2>

<div class="v-method-wrapper">
    <v-method before="ReactDOM." method="render" after="" arg="()">
    рендеринг элементов. Единственный обязательный метод в подклассе <u>React.Component</u>. При вызове он проверяет <u>this.props</u> и <u>this.state</u>. Возвращает дерево React-элементов, которые превращаются в DOM-элементы
    </v-method>

    <v-method-return><u>Элемент React</u>. Обычно создаётся с помощью JSX. Указывает React, что рендерить: DOM-узел или пользовательский компонент. Например, <u>&lt;div /&gt;</u> или <u>&lt;MyComponent /&gt;</u></v-method-return>
    <v-method-return><u>Массивы и фрагменты</u>. Возвращает несколько элементов из <u>render()</u></v-method-return>
    <v-method-return><u>Порталы</u>. Рендерит несколько дочерних элементов в другое поддерево DOM</v-method-return>
    <v-method-return><u>Строки и числа</u>. Рендерит текстовые DOM-узлы</v-method-return>
    <v-method-return><u>Booleans или null</u>. Ничего не рендерит. Обычно необходим для поддержки паттерна <u>return test &amp;&amp; &lt;Child /&gt;</u>, где <u>test</u> - логическое значение</v-method-return>
</div>

<ul class="list-point">
    <li>Функция render() должна быть <b>чистой</b>. Это означает, что она не изменяет состояние компонента, всегда возвращает один и тот же результат, не взаимодействует напрямую с браузером. Взаимодействовать с браузером необходимо в <u-code-text>componentDidMount()</u-code-text> или других методах жизненного цикла. Чистый <u-code-text>render()</u-code-text> делает компонент понятным</li>
</ul>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>ReactDOM.render() - рендеринг элементов</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
	<li><u-text-define>Элементы</u-text-define> - это то, «из чего сделаны» компоненты</li>
	<li>В отличие от DOM-элементов, элементы React - это простые объекты, не отнимающие много ресурсов. React DOM обновляет DOM, чтобы он соответствовал переданным React-элементам</li>
	<li><u-code-text>ReactDOM.render()</u-code-text> - рендеринг React-элемента в узел DOM</li>
	<li>Элементы React иммутабельны. После создания элемента, нельзя изменить его потомков или атрибуты. Элемент похож на кадр в фильме: он отражает состояние интерфейса в конкретный момент времени</li>
</ul>

<v-code lang="js" title="">
ReactDOM.render(
	&lt;App /&gt;,
	document.getElementById('root')
);
</v-code>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Рендеринг</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
	<li>Элементы могут описывать и наши собственные компоненты</li>
	<li>Когда React встречает подобный элемент, он собирает все JSX-атрибуты в один объект и передаёт их нашему компоненту. Этот объект называется <u>«пропсы» (props)</u></li>
</ul>

<v-code lang="js" title="">
function Welcome(props) {
	return &lt;h1&gt;Привет, {props.name}&lt;/h1&gt;;
}

const element = &lt;Welcome name="Алиса" /&gt;;
ReactDOM.render(element, document.getElementById('root'));
</v-code>

<ol class="list-num">
	<li>Мы передаём React-элемент <u-code-text>&lt;Welcome name="Алиса" /&gt;</u-code-text> в <u-code-text>ReactDOM.render()</u-code-text></li>
	<li>React вызывает наш компонент <u-code-text>Welcome</u-code-text> с пропсами <u-code-text>{name: 'Алиса'}</u-code-text></li>
	<li>Наш компонент <u-code-text>Welcome</u-code-text> возвращает элемент <u-code-text>&lt;h1&gt;Привет, Алиса&lt;/h1&gt;</u-code-text> в качестве результата</li>
	<li>React DOM делает минимальные изменения в DOM, чтобы получилось <u-code-text>&lt;h1&gt;Привет, Алиса&lt;/h1&gt;</u-code-text></li>
</ol>
</div><div id="react-js/lifecycle/hook-get-snapshot-before-update"><h2>getSnapshotBeforeUpdate</h2>


<div class="v-method-wrapper">
    <v-method before="" method="getSnapshotBeforeUpdate" after="" arg="(prevProps, prevState)">
    вызывается прямо перед этапом «фиксирования» (например, перед добавлением в DOM). Он позволяет компоненту брать некоторую информацию из DOM (например, положение прокрутки) перед её возможным изменением. Любое значение, возвращаемое этим методом жизненного цикла, будет передано как параметр <u>componentDidUpdate()</u>. Это применяется редко, но может быть полезно в таких интерфейсах, как цепочка сообщений в чатах, в которых позиция прокрутки обрабатывается особым образом
    </v-method>

	<v-method-arg arg="prevProps">prevProps</v-method-arg>
	<v-method-arg arg="prevState">prevState</v-method-arg>
</div>
</div><div id="react-js/lifecycle/hook-component-did-mount"><h2>componentDidMount()</h2>

<div class="v-method-wrapper">
    <v-method before="" method="componentDidMount" after="" arg="()">
    <u>МОНТИРОВАНИЕ (mounting)</u> вызывается сразу после монтирования (то есть, вставки компонента в DOM). 
    </v-method>
</div>

<ul class="list-point">
	<li>В этом методе должны происходить действия, которые требуют наличия DOM-узлов. Это хорошее место для создания сетевых запросов</li>
	<li>Этот метод подходит для настройки подписок. Но не забудьте отписаться от них в <u>componentWillUnmount()</u></li>
	<li>Вы можете сразу вызвать <u>setState()</u>. Это вызовет дополнительный рендер перед тем, как браузер обновит экран. Гарантируется, что пользователь не увидит промежуточное состояние, даже если <u>render()</u> будет вызываться дважды. Подход может вызвать проблемы с производительностью. В большинстве случаев начальное состояние лучше объявить в <u>constructor()</u>. Однако, это может быть необходимо для случаев, когда нужно измерить размер или положение DOM-узла, на основе которого происходит рендер. Например, для модальных окон или всплывающих подсказок</li>
</ul>
</div><div id="react-js/lifecycle/hook-component-did-update"><h2>componentDidUpdate()</h2>

<div class="v-method-wrapper">
    <v-method before="" method="componentDidUpdate" after="" arg="(prevProps, prevState, snapshot)">
    <u>ОБНОВЛЕНИЕ</u> вызывается сразу после обновления (изменение пропсов или состояния: setState). Не вызывается при первом рендере. Позволяет работать с DOM при обновлении компонента
    </v-method>

	<v-method-arg arg="prevProps">предыдущий prop</v-method-arg>
	<v-method-arg arg="prevState">предыдущий state</v-method-arg>
	<v-method-arg arg="snapshot">snapshot</v-method-arg>
</div>

<ul class="list-point">
    <li>Необходимо делать сравнение пропсов: если не сделать - будет бесконечный цикл: <u-code-text>render -> componentDidUpdate -> render ...</u-code-text></li>
</ul>

<v-code lang="js" title="">
componentDidUpdate(prevProps) {
	// сравнение пропсов
	if (<u-code>this.props.userID</u-code> !== <u-code>prevProps.userID</u-code>) {
		this.fetchData(this.props.userID);
	}
}
</v-code>

<ul class="list-point">
    <li>Метод подходит для выполнения таких сетевых запросов, которые выполняются на основании результата сравнения текущих пропсов с предыдущими. Если пропсы не изменились, новый запрос может и не требоваться</li>
    <li>В методе можно вызывать <u>setState()</u>, однако его необходимо обернуть в условие, как в примере выше, чтобы не возник бесконечный цикл. Вызов <u>setState()</u> влечет за собой дополнительный рендер, который незаметен для пользователя, но может повлиять на производительность компонента. Вместо «отражения» пропсов в состоянии рекомендуется использовать пропсы напрямую</li>
</ul>
</div><div id="react-js/lifecycle/hook-component-will-unmount"><h2>componentWillUnmount()</h2>

<div class="v-method-wrapper">
    <v-method before="" method="componentWillUnmount" after="" arg="()">
    <u>РАЗМОНТИРОВАНИЕ (unmounting)</u> вызывается перед размонтированием и удалением компонента (после удаления DOM-узла, созданного компонентом)
    </v-method>
</div>

<ul class="list-point">
	<li>В этом методе выполняется необходимый сброс: отмена таймеров, сетевых запросов и подписок, созданных в <u>componentDidMount()</u></li>
	<li>Не используйте <u>setState()</u> в методе, так как компонент никогда не рендерится повторно. После того, как экземпляр компонента будет размонтирован, он никогда не будет примонтирован снова</li>
	<li>В момент вызова DOM-элемент всё еще находится на странице</li>
</ul>
</div><div id="react-js/lifecycle/hook-get-derived-state-from-error"><h2>getDerivedStateFromError()</h2>

<div class="v-method-wrapper">
    <v-method before="" method="getDerivedStateFromError" after="" arg="(error)">
    вызывается после возникновения ошибки у компонента-потомка
    </v-method>

	<v-method-arg arg="error">ошибка</v-method-arg>

	<v-method-return>Возвращает значение для обновления состояния</v-method-return>
</div>

<v-code lang="js" title="">
import React, { Component } from 'react';

export default class App extends Component {
	constructor(props) {
		super(props);
		this.state = { hasError: false };
	}
	<u-code>static getDerivedStateFromError</u-code>(error) {
		// Обновить состояние с тем, чтобы следующий рендер показал запасной UI
		return { hasError: true };
	}
	render() {
		if (this.state.hasError) {
			return &lt;h1&gt;Запасной UI&lt;/h1&gt;;
		}
		return &lt;div&gt;Основной UI&lt;/div&gt;; 
	}
}
</v-code>
</div><div id="react-js/lifecycle/hook-component-did-catch"><h2>componentDidCatch()</h2>

<div class="v-method-wrapper">
    <v-method before="" method="componentDidCatch" after="" arg="(error, info)">
    <u>ОБРАБОТКА ОШИБОК</u> если произошла ошибка в процессе рендеринга, методе жизненного цикла или конструкторе любого дочернего компонента
    </v-method>

	<v-method-arg arg="error">перехваченная ошибка</v-method-arg>
	<v-method-arg arg="info">объект с ключом <u>componentStack</u>, содержащий информацию о компоненте, в котором произошла ошибка</v-method-arg>
</div>

<ul class="list-point">
	<li>Компоненты, которые содержат componentDidCatch называются <u>Error Boundary</u> - ловят ошибки ниже себя по иерархии и ограничивают область действия этих ошибок</li>
	<li>Если в componentDidCatch произойдет ошибка, она в componentDidCatch выше по иерархиии</li>
	<li><u>Не будут обрабатываться</u> асинхронные ошибки, ошибки из eventListeners</li>
	<li>Метод вызывается во время этапа «фиксации», поэтому здесь можно использовать побочные эффекты. Метод можно использовать для <u>логирования ошибок</u></li>
	<li>В случае ошибки можно рендерить запасной интерфейс с помощью <u-code-text>getDerivedStateFromError()</u-code-text></li>
</ul>

<v-code lang="js" title="">
import React, { Component } from 'react';

export default class App extends Component {
	<u-code>componentDidCatch</u-code>(error, info) {
		// Можно также сохранить информацию об ошибке в соответствующую службу журнала ошибок
		logErrorToMyService(error, info);
	}
	render() {
		//
	}
}
</v-code>
</div><div id="react-js/other/react-developer-tools"><h2>React Developer Tools</h2>

<u-link-wrapper>
	<a href="https://github.com/facebook/react-devtools" target="_blank">React Developer Tools</a>
	<a href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=ru" target="_blank">Интернет-магазин Chrome</a>
</u-link-wrapper>

</div><div id="react-js/other/components"><h2>Виды компонентов</h2>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Виды компонентов</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<v-two><template v-slot:first>
<ul class="list-point">
	<li><u-text-define>Stateful Component</u-text-define> (компоненты с состоянием) - делают что-то с данными и работают со стором</li>
	<ul class="list-point">
		<li><b>Название: </b>Умные компоненты</li>
		<li><b>Директория: </b>containers</li>
		<li><b>Реализация: </b>классы</li>
		<li><b>Наличие state: </b>да</li>
	</ul>
</ul>
</template><template v-slot:last>
<ul class="list-point">
	<li><u-text-define>Stateless Functional Components</u-text-define> (функциональные компоненты без состояния) - получают данные и их отрисовывают</li>
	<ul class="list-point">
		<li><b>Название: </b>Глупые компоненты</li>
		<li><b>Директория: </b>components</li>
		<li><b>Реализация: </b>функции</li>
		<li><b>Наличие state: </b>нет</li>
	</ul>
</ul>
</template></v-two>

<img src="/@img/react/components-type.png" width="650px">

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Композиция компонентов</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
	<li>Компоненты могут ссылаться на другие компоненты в возвращённом ими дереве. Это позволяет нам использовать одну и ту же абстракцию - компоненты - на любом уровне нашего приложения</li>
	<li>компонент App может отрендерить компонент Child несколько раз</li>
</ul>

<v-code lang="js" title="">
function App() {
	return (
		&lt;div&gt;
			&lt;Child /&gt;
			&lt;Child /&gt;
		&lt;/div&gt;
	);
}
</v-code>
</div><div id="react-js/other/samples"><h2>Примеры</h2>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Принудительный перерендеринг</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<v-code lang="js" title="">
// При измнении key, компонент будет обязательно перерендерен
import React, { useState } from "react";
import TextField from '@material-ui/core/TextField';

const App = () =&gt; {
	const [label, setLabel] = useState('Hello');
	const [key, setKey] = useState(Date.now());
	const handleClick = () =&gt; {
		setLabel('Hello World');
		setKey(Date.now());
	};
	
	return (
		&lt;&gt;
			&lt;TextField key={key} value = '1' variant='outlined' fullWidth label={label}/&gt;
			&lt;button onClick={handleClick}&gt;Change&lt;/button&gt;
		&lt;/&gt;
	);
};
</v-code>
</div><div id="react-js/react-plugins/create-react-app"><h2>Create React App</h2>

<u-link-wrapper>
	<a href="https://create-react-app.dev/" target="_blank">Документация</a>
	<a href="https://facebook.github.io/create-react-app/docs/getting-started" target="_blank">Getting Started</a>
	<a href="https://github.com/facebook/create-react-app#create-react-app--" target="_blank">Create React App</a>
	<a href="https://github.com/facebook/create-react-app/blob/master/packages/react-scripts/template/README.md#table-of-contents" target="_blank">Available Scripts</a>
</u-link-wrapper>

<ul class="list-point">
	<li><u-text-define>Create React App</u-text-define> - создание одностраничных приложений, предоставляет команды для сборки фронтенда</li>
	<li>Будут установлены пакеты <u-code-text>react</u-code-text> и <u-code-text>react-dom</u-code-text></li>
	<li>«Под капотом» используются <u>Babel</u> и <u>Webpack</u>, <u>eslint</u> и т.д.</li>
</ul>

<v-code lang="bash" title="">
npx <u-code>create-react-app</u-code> AppName              # стандартная установка
npx <u-code>create-react-app</u-code> AppName <u-code>--typescript</u-code> # установка с TypeScript
</v-code>

<v-code lang="bash" title="">
npm run start  # старт сервера
npm run build  # создание оптимизированной сборки приложения в папке build
</v-code>
</div><div id="react-js/react-plugins/classnames"><h2>classnames</h2>

<v-pre-npm>
npm i --save <u-code-accent>classnames</u-code-accent>
</v-pre-npm>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Импорт</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<v-code lang="js" title="">
import cn from 'classnames';
</v-code>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Примеры</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<!------------------------------------------------------------->
<h4>Простой пример</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
&lt;div className={cn(classes.first, classes.second)}&lt;/div&gt; 
</v-code>

<!------------------------------------------------------------->
<h4>Использование CSS-in-JS</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
import { withStyles } from '@material-ui/core/styles';
import styles from './styles';

const App = ({ classes }) =&gt; (
    &lt;div className={classes.container}&gt;&lt;/div&gt;
);

export default withStyles(styles)(App);
</v-code>

<!------------------------------------------------------------->
<h4>Применение условий</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
const isError = true

&lt;div className={cn(classes.first, { [classes.error]: isError })}&gt;&lt;/div&gt;  
</v-code>
</div></div>
                </div>
            </div>

            <!-- CSS -->
            <link rel="stylesheet" type="text/css" href="../src/css/basic.css">
            <link rel="stylesheet" type="text/css" href="../src/css/index.css">

            <!-- Libraries -->
            <script src="../src/libs/highlight/highlight.pack.js"></script>
            <script src="../src/libs/vue.js"></script>

            <!-- Custom Elements -->
            <script src="../src/components-web/custom-elements.js"></script>
            <link rel="stylesheet" type="text/css" href="../src/components-web/custom-elements.css">

            <!-- Vue.js Components -->
            <script src="../src/components-vue/vue-components.js"></script>
            <link rel="stylesheet" type="text/css" href="../src/components-vue/vue-components.css">

            <!-- JavaScript -->
            <script src="../src/js/init.js"></script>
            <script src="../@modules/@links.js"></script>
            <script src="../src/vue/build.js"></script>
        </body>
    </html>
