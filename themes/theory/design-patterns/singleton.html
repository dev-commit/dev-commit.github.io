<h2>Паттерн «Синглтон»</h2>

<ul class="list-point">
    <li><u-text-define>«Синглтон» (Singleton)</u-text-define> порождающий паттерн проектирования, гарантирующий что у класса есть только один экземпляр, и предоставляет к нему глобальную точку доступа в однопоточном приложении</li>
    <li>В рамках применения этого паттерна новый экземпляр некоего класса создаётся в том случае, если он пока не создан. Если же экземпляр класса уже существует, то, при попытке обращения к конструктору, возвращается ссылка на соответствующий объект. Последующие вызовы конструктора всегда будут возвращать тот же самый объект</li>

    <li><b>Зачем:</b> Использование конструктора плохая практика, особенно если у класса есть зависимости var user = new User()</li>
    <li><b>Применение</b>: сервисы в Angular</li>
</ul>

<h4>Какие проблемы решает</h4>
<ol class="list-num">
    <li><u-code>Гарантирует наличие единственного экземпляра класса</u-code> Чаще всего это полезно для доступа к какому-то общему ресурсу, например, базе данных. Такое поведение невозможно реализовать с помощью обычного конструктора, так как конструктор класса всегда возвращает новый объект</li>
    <li><u-code>Предоставляет глобальную точку доступа</u-code> Это не просто глобальная переменная, через которую можно достучаться к определённому объекту. Глобальные переменные не защищены от записи, поэтому любой код может подменять их значения без вашего ведома</li>
</ol>

<!------------------------------------------------------>
<h3>Представление класса в виде синглтона</h3>
<!------------------------------------------------------>
<h4>Обычный класс a !== b</h4>
<pre><code class="js">
class usualClass {
    constructor() {
        // this.name = null;
    }
    testMethod() {
        return 'Hello'
    }
}

var a = new usualClass();
var b = new usualClass();
<u-code>console.log(a === b); // false</u-code>
console.log(a.testMethod());
</code></pre>


<div class="container-flex"><div class="container-half"><h4>Singleton ES5</h4><pre><code class="js">
const Universe = (function(){
    let instance = null;
    function func() {
        if (!instance) {
            instance = this;
            this.size = 100;
        }
        return instance;
    }
    func.prototype.getSize = function() {
       return this.size;
    }
    func.prototype.setSize = function(size) {
       this.size = size;
    }
    return func;
})();

var a = new Universe();
var b = new Universe();

<u-code>console.log(a === b); // true</u-code>
console.log(a.getSize(), b.getSize()); // 100, 100
a.setSize(200);
console.log(a.getSize(), b.getSize()); // 200, 200
</code></pre></div><div class="container-half"><h4>Singleton ES6</h4><pre><code class="js">
var instance = null;

class Singleton {
    constructor() {
        if(!instance){
            instance = this;
        }
        return instance;
    }
}
var a = new Singleton();
var b = new Singleton();
<u-code>console.log(a === b); // true</u-code>
</code></pre></div></div>

<!------------------------------------------------------>
<h3>Представление класса в виде объектного литерала</h3>
<!------------------------------------------------------>
<ul class="list-point">
    <li>Всякий раз, когда мы обращаемся к переменной user, мы получаем ссылку на один и тот же объект</li>
</ul>
<pre><code class="js">
const user = {
    name: 'Tony',
    greet: function() {
        console.log('Hello!');
    }
};
</code></pre>
