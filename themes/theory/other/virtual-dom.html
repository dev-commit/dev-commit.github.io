<h2>Virtual DOM</h2>

<ul class="list-point">
    <li><u-text-define>DOM (Document Object Model)</u-text-define> - способ представления структурного документа с помощью объектов. Это кроссплатформенное и языко-независимое соглашение для представления и взаимодействия с данными в HTML, XML и т.д. </li>
    <li><b>Проблема:</b> никогда не был рассчитан для создания динамического пользовательского интерфейса (UI)</li>
    <hr>

    <li><u-text-define>Shadow DOM</u-text-define> - Спецификация, описывающая метод объединения нескольких DOM-деревьев в одну иерархию и как эти деревья взаимодействуют друг с другом в пределах документа, что позволяет лучше скомпоновать DOM</li>
    <hr>

	<li><u-text-define>Virtual DOM</u-text-define> - техника и набор библиотек / алгоритмов, которые позволяют нам улучшить производительность на клиентской стороне, избегая прямой работы с DOM путем работы с легким JavaScript-объектом, имитирующем DOM-дерево</li>

	<li>Вместо того, чтобы взаимодействовать с DOM напрямую, мы работаем с его легковесной копией. Мы можем вносить изменения в копию, исходя из наших потребностей, а после этого применять изменения к реальному DOM. При этом происходит сравнение DOM-дерева с его виртуальной копией, определяется разница и запускается перерисовка того, что было изменено</li>

	<li>Virtual DOM не является стандартом и в конечном итоге мы по-прежнему взаимодействуем с DOM, но делаем это как можно реже и более эффективно</li>
</ul>

<!------------------------------------------------------------->
<h4>Два варианта узнать, что данные изменились</h4>
<!------------------------------------------------------------->
<ul class="list-point">
	<li><u-text-underline>«Dirty Checking» (грязная проверка)</u-text-underline> - опрашивать данные через регулярные промежутки времени и рекурсивно проверять все значения в структуре данных</li>
	<li><u-text-underline>«Observable» (наблюдаемый)</u-text-underline> - наблюдение за изменением состояния. Если ничего не изменилось, мы ничего не делаем. Если изменилось, мы точно знаем, что нужно обновить</li>
</ul>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Реализация в React</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
    <li>React создает легковесное дерево из JavaScript-объектов для имитации DOM-дерева. Затем он создает из них HTML, который вставляется или добавляется к нужному DOM-элементу, что вызывает перерисовку страницы в браузере</li>
    <li>JS объкты просто строить и сравнивать</li>
</ul>

<!------------------------------------------------------------->
<h4>1. Первоначальный Render DOM</h4>
<!------------------------------------------------------------->
<ol class="list-num">
<li>Вернули JSX</li>
<pre><code class="js">
class App extends React.Component {
	render(
		return (
			&lt;div&gt;Hello&lt;/div&gt;
		)
	);
}
</code></pre>

<li>Транспиляция в React.createElement (Virtual DOM)</li>
<pre><code class="js">
React.createElement('div', null, 'Hello'),
</code></pre>

<li>Рендер в браузер DOM (react-dom)</li>
<pre><code class="js">
ReactDOM.render(&lt;App /&gt;, document.getElementById('root'));
</code></pre>
</ol>

<!------------------------------------------------------------->
<h4>2. Изменение setState()</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li>При нажатии setState() каждый раз асинхронно (React 16) перестраивается Virtual DOM для компонента и всех его потомков. Но в DOM идут только изменения</li>
</ul>
<ol class="list-num">
	<li>Произошел <u-code-text>setState()</u-code-text> в компонене <u-code-text>App</u-code-text>. Помечаем компонент как "грязный"</li>
	<li>Перестроение Virtual DOM</li>
	<li>Сравнение измененого Virtual DOM и старого Virtual DOM. При нахождении изменений, меняется компонент в реальном DOM</li>
</ol>

<img src="/img/dom/virtual-dom-set-state.png" width="450px">

