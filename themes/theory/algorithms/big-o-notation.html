<h2>Big-O Notation (сложность алгоритмов)</h2>

<u-link-wrapper>
    <a href="https://www.youtube.com/watch?v=ZRdOb4yR0kk" target="_blank">[YouTube] Оценка сложности алгоритма</a>
</u-link-wrapper>

<ul class="list-point">
    <li><u-text-define>Big-O Notation</u-text-define> показывает <b>верхнюю границу сложности алгоритма</b> зависимости между <b>входными параметрами</b> функции и <b>количеством операций</b>, которые выполнит процессор</li>

    <li>Нельзя оценивать работу алгоритм с точки зрения времени. Один и тот же алгоритм на разных машинах будет выполняться разное время. Алгоритм включает в себя число шагов. Идея Big-O - сколько шагов нужно сделать чтобы алгоритм завершил свое выполнение</li>

    <li><u-text-define>Сложность алгоритма (вычислительная сложность)</u-text-define> - функция зависимости объёма работы, которая выполняется некоторым алгоритмом, от размера входных данных</li>

    <li>Объём работы обычно измеряется временем и вычислительными ресурсами. Время определяется количеством элементарных шагов, необходимых для решения задачи. Ресурсы определяются объёмом памяти или места на носителе данных</li>
</ul>

<!------------------------------------------------------>
<h3>Верхняя граница (отбрасывание констант)</h3>
<!------------------------------------------------------>
<ul class="list-point">
    <li>Мы говорим как будет вести себя алгоритм на бесконечности</li>
    <li>Если алгоритм для n-элементов выполняет n-тактов плюс один такт для вывода информацим на экран, то сложность такого алгоритма всё равно O(N), т.к. бесконечность гораздо больше единицы. Тоже самое касается алгоритмов, которые выполняются за O(2N) или более</li>
    <li>Big-O описывает только скорость роста. Поэтому мы отбрасываем константы при оценке сложности</li>
    <li>Алгоритм, описываемый как O(2N) должен описываться как O(N)</li>
</ul>

<!------------------------------------------------------>
<h3>O(формула_поведения_алгоритма)</h3>
<!------------------------------------------------------>
<pre><code class="bash">
<em>O(0)</em> # ничего не происходит
<em>O(1)</em> # постоянная величина (н-р: размер файлов не зависит на скорость передачи данных если они доставляются на самолете)
<em>O(N)</em> # зависимость прямо пропорциональна (линейная) и зависит от количества передаваемых бит (н-р: чем больше файлов, тем дольше их передавать по сети)
<em>O(N + N) = O(N)</em> # последователность действий - сложение
<em>O(N * N) = O(N<sup>2</sup>)</em> # вложенные действия - умножение
</code></pre>

<!------------------------------------------------------>
<h3>Быстродействие</h3>
<!------------------------------------------------------>
<h4>Рекурсия => Быстродействие: O(N)</h4>
<pre><code class="js">
function pow(x, n) {
    if (n != 1) {
        return x * pow(x, n - 1);
    } else {
        return x;
    }
}
</code></pre>

<h4>Сложение чисел => Быстродействие: O(1)</h4>
<pre><code class="js">
function sum(a, b) {
    return a + b;
}
</code></pre>

<h4>Быстродействие: O(N)</h4>
<div class="container-flex"><div class="container-half"><pre><code class="js">
let min = 1;
let max = 10;
for(let i=0; i<=100; i++) {
    if (i < min) min = i;
    if (i > max) max = i;
}
</code></pre></div><div class="container-half"><pre><code class="js">
let min = 1;
let max = 10;
for(let i=0; i<=100; i++) {
    if (i < min) min = i;
}
for(let i=0; i<=100; i++) {
    if (i > max) max = i;
}
</code></pre></div></div>

<!------------------------------------------------------>
<h3>Сложение и умножение</h3>
<!------------------------------------------------------>
<div class="container-flex"><div class="container-half">
<b>Быстродействие: O(A + B)</b>
<pre><code class="js">
let arrA = [1,2,3];
let arrB = [1,2,3];
for(let i=0; i<=arrA; i++) {
    console.log(i);
}
for(let i=0; i<=arrB; i++) {
    console.log(i);
}
// Проход по массивам выполняется последовательно
// Выполнение первого цикла не зависит от выполнения второго
// A - длина массива arrA
// B - длина массива arrB
</code></pre></div><div class="container-half">
<b>Быстродействие: O(A * B)</b>
<pre><code class="js">
let arrA = [1,2,3];
let arrB = [1,2,3];
for(let a=0; a<=arrA; a++) {
    for(let b=0; b<=arrB; b++) {
        console.log(a, b);
    }
}
// Выполнить что-то N раз, пока делаешь что-то свое
// Цикл по "B" зависим от цикла по "A"
</code></pre></div></div>
