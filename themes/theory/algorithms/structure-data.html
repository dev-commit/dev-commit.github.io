<h2>Структуры данных</h2>

<ul class="list-point">
    <li><u-text-define>Структуры данных</u-text-define> - способы хранить и организовывать множество однотипных и/или логически связанных данных</li>
    <li>Структуры данных позволяют производить 4 основных типа действий: доступ, поиск, вставку и удаление</li>    
</ul>

<!------------------------------------------------------>
<h3>List (Список)</h3>
<!------------------------------------------------------>
<ul class="list-point">
    <li><u-text-define>List (Список)</u-text-define> - представление пронумерованной последовательности значений, где одно и то же значение может присутствовать сколько угодно раз</li>
    <li>Обычный список позволяет очень быстро получить доступ к памяти, поскольку вы уже знаете нужный адрес</li>
    <li>У списков есть порядковые номера, поэтому можно вставлять значения в начало, середину и конец</li>
    <li>Списки отлично справляются с быстрым доступом к элементам в своём конце и работой с ними. Однако, для элементов из начала или середины они не слишком хороши, так как приходится вручную обрабатывать адреса памяти</li>
</ul>

<h4>Push (добавить в конец), Pop (удалить из конца) <u-code>O(1)</u-code></h4>
<pre><code class="bash">
# являются простыми операциями, поскольку не затрагивают весь остальной список
</code></pre>

<h4>Unshift (добавить в начало) <u-code>O(N)</u-code></h4>
<pre><code class="bash">
# чтобы добавить новый элемент в начало списка, нужно освободить пространство для этого значения, 
# сдвинув на один все последующие значения
[a, b, c, d, e]
 0  1  2  3  4
  ⬊  ⬊  ⬊  ⬊  ⬊
    1  2  3  4  5
[x, a, b, c, d, e]
</code></pre>

<h4>Shift (удалить из начала) <u-code>O(N)</u-code></h4>
<pre><code class="bash">
# удаляем первое значение и затем сдвигаем каждый элемент списка на предшествующий адрес
[x, a, b, c, d, e]
    1  2  3  4  5
  ⬋  ⬋  ⬋  ⬋  ⬋
 0  1  2  3  4
[a, b, c, d, e]
</code></pre>

<!------------------------------------------------------>
<h3>Stack (Стек)</h3>
<!------------------------------------------------------>
<ul class="list-point">
    <li><u-text-define>Stack (Стек)</u-text-define> - абстрактный тип данных, представляющий собой список элементов, организованных по принципу LIFO (англ. last in — first out, «последним пришёл — первым вышел»)</li>
    <li>Зачастую стек реализуется в виде однонаправленного списка (каждый элемент в списке содержит помимо хранимой информации в стеке указатель на следующий элемент стека). Но также часто стек располагается в одномерном массиве с упорядоченными адресами</li>
    <li><b>Операции</b>: добавление элемента (push), удаление (pop), чтение головного элемента (peek)</li>
    <li><b>push</b> добавляется новый элемент, указывающий на элемент, бывший до этого головой. Новый элемент теперь становится головным</li>
    <li><b>pop</b> убирается первый, а головным становится тот, на который был указатель у этого объекта (следующий элемент). При этом значение убранного элемента возвращается</li>
</ul>

<div class="container-flex"><div class="container-half">
<img src="/img/js/structure-stack1.png" width="550px">
</div><div class="container-half">
<img src="/img/js/structure-stack2.png" width="450px">
<ul class="list-point">
    <li>Организация стека в виде одномерного упорядоченного по адресам массива. push и pop</li>
</ul>
</div></div>

<!------------------------------------------------------>
<h3>Queue (Очередь)</h3>
<!------------------------------------------------------>
<ul class="list-point">
    <li><u-text-define>Queue (Очередь)</u-text-define> - абстрактный тип данных с доступом к элементам «первый пришёл — первый вышел» (FIFO, англ. first in, first out)</li>
    <li>Добавление элемента (<u>enqueue</u> — поставить в очередь) возможно лишь в конец очереди, выборка - только из начала очереди (<u>dequeue</u> - убрать из очереди), при этом выбранный элемент из очереди удаляется</li>
</ul>

<!------------------------------------------------------>
<h3>Дерево</h3>
<!------------------------------------------------------>
<u-link-wrapper>
    <a href="https://www.youtube.com/watch?v=wtgLQE9hjuk" target="_blank">[YouTube] Алгоритмы и структуры данных. Деревья</a>
</u-link-wrapper>

<ul class="list-point">
    <li><u-text-define>Деревья</u-text-define> - эмулирует древовидную структуру в виде набора связанных узлов (вершин) и ребер</li>
    <li>Дерево должно начинаться с единственного родителя, «корня» дерева</li>
    <li>Дерево считается ориентированным, если в корень не заходит ни одно ребро</li>
    <li><b>Определяющее свойство дерева</b> - существование только одного пути, соединяющего любые два узла</li>
</ul>

<h4>Определения</h4>

<div class="container-flex"><div class="container-half">
<ul class="list-point">
    <li><u>Вершина (узел)</u> - простой объект</li>
    <li><u>Ребро</u> - связь между двумя верщинами</li>
    <li><u>Путь в дереве</u> - список отдельных вершин, в котором следующие друг за другом вершины соединяются ребрами дерева</li>
    <li><u>Корневой узел</u> - самый верхний узел дерева (узел 8 на примере)</li>
    <li><u>Корень</u> - одна из вершин, по желанию наблюдателя</li>
    <li><u>Лист, листовой или терминальный узел</u> - узел, не имеющий дочерних элементов (узлы 1, 4, 7, 13)</li>
    <li><u>Внутренний узел</u> - любой узел дерева, имеющий потомков, и таким образом, не являющийся листовым узлом (3, 6, 10, 14)</li>
</ul>
</div><div class="container-half">
<img src="/img/js/structure-tree1.png" width="200px">
</div></div>

<h4>Представление дерева</h4>
<img src="/img/js/structure-tree2.jpg">

<h4>Общие операции</h4>
<ul class="list-point">
    <li>Вставка нового элемента в определённую позицию</li>
    <li>Вставка поддерева</li>
    <li>Добавление ветви дерева</li>
    <li>Нахождение корневого элемента для любого узла</li>
    <li>Нахождение наименьшего общего предка двух вершин</li>
    <li>Перебор всех элементов дерева</li>
    <li>Перебор элементов ветви дерева</li>
    <li>Поиск изоморфного поддерева</li>
    <li>Поиск элемента;</li>
    <li>Удаление ветви дерева</li>
    <li>Удаление поддерева</li>
    <li>Удаление элемента</li>
</ul>

<h4>Обход дерева</h4>
<img src="/img/js/structure-tree3.jpg" height="200px">

<h4>Обход двоичного дерева в глубину (DFS - Depth First Search)</h4>
<ul class="list-point">
    <li>Используется стек</li>
</ul>
<ol class="list-num">
    <li>Обработка узла поддерева</li>
    <li>Рекурсивный обход левого поддерева</li>
    <li>Рекурсивный обход правого поддерева</li>
</ol>

<ul class="list-point">
    <u>Прямой обход (сверху-вниз, pre-order)</u>
    <li>вначале обрабатывается узел, затем посещается левое и правое поддерево</li>
</ul>
<pre><code class="bash">
E, D, B, A, C, H, F, G
</code></pre>

<ul class="list-point">
    <u>Обратный обход (снизу вверх, post-order)</u>
    <li>вначале посещается левое и правое поддерево, затем обрабатывается узел</li>
</ul>
<pre><code class="bash">
A, C, B, D, G, F, H, E
</code></pre>

<ul class="list-point">
    <u>Поперечный обход (слева-направо, in-order)</u>
    <li>вначале посещается левое поддерево, затем узел и правое поддерево</li>
</ul>
<pre><code class="bash">
A, B, C, D, E, F, G, H
</code></pre>


<h4>Обход двоичного дерева в ширину (BFS - Breadth First Search)</h4>
<ul class="list-point">
    <li>Используется очередь, содержащая вершины, требующие просмотра</li>
    <li>Выполняется по слоям начиная от корня</li>
</ul>
<ol class="list-num">
    За одну итерацию алгоритма:
    <li>если очередь не пуста, извлекается вершина из очереди</li>
    <li>обрабатывается извлеченная вершина</li>
    <li>в очередь помещаются все дочерние</li>
</ol>
<pre><code class="bash">
E, D, H, B, F, A, C, G
</code></pre>

<!------------------------------------------------------>
<h3>Куча</h3>
<!------------------------------------------------------>
<ul class="list-point">
    <li><u-text-define>Куча</u-text-define> - специализированная структура данных типа дерево, которая удовлетворяет свойству кучи: если B является узлом-потомком узла A, то ключ(A) ≥ ключ(B). Из этого следует, что элемент с наибольшим ключом всегда является корневым узлом кучи, поэтому иногда такие кучи называют max-кучами (в качестве альтернативы, если сравнение перевернуть, то наименьший элемент будет всегда корневым узлом, такие кучи называют min-кучами)</li>
    <li><b>Реализация</b>: массив</li>
</ul>

<h4>Операции</h4>
<ul class="list-point">
    <li>Найти максимум или найти минимум: найти максимальный элемент в max-куче или минимальный элемент в min-куче, соответственно</li>
    <li>Удалить максимум или удалить минимум: удалить корневой узел в max- или min-куче, соответственно</li>
    <li>Увеличить ключ или уменьшить ключ: обновить ключ в max- или min-куче, соответственно</li>
    <li>Добавить: добавление нового ключа в кучу</li>
    <li>Слияние: соединение двух куч с целью создания новой кучи, содержащей все элементы обеих исходных</li>
</ul>

<!------------------------------------------------------>
<h3>Хеш-таблица</h3>
<!------------------------------------------------------>
<ul class="list-point">
    <li><u-text-define>Хеш-таблица</u-text-define> - это структура данных, реализующая интерфейс ассоциативного массива, а именно, она позволяет хранить пары (ключ, значение) и выполнять три операции: операцию добавления новой пары, операцию поиска и операцию удаления пары по ключу</li>
</ul>

<!------------------------------------------------------>
<h3>Граф</h3>
<!------------------------------------------------------>
<ul class="list-point">
    <li><u-text-define>Граф</u-text-define> - есть множество «вершин» (A, B, C, D, ...), связанных линиями</li>
</ul>
