<h2>Объектно-ориентированное программирование</h2>

<ul class="list-point">
    <li><u-text-define>Объектно-ориентированное программирование</u-text-define> - методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определённого класса, а классы образуют иерархию наследования</li>
</ul>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>1. Инкапсуляция</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
    <li><u-text-define>Инкапсуляция</u-text-define> – отделение и защита внутреннего интерфейса от внешнего</li>
    <li><u-text-underline>Внутренний интерфейс</u-text-underline> – приватные свойства и методы, доступ к которым может быть осуществлен только из других методов класса</li>
    <li><u-text-underline>Внешний интерфейс</u-text-underline> – публичные свойства и методы класса, предоставляющие доступ к внутренней реализации</li>
    <li>Мы обращаемся с объектами как с единой сущностью, а не как с набором отдельных полей и методов, тем самым скрываем и защищаем реализацию класса. Если клиентский код не знает ничего, кроме публичного интерфейса, он не может зависеть от деталей реализации</li>
    <li>Обычно прячут все поля класса и предоставляют набор методов для работы с ними. У разработчиков есть универсальный интерфейс для доступа к свойствам, им не важна какая реализация метода</li>
</ul>

<!------------------------------------------------------------->
<h4>Задача</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li>Обеспечить согласованность и целостность данны класса</li>
    <li>Защитить данные от некорректного использования или повреждения</li>
    <li>Нет зависимости от деталей внутренней реализации</li>
</ul>

<!------------------------------------------------------------->
<h4>Сокрытие и Инкапсуляция</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li><u>Сокрытие</u> - разграничение доступа частей программы к компонентам друг друга</li>
    <li><u>Инкапсуляция</u> - свойство системы объединять данные и методы работы с ними в класс</li>
</ul>

<!------------------------------------------------------------->
<h4>Геттеры и Сеттеры</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li><u-text-define>Геттеры и Сеттеры (Аксессоры)</u-text-define> - доступ к свойствам класса</li>
</ul>

<v-two-code type="js;js" comment="js;java">
<template v-slot:first>
class User {
    constructor() {
        this._name = 'Tony';
    }
    get name() {
        return this._name;
    }
    set name(value) {
            this._name = value;
    }
}
let user = new User();
user.name = 'Jack';
let name = user.name; // => Jack
</template>
<template v-slot:last>
public class User {
    private String name;

    public String getName() {
        return name;
    }
    public String setName(String name) {
        this.name = name;
    }
}
</template>
</v-two-code>

<!------------------------------------------------------------->
<h4>Модификаторы доступа (Методы классов)</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li><u-text-define>Модификаторы доступа (access modifiers)</u-text-define> - способ ограничения доступа к методам, классам, переменным</li>
</ul>

<ul class="list-point">
    <li><u-code-list>private</u-code-list> - Видны внутри класса. Запрещает доступ из подкласса. Методы не наследуются</li>
    <li><u-code-list>protected</u-code-list> - Видны внутри класса, пакета и наследников. Нельзя вызвать вне класса</li>
    <li><u-code-list>static</u-code-list>    - Не имеет доступ к instance класса (this нельзя получить). Н-р, Math статический класс, в котором содержится набор статических методов. Не создаем instance через new, но можем пользоваться методами</li>
    <li><u-code-list>package</u-code-list> - Видны только из текущего пакета</li>
    <li><u-code-list>public</u-code-list> - Видны из всего приложения. Можно обратиться к this</li>
</ul>

<ul class="list-point">
    <b>JavaScript</b>
    <li><u-text-underline>Приватные (private)</u-text-underline> - let prop локальные переменные/методы, включая параметры конструктора. доступн только внутри класса</li>
    <li><u-text-underline>Публичные (public)</u-text-underline> - this.prop свойства/методы, записанные в this класса</li>
    <li><u-text-underline>Защищённые (protected)</u-text-underline> - this._prop начинаются с подчеркивания. доступны внутри класса и для его потомков</li>
</ul>

<pre><code class="js">
public class Car {
    <u-code>public</u-code> void startMoving() {
        turnKey();
        startEngine();
    }
    <u-code>private</u-code> void turnKey() {...}
    <u-code>private</u-code> void startEngine() {...}
}
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>2. Наследование</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
    <li><u-text-define>Наследование</u-text-define> - описание нового класса на основе уже существующего с частично или полностью заимствующейся функциональностью</li>
    <li>Наследование транзитивно: класс может наследоваться от другого класса, который наследуется от третьего, и так далее вплоть до базового класса (Object). Наследник может переопределить какие-то методы и поля чтобы изменить поведение по умолчанию</li>
    <li><i><u>SuperClass:</u> базовый, родительский, предок, надкласс, супер класс</i></li>
    <li><i><u>SubClass:</u> наследник, дочерний, потомок, подкласс, суб класс, производный</i></li>
    <li>Подкласс должен являться более специализированной версией супер-класса</li>
    <li><u-text-define>Множественное наследование</u-text-define> - у одного подкласса существует сразу несколько супер-классов</li>
</ul>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>3. Полиморфизм</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
    <li><u-text-define>Полиморфизм</u-text-define> ("множество форм") - возможность единообразно обрабатывать объекты с различной реализацией при условии наличия общего интерфейса. <u>«Один интерфейс, множество реализаций»</u></li>
    <li>Позволяет одно и то же имя (например имя метода) использовать для решения внешне схожих, но технически разных задач</li>
    <li>Изменение поведения одного и того же метода в рамках разных классов</li>
    <li><b>Задачи:</b> позволяет расширить библиотеки не требуя доступа к их исходному коду</li>
    <hr>

    <li><u-text-define>Абстрактный метод</u-text-define> - метод без реализации</li>
    <li><u-text-define>Абстрактный класс</u-text-define> - если в классе есть хотя бы 1 абстрактный метод, класс является абстрактным, следовательно мы не можем создать экземпляр класса и воспользоваться им, пока не переопределим этот метод, добавляя различную реализацию в подклассах</li>

    <li><u-text-define>Перегрузка</u-text-define> - одна из форм полиморфизма (ad hoc / специальный полиморфизм)</li>
    <li><u-text-define>Механизм "Позднего связывания" / "Динамического связывания"</u-text-define> - откладывает принятие решения о том, какой из вариантов кода выполнить до момента выполнения программы. В результате вызова метода draw(), будут выполнены именно те инструкции, которые определены в фактическом классе данного объекта. Без механизма позднего связывания полиморфизм не будет работать</li>
</ul>

<i>«Один интерфейс, множество реализаций». Интерфейс - метод draw(). У него есть несколько вариантов реализаций</i>

<img src="/img/js/oop/polymorphism.png" width="550px">

<v-two-code type="js;js" comment="comment;comment">
<template v-slot:first>
// Динамический полиморфизм
// Один и тот же метод (draw) в зависимости от реализации выводит различные значения
let circle = new Circle();
let square = new Square();
let triangle = new Triangle();

circle.<u-code>draw()</u-code>;
square.<u-code>draw()</u-code>;
triangle.<u-code>draw()</u-code>;
</template>
<template v-slot:last>
// Статический полиморфизм
// Метод с одинаковым названием, но различными параметрами
public class Shape {
    public void draw() {...}
    public void draw(String s) {...}
    public void draw(int a) {...}
}
</template>
</v-two-code>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>4. Абстракция</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
    <li><u-text-define>Абстракция</u-text-define> способ представления объекта в программе, позволяющий работать с объектами не вдаваясь в особенности их реализации</li>
    <li>Инкапсуляция помогает реализовать абстракцию. Можно абстрагировать внутренне устройство класса</li>
    <hr>

    <li>Абстракция - объекты из окружающего мира которые мы хотим описать. Выделяем только черты, необходимые для решения задачи. Н-р: есть животное, но для конкретной задачи нужны не все характеристики, а только "вес" и "возраст"</li>
    <li>Абстрагировать объект или явление - отбросить все маловажные элементы для того, чтобы увидеть его суть</li>
    <li>Когда моделируем объект, можем отказаться от некоторых его частей неважных в контексте программы</li>
</ul>
