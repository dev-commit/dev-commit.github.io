<h2>Рефакторинг</h2>

<ul class="list-point">
    <li><u-text-define>Рефакторинг (refactoring)</u-text-define> - процесс изменения внутренней структуры программы, не затрагивающий её внешнего поведения и имеющий целью облегчить понимание её работы. В основе рефакторинга лежит последовательность небольших эквивалентных (то есть сохраняющих поведение) преобразований. Поскольку каждое преобразование маленькое, программисту легче проследить за его правильностью, и в то же время вся последовательность может привести к существенной перестройке программы и улучшению её согласованности и чёткости</li>
    <li>Цель рефакторинга — сделать код программы более легким для понимания; без этого рефакторинг нельзя считать успешным</li>
    <li>Рефакторинг следует отличать от <u>оптимизации производительности</u>. Как и рефакторинг, оптимизация обычно не изменяет поведение программы, а только ускоряет её работу. Но оптимизация часто затрудняет понимание кода, что противоположно рефакторингу</li>
    <li>С другой стороны, нужно отличать рефакторинг от <u>реинжиниринга</u>, который осуществляется для расширения функциональности программного обеспечения. Как правило, крупные рефакторинги предваряют реинжиниринг</li>
</ul>

<h4>Причины применения рефакторинга</h4>
<ol class="list-num">
    <li>Необходимо добавить новую функцию, которая недостаточно укладывается в принятое архитектурное решение</li>
    <li>Необходимо исправить ошибку, причины возникновения которой сразу не ясны</li>
    <li>Преодоление трудностей в командной разработке, которые обусловлены сложной логикой программы</li>
</ol>

<h4>Признаки плохого кода</h4>
<ol class="list-num">
    <li>Дублирование кода</li>
    <li>Длинный метод</li>
    <li>Большой класс</li>
    <li>Длинный список параметров</li>
    <li>"Жадные" функции — это метод, который чрезмерно обращается к данным другого объекта</li>
    <li>Избыточные временные переменные</li>
    <li>Классы данных</li>
    <li>Несгруппированные данные</li>
</ol>

<h4>Методы рефакторинга</h4>
<ul class="list-point">
    <li><u-code>Изменение сигнатуры метода (change method signature)</u-code> - добавление, изменение или удаление параметра метода. Изменив сигнатуру метода, необходимо скорректировать обращения к нему в коде всех клиентов. Это изменение может затронуть внешний интерфейс программы, кроме того, не всегда разработчику, изменяющему интерфейс, доступны все клиенты этого интерфейса, поэтому может потребоваться та или иная форма регистрации изменений интерфейса для последующей передачи их вместе с новой версией программы
    </li>

    <li><u-code>Инкапсуляция поля (encapsulate field)</u-code> В случае, если у класса имеется открытое поле, необходимо сделать его закрытым и обеспечить методы доступа. После «Инкапсуляции поля» часто применяется «Перемещение метода»</li>
    
    <li><u-code>Выделение класса (extract class)</u-code></li>
    <li><u-code>Выделение интерфейса (extract interface)</u-code></li>
    <li><u-code>Выделение локальной переменной (extract local variable)</u-code></li>
    <li><u-code>Выделение метода (extract method)</u-code> - выделение из длинного и/или требующего комментариев кода отдельных фрагментов и преобразовании их в отдельные методы, с подстановкой подходящих вызовов в местах использования. В этом случае действует правило: если фрагмент кода требует комментария о том, что он делает, то он должен быть выделен в отдельный метод. Также правило: один метод не должен занимать более чем один экран (25-50 строк, в зависимости от условий редактирования), в противном случае некоторые его фрагменты имеют самостоятельную ценность и подлежат выделению. Из анализа связей выделяемого фрагмента с окружающим контекстом делается вывод о перечне параметров нового метода и его локальных переменных</li>
    
    <li><u-code>Генерализация типа (generalize type)</u-code></li>
    <li><u-code>Встраивание (inline)</u-code></li>
    <li><u-code>Введение фабрики (introduce factory)</u-code></li>
    <li><u-code>Введение параметра (introduce parameter)</u-code></li>
    <li><u-code>Подъём метода (pull up method)</u-code></li>
    <li><u-code>Спуск метода (push down method)</u-code></li>
    <li><u-code>Переименование метода (rename method)</u-code></li>
    <li><u-code>Перемещение метода (move method)</u-code> применяется по отношению к методу, который чаще обращается к другому классу, чем к тому, в котором сам располагается</li>

    <li><u-code>Замена условного оператора полиморфизмом (replace conditional with polymorphism)</u-code> Условный оператор с несколькими ветвями заменяется вызовом полиморфного метода некоторого базового класса, имеющего подклассы для каждой ветви исходного оператора. Выбор ветви осуществляется неявно, в зависимости от того, экземпляру какого из подклассов оказался адресован вызов</li>
    
    <li><u-code>Замена наследования делегированием (replace inheritance with delegation)</u-code></li>
    <li><u-code>Замена кода типа подклассами (replace type code with subclasses)</u-code></li>
</ul>

<h4>Проблемы, возникающие при проведении рефакторинга</h4>
<ul class="list-point">
    <li>Проблемы, связанные с базами данных</li>
    <li>Проблемы изменения интерфейсов</li>
    <li>Трудности при изменении дизайна</li>
</ul>

<h4>Средства автоматизации рефакторинга</h4>
<ul class="list-point">
    Технические критерии для инструментов рефакторинга:
    <li>Базы данных программы</li>
    <li>Деревья синтаксического разбора</li>
    <li>Точность</li>
    Практические критерии для инструментов рефакторинга:
    <li>Скорость</li>
    <li>Отмена модификаций</li>
    <li>Интеграция с другими инструментами</li>
</ul>
