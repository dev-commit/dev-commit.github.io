<h2>Запахи кода (Code Smell)</h2>

<ul class="list-point">
    <li><u-text-define>Code Smell (Запахи кода)</u-text-define> - код с признаками (запахами) проблем в системе</li>
    <li>Запахи кода - ключевые признаки необходимости рефакторинга</li>
    <li>Запахи кода - это не набор чётких правил, а описание мест, на которые нужно обращать внимание при рефакторинге</li>
</ul>

<!------------------------------------------------------------->
<h4>Общие запахи объектно-ориентированного кода</h4>
<!------------------------------------------------------------->
<ol class="list-num">
    <li><u-code>Дублирование кода</u-code> - использование одинаковых структур кода в нескольких местах</li>
    <li><u-code>Длинный метод</u-code></li>
    <li><u-code>Большой класс</u-code></li>
    <li><u-code>Длинный список параметров</u-code> - использование объектов позволяет, в случае изменения передаваемых данных, модифицировать только сам объект</li>
    <li><u-code>Расходящиеся модификации</u-code> - проблема возникает, когда при модификации в системе невозможно выделить определённое место, которое нужно изменить</li>
    <li><u-code>Стрельба дробью</u-code> - при выполнении любых модификаций приходится вносить множество мелких изменений в большое число классов</li>
    <li><u-code>Завистливые функции</u-code> - метод обращается к данным другого объекта чаще, чем к собственным данным</li>
    <li><u-code>Группы данных</u-code> - группы данных, встречающихся совместно, нужно превращать в самостоятельный класс</li>
    <li><u-code>Одержимость элементарными типами</u-code> - Проблема связана с использованием элементарных типов вместо маленьких объектов для небольших задач, таких как валюта, диапазоны, специальные строки для телефонных номеров и т.д.</li>
    <li><u-code>Операторы типа switch</u-code> - часто один и тот же блок switch оказывается разбросанным по разным местам программы. При добавлении в переключатель нового варианта приходится искать все эти блоки switch и модифицировать их</li>
    <li><u-code>Параллельные иерархии наследования</u-code> - всякий раз при порождении подкласса одного из классов приходится создавать подкласс другого класса</li>
    <li><u-code>Ленивый класс</u-code> - класс, затраты на существование которого не окупаются выполняемыми им функциями, должен быть ликвидирован</li>
    <li><u-code>Теоретическая общность</u-code> - на определённом этапе существования программы обеспечивается набор механизмов, который, возможно, потребуется для некоторой будущей функциональности. Программу становится труднее понимать и сопровождать</li>
    <li><u-code>Временное поле</u-code> поле, которое нужно объекту только при определённых обстоятельствах. Такое положение вещей трудно для понимания, так как ожидается, что объекту нужны все его поля</li>
    <li><u-code>Цепочка вызовов</u-code> появляется тогда, когда клиент запрашивает у одного объекта другой объект, другой объект запрашивает ещё один объект и т. д. Такие последовательности вызовов означают, что клиент связан с навигацией по структуре классов. Любые изменения промежуточных связей означают необходимость модификации клиента</li>
    <li><u-code>Посредник</u-code> - чрезмерное использование делегирования может привести к появлению классов, у которых большинство методов состоит только из вызова метода другого класса</li>
    <li><u-code>Неуместная близость</u-code> возникает тогда, когда классы чаще, чем следовало бы, погружены в закрытые части друг друга</li>
    <li><u-code>Альтернативные классы с разными интерфейсами</u-code> - два класса, в которых часть функциональности общая, но методы, реализующие её, имеют разные параметры</li>
    <li><u-code>Неполнота библиотечного класса</u-code> Библиотеки через некоторое время перестают удовлетворять требованиям пользователей. Естественное решение — поменять кое-что в библиотеках, но библиотечные классы не изменять</li>
    <li><u-code>Классы данных</u-code> - это классы, которые содержат только поля и методы для доступа к ним, это просто контейнеры для данных, используемые другими классами</li>
    <li><u-code>Отказ от наследства</u-code> Если наследник использует лишь малую часть унаследованных методов и свойств родителя, это является признаком неправильной иерархии</li>
    <li><u-code>Комментарии</u-code> Почувствовав потребность написать комментарий, попробуйте изменить структуру кода так, чтобы любые комментарии стали излишними</li>
</ol>
