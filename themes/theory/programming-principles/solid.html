<h2>SOLID</h2>

<ul class="list-point">
    <li><u-text-define>SOLID</u-text-define> (Single Responsibility, Open-Closed, Liskov Substitution, Interface Segregation, Dependency inversion) - пять основных принципов ООП</li>
    <li>При создании программных систем использование принципов SOLID способствует созданию такой системы, которую будет легко поддерживать и расширять в течение долгого времени</li>
    <li><b>Цель принципов</b>: способствуют изменениям; легко понимаемы; повторно используемы</li>
</ul>

<h4>Принципы</h4>
<ul class="list-point">
    <li><u-text-define>[S] SRP</u-text-define> (The Single Responsibility Principle. Принцип единственной ответственности)</li>
    <li>Каждый класс выполняет лишь одну задачу/ответственность</li>

    <li class="margin-top"><u-text-define>[O] OCP</u-text-define> (The Open Closed Principle. Принцип открытости/закрытости)</li>
    <li>Программные сущности (классы, модули, функции и т.д.) должны быть открыты для расширения, но закрыты для модификации</li>
    <li>От класса можно наследоваться и расширить его функциональность, но нет прямой возможности менять функциональность базового класса</li>
    <li>Неважно сколько добавили свойств объекту, код будет работать</li>

    <li class="margin-top"><u-text-define>[L] LSP</u-text-define> (The Liskov Substitution Principle. Принцип подстановки Барбары Лисков)</li>
    <li>При подстановке в качестве класса его дочерний класс всё доожно работать</li>
    <li>Если гарантируется функциональность для базового класса, то гарантируется функциональность для всех его потомков (поведение программы не изменится)</li>
    <li>Поведение в методах-наследниках менять нельзя</li>
    <li>Наследующий класс должен дополнять, а не изменять базовый и не должен противоречить поведению, заданному базовым классом</li>
    <li>То что отнаследовали должно вести себя так же как и базовый класс</li>

    <li class="margin-top"><u-text-define>[I] ISP</u-text-define> (The Interface Segregation Principle. Принцип разделения интерфейса)</li>
    <li>Разделение интерфейса на более мелкие</li>
    <li>Абстракция (API или класс) должна быть сгруппирована в мелкие единицы и содержать только необходимые методы, давая возможность использовать только то, что необходимо. При необходимости разделить функциональность на несколько классов. При изменении методов интерфейса не должны меняться программные сущности, которые этот метод не используют</li>
    <li>Программные сущности не должны зависеть от методов, которые они не используют</li>

    <li class="margin-top"><u-text-define>[D] DIP</u-text-define> (The Dependency Inversion Principle. Принцип инверсии зависимостей)</li>
    <li>Зависимость кода должна строиться от абстракции, а не от класса</li>
    <li>Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций</li>
    <li>Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций</li>
    <li>Зависимость на Абстракциях. Нет зависимости на что-то конкретное</li>
    <li>Решает, когда части зависят друг от друга. Когда появляются связи между двумя объектами, их нужно разделить</li>
</ul>

<h4>DIP</h4>
<pre><code class="bash">
Decoupling
    &#9776; Inversion of Control
        &#8226; Dependency Injection
    &#9776; Dependency Invertion
        &#8226; Inderfaces
</code></pre>

<h4>Когда следует применять</h4>
<ul class="list-point">
    <li>Жесткость - трудно вносить изменнея в код. Одно изменение вносит изменение в другие модули</li>
    <li>Хрупкость - свойство программы повреждаться во многих местах при внесении одного изменения</li>
    <li>Ненужная сложность - содержание элементов не используемых в данный момент</li>
    <li>Ненужные повторения - проблема дублирования кода</li>
    <li>Непрозрачность - трудность кода для понимания</li>
</ul>
