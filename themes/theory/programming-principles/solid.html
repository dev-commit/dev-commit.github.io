<h2>SOLID</h2>

<ul class="list-point">
    <li><u-text-define>SOLID</u-text-define> (Single Responsibility, Open-Closed, Liskov Substitution, Interface Segregation, Dependency inversion) - пять основных принципов ООП</li>
    <li>При создании программных систем использование принципов SOLID способствует созданию такой системы, которую будет легко поддерживать и расширять в течение долгого времени</li>
    <li><b>Цель принципов</b>: способствуют изменениям; легко понимаемы; повторно используемы</li>
</ul>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Принципы</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<!------------------------------------------------------------->
<h4>[S] SRP</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li><u-text-define>The Single Responsibility Principle</u-text-define> - Принцип единственной ответственности</li>
    <li>Каждый класс выполняет лишь одну задачу/ответственность</li>
</ul>

<v-details title="Пример">
<v-two><template v-slot:first>
<b>Да</b>

<v-code lang="js border" title="">
// Класс для обоработки новости
class News {
    constructor(title, text) {
        this.title = title;
        this.text = text;
        this.modified = false;
    }
    update(text) {
        this.text = text;
        this.modified = true;
    }
    // Разные форматы новости должно быть в отдельном класса
    // html() {}
    // json() {}
}
</v-code>

<v-code lang="js border" title="">
// Класс для формирования новости в разных форматах
class NewsPrinter {
    constructor(news) {
        this.news = news;
    }
    html() {
        return `
            &lt;div&gt;
                &lt;h1&gt;${this.news.title}&lt;/h1&gt;
                &lt;h1&gt;${this.news.text}&lt;/h1&gt;
            &lt;/div&gt;
        `
    }
    json() {
        return JSON.stringify({
            title: this.news.title,
            text: this.news.text,
            modified: this.news.modified
        })
    }
}
</v-code>

<v-code lang="js border" title="">
const printer = new NewsPrinter(
    new News('Название новости', 'Описание новости')
)

console.log(printer.html());
console.log(printer.json());
</v-code>

</template><template v-slot:last>
<b>Нет</b>

<v-code lang="js" title="">
// Класс для обоработки новости
class News {
    constructor(title, text) {
        this.title = title;
        this.text = text;
        this.modified = false;
    }
    update(text) {
        this.text = text;
        this.modified = true;
    }

    // Разные форматы новости
    html() {
        return `
            &lt;div&gt;
                &lt;h1&gt;${this.title}&lt;/h1&gt;
                &lt;h1&gt;${this.text}&lt;/h1&gt;
            &lt;/div&gt;
        `
    }
    json() {
        return JSON.stringify({
            title: this.title,
            text: this.text,
            modified: this.modified
        })
    }
}
</v-code>

<v-code lang="js" title="">
const news = new News(
    'Название новости',
    'Описание новости'
);

console.log(news.html());
console.log(news.json());
</v-code>

</template></v-two>
</v-details>






<!------------------------------------------------------------->
<h4>[O] OCP</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li><u-text-define>The Open Closed Principle</u-text-define> - Принцип открытости/закрытости</li>
    <li>Программные сущности (классы, модули, функции и т.д.) должны быть открыты для расширения, но закрыты для модификации</li>
    <li>От класса можно наследоваться и расширить его функциональность, но нет прямой возможности менять функциональность базового класса</li>
    <li>Неважно сколько добавили свойств объекту, код будет работать</li>
    <li>Если привносим что-то новое, то не меняем старый код</li>
</ul>

<v-details title="Пример">

<v-two><template v-slot:first>

<b>Да</b>

<v-code lang="js border" title="Базовый класс">
class Shape {
    area() {
        //
    }
}
</v-code>

<v-code lang="js border" title="Наследники">
class Square extends Shape {
    constructor(size) {
        super();
        this.size = size;
    }
    area() {
        return this.size ** 2;
    }
}

class Circle extends Shape {
    constructor(radius) {
        super();
        this.radius = radius;
    }
    area() {
        return (this.radius * 2) * Math.PI;
    }
}
</v-code>

<ul class="list-point">
    <li>Класс AreaCalculator открыли для расширений и закрыли для модификаций - метод sum сделан 1 раз и больше к нему не возвращаемся</li>
</ul>

<v-code lang="js border" title="Класс для калькуляции">
class AreaCalculator {
    constructor(shapes = []) {
        this.shapes = shapes;
    }
    sum() {
        return this.shapes.reduce((acc, shape) => {
            acc += shape.area();
            return acc;
        }, 0)
    }
}

const calc = new AreaCalculator([
    new Square(10),
    new Circle(1)
]);

console.log(calc.sum());
</v-code>

</template><template v-slot:last>
<b>Нет</b>

<v-code lang="js" title="Наследники">
class Square {
    constructor(size) {
        this.type = 'square';
        this.size = size;
    }
}

class Circle {
    constructor(radius) {
        this.type = 'circle';
        this.radius = radius;
    }
}
</v-code>

<v-code lang="js" title="Класс для калькуляции">
class AreaCalculator {
    constructor(shapes = []) {
        this.shapes = shapes;
    }

    sum() {
        return this.shapes.reduce((acc, shape) => {
            if (shape.type === 'circle') {
                acc += (shape.radius * 2) * Math.PI
            } else if (shape.type === 'square') {
                acc += shape.size ** 2
            }

            return acc;
        }, 0)
    }
}

const calc = new AreaCalculator([
    new Square(10),
    new Circle(1)
]);

console.log(calc.sum());
</v-code>

</template></v-two>
</v-details>

<!------------------------------------------------------------->
<h4>[L] LSP</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li><u-text-define>The Liskov Substitution Principle</u-text-define> - Принцип подстановки Барбары Лиско́в</li>
    <li>Если гарантируется функциональность для базового класса, то гарантируется функциональность для всех его потомков (поведение программы не изменится)</li>
    <li>Поведение в методах-наследниках менять нельзя</li>
    <li>Наследующий класс должен дополнять, а не изменять базовый и не должен противоречить поведению, заданному базовым классом</li>
</ul>

<v-details title="Пример">
<v-code lang="js" title="">
//
</v-code>
</v-details>

<!------------------------------------------------------------->
<h4>[I] ISP</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li><u-text-define>The Interface Segregation Principle</u-text-define> - Принцип разделения интерфейса</li>
    <li>Разделение интерфейса на более мелкие части</li>
    <li>Абстракция (API или класс) должна быть сгруппирована в мелкие единицы и содержать только необходимые методы, давая возможность использовать только то, что необходимо. При необходимости разделить функциональность на несколько классов. При изменении методов интерфейса не должны меняться программные сущности, которые этот метод не используют</li>
    <li>Программные сущности не должны зависеть от методов, которые они не используют</li>
</ul>

<v-details title="Пример">
<v-code lang="js" title="">
//
</v-code>
</v-details>

<!------------------------------------------------------------->
<h4>[D] DIP</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li><u-text-define>The Dependency Inversion Principle</u-text-define> - Принцип инверсии зависимостей</li>
    <li>Зависимость кода должна строиться от абстракции, а не от класса</li>
    <li>Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций</li>
    <li>Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций</li>
    <li>Зависимость на Абстракциях. Нет зависимости на что-то конкретное</li>
    <li>Решает, когда части зависят друг от друга. Когда появляются связи между двумя объектами, их нужно разделить</li>
</ul>

<v-details title="Пример">
<v-code lang="js" title="">
//
</v-code>
</v-details>

<v-code lang="bash" title="">
Decoupling
    &#9776; Inversion of Control
        &#8226; Dependency Injection
    &#9776; Dependency Invertion
        &#8226; Inderfaces
</v-code>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Когда следует применять</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
    <li><u>Жесткость</u> - трудно вносить изменнея в код. Одно изменение вносит изменение в другие модули</li>
    <li><u>Хрупкость</u> - свойство программы повреждаться во многих местах при внесении одного изменения</li>
    <li><u>Ненужная сложность</u> - содержание элементов не используемых в данный момент</li>
    <li><u>Ненужные повторения</u> - проблема дублирования кода</li>
    <li><u>Непрозрачность</u> - трудность кода для понимания</li>
</ul>
