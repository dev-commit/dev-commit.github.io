<h2>Connect</h2>

<ul class="list-point">
    <li><u-text-define>Connect</u-text-define> - подключение компонента к Store (декоратор)</li>
    <li>Результат работы функции <u>connect</u> - новый присоединенный компонент, который оборачивает переданный компонент. Компонент <u-code-text>&lt;App /&gt;</u-code-text> на выходе получился <u-code-text>&lt;Connected(App)&gt;</u-code-text>. В свойствах (<u-code-text>props</u-code-text>) компонента <u-code-text>&lt;App /&gt;</u-code-text> теперь есть метод redux <u-code-text>store - dispatch</u-code-text>, и <u>объект свойств</u></li>
</ul>

<ul class="list-point">
    <li><u-menu-code>connect</u-menu-code> </li>
    <ul class="list-point">
        <li><u-code-text>mapStateToProps</u-code-text> - "маппинг" (соответствие) <u-text-underline>state</u-text-underline> к props. Подписаться на обновления данных</li>
        <ul class="list-point">
        	<li>Не только получаем в <u-code-text>this.props.XXX</u-code-text> данные, но еще подписываемся на изменение этих данных</li>
	    	<li>Когда мы подписываемся только на нужные редьюсеры в компоненте, перерисовка происходит только в случае изменения конкретно этих данных. Если же мы бы подписались просто на весь корневой редьюсер, то не важно в каком бы редьюсере изменились данные - все подписанные на корневой редьюсер компоненты обновились бы</li>
        </ul>

        <li><u-code-text>mapDispatchToProps</u-code-text> - "маппинг" (соответствие) <u-text-underline>dispatch</u-text-underline> к props. "Прокинуть" actions в контейнер</li>
    </ul>
</ul>

<pre><code class="js"><u-code-title>Component</u-code-title>
import { connect } from 'react-redux';

const mapStateToProps = state => ({
	myValue: state.myReducer
})
const mapDispatchToProps = {
	getMethod: getMethod
}
export default connect(
	mapStateToProps,
	mapDispatchToProps
)(Component);
</code></pre>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>mapDispatchToProps</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<v-two-code type="js;js" comment="Объект;Функция">
<template v-slot:first>
const mapDispatchToProps = {
	getPhotosAction: return
}
</template>
<template v-slot:last>
const mapDispatchToProps = function(<u-code>dispatch</u-code>) {
	return {
		getPhotosAction: function(year) {
			return <u-code>dispatch</u-code>(getPhotos(year));
		}
	}
}
</template>
</v-two-code>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Варианты</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<v-two><template v-slot:first>
<pre><code class="js">
export default connect(
	null,              // subscribe = false
	null               // action = false
)(Component);
</code></pre>
<pre><code class="js">
export default connect(
	mapStateToProps,   // subscribe = true
	null               // action = false
)(Component)
</code></pre>
</template><template v-slot:last>
<pre><code class="js">
export default connect(
	null,              // subscribe = false
	mapDispatchToProps // action = true
)(Component)
</code></pre>
<pre><code class="js">
export default connect(
	mapStateToProps,   // subscribe = true
	mapDispatchToProps // action = true
)(Component)
</code></pre>
</template></v-two>
