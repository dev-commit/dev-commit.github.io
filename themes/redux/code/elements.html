<h2>Элементы</h2>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>1. View (компонент)</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
    <li>Компонент</li>
</ul>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>2. Store</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
    <li>Помещаются все данные приложения</li>
    <li>Store иммутабельный: мы можем создавать всегда только новую копию данных, а не менять старое состояние store</li>
    <li>В Redux <u>ТОЛЬКО ОДИН</u> объект Store</li>
</ul>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>3. Actions (объект)</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
    <li>Описывает факт, что что-то произошло, но не указывает, как состояние приложения должно измениться в ответ (<u>Reducer</u>). Изменение состоние происходит с помощью <u>Actions</u></li>
    <li><u-text-underline>ActionsCreator</u-text-underline> - функция для вызова Action</li>
    <hr>
    <li><u-code-text>type</u-code-text> - обязательное поле</li>
    <li><u-code-text>payload</u-code-text> - свойство в которое помещаются все данные, которые передаются вместе с действием</li>
</ul>

<!------------------------------------------------------------->
<h4>Для чего нужен Actions</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li>Action - объект, который описывает какое-то действие за которым скрываетмся какой-то Reducer. Реализация того что скрывается за Action это уже детали и она не принципиальна</li>
    <li>Вместо того чтобы несвязанно запускать изменения, мы пытаемся его связать с Action, который как правило никогда не будет изменяться, а за ним будет уже стоять реализация</li>
    <li>Приложение может пережить рефакторинг, но Action описывают бизнес-логику, которая не должна поменяться</li>
    <li>Каждый Action - это метаданные (metaknowledge) - знания о том что мы делали (получали пользователя, добавляли пользователя, фильтровали и т.д.). К бизнес-логике не относится</li>
    <li>this</li>
</ul>

<ul class="list-point">
    <b>Задача: Добавить пользователя</b>
    <li>- пользователь может добавиться только на фронте</li>
    <li>- пользователь может добавиться в базу данных</li>
    <li>Для Action это всё равно будет ADD_USER</li>
</ul>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>4. Reducer (преобразователь)</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
    <li>Чистая функция типа <u-code-text>(state, action) => newState</u-code-text>, которая берет на вход <u>предыдущее состояние</u> и <u>action</u> и возвращает новое состояние. Не модифицирует данные, а всегда возвращает новые данные. Указывает, как состояние приложения должно измениться в ответ на Action</li>
    <li>Мы не мутировали наш state, мы создали новый state. В редьюсере, мы всегда должны возвращать новый объект, а не измененный предыдущий</li>
    <li>Объект, который мы возвращаем в редьюсере, далее с помощью функции <u-code-text>connect</u-code-text>, превратится в свойства для компонентов. Благодаря этому, внутри компонента <u-code-text>&lt;Component /&gt;</u-code-text>, мы сможем получить доступ к свойству <u-code-text>this.props.name_prop</u-code-text></li>
    <li><u-text-underline>Reducer Composition</u-text-underline> - фундаментальный шаблон построения redux приложений: мы разбиваем наше глобальное состояние на кусочки, за каждый кусочек отвечает свой <u-code-text>reducer</u-code-text>. Кусочки объединяются в <u-code-text>rootReducer</u-code-text> Корневом Редьюсере</li>
</ul>

<!------------------------------------------------------------->
<h4>Чистые функции</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li><u-text-define>Чистые функции</u-text-define> (pure functions)</li>
    <li>Возвращает один и тот же результат для одинаковых входных данных</li>
    <li>Не изменяет входные данные (иммутабельность)</li>
    <li>Не зависит от внешнего состояния (базы данных, DOM или глобальной переменной)</li>
    <li>Не имеет побочных эффектов (side effects): не влияют на состояние программы</li>
    <li>Чистые функции могут вызывать только чистые функции</li>
</ul>


