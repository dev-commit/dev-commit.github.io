<h2>React.PureComponent</h2>

<ul class="list-point">
    <li><u-text-define>React.PureComponent</u-text-define> похож на <u-code-text>React.Component</u-code-text>. Отличие заключается в том, что <u-code-text>React.Component</u-code-text> не реализует <u-code-text>shouldComponentUpdate()</u-code-text>, а <u-code-text>React.PureComponent</u-code-text> реализует его поверхностным сравнением пропсов и состояния</li>

    <li>Если метод <u-code-text>render()</u-code-text> React-компонента всегда рендерит одинаковый результат при одних и тех же пропсах и состояниях, для <u>повышения производительности</u> в некоторых случаях вы можете использовать <u-code-text>React.PureComponent</u-code-text></li>

    <li>Метод <u-text-underline>shouldComponentUpdate()</u-text-underline> базового класса <u-code-text>React.PureComponent</u-code-text> делает только поверхностное сравнение объектов. Если они содержат сложные структуры данных, это может привести к неправильной работе для более глубоких различий (то есть, различий, не выраженных на поверхности структуры). Наследуйте класс <u-code-text>PureComponent</u-code-text> только тогда, когда вы ожидаете использовать простые пропсы и состояние, или используйте <u-code-text>forceUpdate()</u-code-text>, когда знаете, что вложенные структуры данных изменились. Также подумайте об использовании иммутабельных объектов, чтобы упростить процесс сравнения вложенных данных</li>

    <li>Метод <u-code-text>shouldComponentUpdate()</u-code-text> пропускает обновление пропсов для всего поддерева компонентов. Убедитесь, что все дочерние компоненты также являются «чистыми»</li>
</ul>

<!------------------------------------------------------------->
<h4>Как сравнивает элементы PureComponent</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li>Простые типы данных - по значению</li>
    <li>Объекты - по ссылкам. Если ссылка на объект поменялась - перерендер</li>
</ul>
