<h2>Big-O Notation (сложность алгоритмов)</h2>

<u-link-wrapper>
    <a href="https://www.bigocheatsheet.com/" target="_blank">bigocheatsheet.com</a>
    <a href="https://www.youtube.com/watch?v=ZRdOb4yR0kk" target="_blank">[YouTube] Оценка сложности алгоритма</a>
</u-link-wrapper>

<ul class="list-point">
    <li><u-text-define>Big-O Notation</u-text-define> - временная сложность алгоритма</li>
    <li>Показывает <b>верхнюю границу сложности алгоритма</b> зависимости между <b>входными параметрами</b> функции и <b>количеством операций</b>, которые выполнит процессор</li>
    <li>Нельзя оценивать работу алгоритм с точки зрения времени. Один и тот же алгоритм на разных машинах будет выполняться разное время. Алгоритм включает в себя число шагов. Идея Big-O - сколько шагов нужно сделать чтобы алгоритм завершил свое выполнение</li>
    
    <hr>
    <li><u-text-define>Сложность алгоритма (вычислительная сложность)</u-text-define> - функция зависимости объёма работы, которая выполняется некоторым алгоритмом, от размера входных данных</li>
    <li>Объём работы обычно измеряется временем и вычислительными ресурсами. Время определяется количеством элементарных шагов, необходимых для решения задачи. Ресурсы определяются объёмом памяти или места на носителе данных</li>

    <hr>
    <li><u-text-define>Time Complexity</u-text-define> - Временная сложность вычисления</li>
    <li><u-text-define>Space Complexity</u-text-define> - Пространсвенная сложность вычисления</li>
</ul>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Основные обозначения</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
    <li><u-code-text>O(0)</u-code-text> - ничего не происходит</li>

    <hr>
    <li><u-code-text>O(1)</u-code-text> - постоянная величина (константное время)</li>
    <li>Независимо от кол-ва входных данных, требуется 1 операция</li>
    <li><u>Пример</u>: определить чётное или нечетное число</li>

    <hr>
    <li><u-code-text>O(log N)</u-code-text> - логарифмическая сложность (бинарный поиск)</li>
    <li>Алгоритм "разделяй и властвуй": есть телефонный справочник, в котором нужно найти телефон. Открываем справочник посередине, отбрасываем половину и т.д.</li>
    <li>Всегда будет меньше чем половина <u>N</u></li>

    <hr>
    <li><u-code-text>O(N)</u-code-text> - линейная (прямо пропорциональна) сложность</li>
    <li>Зависит от количества передаваемых бит, н-р: 4 элемента - 4 операции</li>
    <li><u>Пример</u>: перебор массива forEach</li>

    <hr>
    <li><u-code-text>O(N * log N)</u-code-text></li>
    <li>Работают большинство алгоритмов сортировки: heap-sort, merge-sort, метод sort JavaScript</li>

    <hr>
    <li><u-code-text>O(N<sup>2</sup>)</u-code-text> - O(N * N) квадратичная сложность</li>
    <li>Вложенные действия - умножение</li>
    <li><u>Пример</u>: цикл в цикле</li>

    <hr>
    <li><u-code-text>O(2<sup>N</sup>)</u-code-text></li>

    <hr>
    <li><u-code-text>O(N!)</u-code-text></li>
</ul>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Верхняя граница (отбрасывание констант)</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<v-code lang="bash" title="">
O(N + N) == O(N)
O(N + 1) == O(N)
O(2N)    == O(N)
</v-code>

<ul class="list-point">
    <li>Мы говорим как будет вести себя алгоритм на бесконечности</li>
    <li>Если алгоритм для n-элементов выполняет n-тактов плюс один такт для вывода информацим на экран, то сложность такого алгоритма всё равно O(N), т.к. бесконечность гораздо больше единицы. Тоже самое касается алгоритмов, которые выполняются за O(2N) или более</li>
    <li>Big-O описывает только скорость роста. Поэтому мы отбрасываем константы при оценке сложности</li>
    <li>Алгоритм, описываемый как O(2N) должен описываться как O(N)</li>
</ul>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Быстродействие</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<!------------------------------------------------------------->
<h4>Рекурсия => Быстродействие: O(N)</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
function pow(x, n) {
    if (n != 1) {
        return x * pow(x, n - 1);
    } else {
        return x;
    }
}
</v-code>

<!------------------------------------------------------------->
<h4>Сложение чисел => Быстродействие: O(1)</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
function sum(a, b) {
    return a + b;
}
</v-code>

<!------------------------------------------------------------->
<h4>Быстродействие: O(N)</h4>
<!------------------------------------------------------------->
<v-two-code type="js;js" comment=";">
<template v-slot:first>
let min = 1;
let max = 10;
for(let i=0; i<=100; i++) {
    if (i < min) min = i;
    if (i > max) max = i;
}
</template>
<template v-slot:last>
let min = 1;
let max = 10;
for(let i=0; i<=100; i++) {
    if (i < min) min = i;
}
for(let i=0; i<=100; i++) {
    if (i > max) max = i;
}
</template>
</v-two-code>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Сложение и умножение</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<v-two-code type="js;js" comment=";">
<template v-slot:first>
// Быстродействие: O(A + B)
let arrA = [1,2,3];
let arrB = [1,2,3];
for(let i=0; i<=arrA; i++) {
    console.log(i);
}
for(let i=0; i<=arrB; i++) {
    console.log(i);
}
// Проход по массивам выполняется последовательно
// Выполнение первого цикла не зависит от выполнения второго
// A - длина массива arrA
// B - длина массива arrB
</template>
<template v-slot:last>
// Быстродействие: O(A * B)
let arrA = [1,2,3];
let arrB = [1,2,3];
for(let a=0; a<=arrA; a++) {
    for(let b=0; b<=arrB; b++) {
        console.log(a, b);
    }
}
// Выполнить что-то N раз, пока делаешь что-то свое
// Цикл по "B" зависим от цикла по "A"
</template>
</v-two-code>
