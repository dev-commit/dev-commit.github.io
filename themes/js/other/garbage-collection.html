<h2>Сборщик мусора</h2>

<ul class="list-point">
    <li><u-text-define>Сборщик мусора (Garbage collection, GC)</u-text-define> - очистка памяти от недостижимых значений в браузере. GC встроенн в интерпретатор, он наблюдает за объектами и время от времени удаляет недостижимые</li>
    <li><u>Примитивы</u> - при присвоении они копируются целиком, ссылок на них не создаётся. Если в переменной была одна строка, а её заменили на другую, то предыдущая удаляется</li>
    <li><u>Объекты</u> требуют специального <u>«сборщика мусора»</u>, который наблюдает за ссылками, т.к. на один объект может быть много ссылок из разных переменных и, при перезаписи одной из них, объект может быть всё ещё доступен из другой</li>
    <li>
        <b>Упрощение для работы с памятью</b>: «значение остаётся в памяти, пока на него есть хотя бы одна ссылка»
        <ul class="list-point">
            <li>Верно - в том плане, что если ссылок на значение нет, то память из-под него очищается</li>
            <li>Неверно - в другую сторону: наличие ссылки не гарантирует, что значение останется в памяти</li>
        </ul>
    </li>
    <li><u>Сборщик мусора</u> идёт от корня по ссылкам и запоминает все найденные объекты. По окончанию - он смотрит, какие объекты в нём отсутствуют и удаляет их</li>
    <li><u>Применение оптимизации интерпретаторами</u> - деление объектов на два вида «старые» и «новые». Для каждого типа выделяется своя область памяти. Каждый объект создаётся в «новой» области и, если прожил достаточно долго, мигрирует в старую. «Новая» область обычно небольшая. Она очищается часто. «Старая» – редко</li>
    <li><u-text-define>Замыкания</u-text-define> <u>LexicalEnvironment</u> внешней функции существует в памяти до тех пор, пока существует хоть одна внутренняя функция, ссылающаяся на него через свойство <u>[[Scope]]</u></li>
    <li><u-text-define>Оптимизация в V8</u-text-define> JS-движки делают оптимизации <u>замыканий</u> по памяти. Они анализируют использование переменных и в случае, когда переменная из замыкания абсолютно точно не используется, удаляют её</li>
    <li><u>clearTimeout / setInterval</u> Сборщик мусора не чистит функции, назначенные в таймерах, пока таймеры актуальны</li>
</ul>

<!------------------------------------------------------------->
<h4>Очистка памяти</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
var user = {
    name: 'Tony'
}
user = null;
</v-code>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Подходы к сборке мусора</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<!------------------------------------------------------------->
<h4>1. Mark and Sweep</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li>Самый простой алгоритм поиска и удаления мусора. Работает только тогда, когда мусор есть, если память наполнена только живыми объектами, Mark and Sweep ничего не делает.</li>
    <li>Основной минус Mark and Sweep в том, что он фрагментирует память. В итоге он может очистить много места, но новый крупный объект все равно не сможет разместиться в оперативной памяти.</li>
</ul>

<!------------------------------------------------------------->
<h4>2. Mark-Sweep-Compact</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li>В алгоритме Mark-Sweep-Compact добавляется как раз та самая необходимая функция дефрагментации. После очистки он смещает все оставшиеся объекты и создает единое пространство свободной памяти.</li>
    <li>С точки зрения результата Mark-Sweep-Compact оптимален. Однако сам процесс смещения объектов довольно ресурсозатратный, к тому же Mark-Sweep-Compact нужно проходить по памяти 2-3 раза, что занимает много лишнего времени.</li>
</ul>

<!------------------------------------------------------------->
<h4>3. SemiSpace</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li>SemiSpace (копирующий сборщик), несколько ускоряет процесс очистки и дефрагментации. SemiSpace находит живые объекты и копирует их в заранее выделенное пространство, а все остальное удаляет.</li>
    <li>Этот алгоритм проще и быстрее Mark-Sweep-Compact, однако требует выделения дополнительного места для копирования живых объектов. К тому же сам процесс копирования также ресурсозатратен.</li>
</ul>

<!------------------------------------------------------------->
<h4>Слабая гипотеза о поколениях</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li>Согласно теории поколений, объекты “умирают молодыми” гораздо чаще, чем “старыми”. Недавно созданный объект станет мусором с гораздо большей вероятностью. Именно поэтому сборщику мусора рационально проверять такие объекты чаще.</li>
</ul>
