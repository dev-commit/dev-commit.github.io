<h2>Итераторы</h2>

<ul class="list-point">
	<li><u-text-define>Итерируемый, перебираемый объект (Iterable)</u-text-define> - объект содержание которого можно перебрать по одному элементу. Пример: массив, строка, коллекция dom-элементов</li>
	<li><u-code>Итератор</u-code> - паттерн проектирования, согласно которому источник элементов прячется от клиента. Клиенту достается специальный объект с помощью которого он может получить элементы по одному. Клиенту не нужно беспокоиться о том как итерировать объект, при этом внутри самого объекта автор может использовать любую структуру для хранения элементов и любой алгоритм для их перебор. Клиент не получает саму структуру и автору не нужно беспокоиться что клиент может ее изменить</li>
	<li><u-code>Объект является итератором</u-code>, если он умеет обращаться к элементам коллекции по одному за раз, при этом отслеживая свое текущее положение внутри этой последовательности</li>
	<li><u-code>Конструкция for..of</u-code> в начале своего выполнения автоматически вызывает Symbol.iterator(), получает итератор и далее вызывает метод next() до получения done: true. Такова внутренняя механика. Внешний код при переборе через for..of видит только значения</li>
	<li><u-code>Интераторы</u-code> используются для реализации генераторов</li>
</ul>

<ul class="list-point">
	<b>Плюсы</b>
	<li>Разные языковые конструкции работают с разными структурами данных по одному принципу в не зависимости от их внутренней реализации</li>
	<li>Можно написать собственную структуру данных, реализовать интерфейс iterable и работать с ней с помощью конструкций for...of, spread-операторов, Array.from и т.д.</li>
</ul>

<h4>Перебор через for...of</h4>
<pre><code class="js">
var arr = ['js', 'python', 'ruby'];
for(var item of arr) {
    console.log(item);
}
</code></pre>

<h4>Перебор через встроенный итератор</h4>
<pre><code class="js">
var arr = ['js', 'python', 'ruby'];
var iterator = arr[<u-code>Symbol.iterator</u-code>]();
console.log(iterator.<u-code>next()</u-code>); // {value: "js", done: false}
console.log(iterator.<u-code>next()</u-code>); // {value: "python", done: false}
console.log(iterator.<u-code>next()</u-code>); // {value: "ruby", done: false}
console.log(iterator.<u-code>next()</u-code>); // {value: undefined, done: true}
</code></pre>

<h4>Перебор через встроенный итератор в цикле</h4>
<pre><code class="js">
var arr = ['js', 'python', 'ruby'];
var iterator = arr[Symbol.iterator]();
var next = iterator.next();
// по похожему алгоритму работает for...of
while (!next.done) {
    console.log(next.value);
    next = iterator.next();
}
</code></pre>

<h4>Создание итератора</h4>
<pre><code class="js">
// итерируемый объект
// числа от 1 до 100
let idGenerator = {
    [Symbol.iterator]() {
        let id = 1;
        return {
            next() {
                let value = id++;
                let done = false;
                return {value, done};
            }
        };
    }
};
// используя цикл
// for(let id of idGenerator) {
//     console.log(id);
//     if (id > 100) {
//         break;
//     }
// }
// доступ к итератору
let num = idGenerator[Symbol.iterator]();
console.log(num.next().value);
</code></pre>
