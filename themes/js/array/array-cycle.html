<h2>Перебор массива</h2>

<ul class="list-point">
	<li><u-code-list>every/some</u-code-list> - для проверки массива</li>
	<li><u-code-list>forEach</u-code-list> - для перебора массива</li>
	<li><u-code-list>filter</u-code-list> - для фильтрации массива</li>
	<li><u-code-list>map</u-code-list> - для трансформации массива в массив</li>
	<li><u-code-list>reduce/reduceRight</u-code-list> - для прохода по массиву с вычислением значения</li>
</ul>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>map</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div class="v-method-wrapper">
    <v-method before="arr." method="map" after="" arg="(callback, thisArg)">
    создаёт новый массив с результатом вызова указанной функции для каждого элемента массива
    </v-method>

	<v-method-arg arg="callback">
	Функция, создающая элемент в новом массиве, принимает три аргумента:<br>
	<u>currentValue</u> - текущий обрабатываемый элемент массива<br>
	<u>index</u> - индекс текущего обрабатываемого элемента в массиве<br>
	<u>array</u> - массив, по которому осуществляется проход<br>
	</v-method-arg>

	<v-method-arg arg="thisArg">
	Необязательный параметр. Значение, используемое в качестве this при вызове функции callback
	</v-method-arg>

	<v-method-return>Новый массив, где каждый элемент является результатом callback функции</v-method-return>
</div>

<pre><code class="js border">
var new_array = arr.map(function callback(currentValue, index, array) { 
	// Возвращает элемент для new_array 
}[, thisArg])
</code></pre>

<pre><code class="js">
var numbers = [1, 4, 9];
var doubles = numbers.map(function(num) {
	return num * 2;
});
// теперь doubles равен [2, 8, 18], а numbers всё ещё равен [1, 4, 9]
</code></pre>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>forEach</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div class="v-method-wrapper">
    <v-method before="arr." method="forEach" after="" arg="(callback, thisArg)">
    Выполняет указанную функцию один раз для каждого элемента в массиве
    </v-method>

	<v-method-arg arg="callback">
	Функция, которая будет вызвана для каждого элемента массива; в нее будет передано три аргумента:<br>
	<u>currentValue</u> - текущий обрабатываемый элемент массива<br>
	<u>index</u> - индекс текущего обрабатываемого элемента в массиве<br>
	<u>array</u> - массив, по которому осуществляется проход<br>
	</v-method-arg>

	<v-method-arg arg="thisArg">
	Необязательный параметр. Значение, используемое в качестве this при вызове функции callback
	</v-method-arg>
</div>

<pre><code class="js border">
arr.forEach(function callback(currentValue, index, array) {
	//your iterator
}[, thisArg]);
</code></pre>

<ul class="list-point">
	<li>Ничего не возвращает, используется только для перебора</li>
</ul>
<pre><code class="js">
var arr = ["Яблоко", "Апельсин", "Груша"];
arr.forEach(function(element, index, arr) {
	console.log( index + ": " + element + " (массив:" + arr + ")" );
});
// "0: Яблоко   (массив:Яблоко,Апельсин,Груша)"
// "1: Апельсин (массив:Яблоко,Апельсин,Груша)"
// "2: Груша    (массив:Яблоко,Апельсин,Груша)"
</code></pre>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>filter</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div class="v-method-wrapper">
    <v-method before="arr." method="filter" after="" arg="(callback, thisArg)">
    создаёт новый массив со всеми элементами, прошедшими проверку, задаваемую в передаваемой функции
    </v-method>

	<v-method-arg arg="callback">
	Функция, которая будет вызвана для каждого элемента массива. Если функция возвращает true, то элемент остаётся в массиве, если false, то удаляется. Три аргумента:<br>
	<u>currentValue</u> - текущий обрабатываемый элемент массива<br>
	<u>index</u> - индекс текущего обрабатываемого элемента в массиве<br>
	<u>array</u> - массив, по которому осуществляется проход<br>
	</v-method-arg>

	<v-method-arg arg="thisArg">
	Необязательный параметр. Значение, используемое в качестве this при вызове функции callback
	</v-method-arg>

	<v-method-return>Новый массив с элементами для которых callback вернёт true. Если ни один элемент не пройдет тест, то будет возвращен пустой массив</v-method-return>
</div>

<ul class="list-point">
	<li>Используется для фильтрации массива через функцию</li>
	<li>Создаёт новый массив, в который войдут только те элементы arr, для которых вызов callback(item, i, arr) возвратит true</li>
</ul>

<pre><code class="js">
// Выбор положительных элементов массива
var arr = [1, -1, 2, -2, 3];
var result = arr.filter(function(number) {
	return number > 0;
});
alert(result); // => 1,2,3
</code></pre>

<pre><code class="js">
// Поиск вхождения подстроки в массив
let arr = ['Tony', 'Jack', 'Nick', 'Tony and Jane'];
let result = arr.filter(item => item.<u-code>includes</u-code>('Tony')); // => ["Tony", "Tony and Jane"]
</code></pre>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>every/some</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div class="v-method-wrapper">
    <v-method before="arr." method="every/some" after="" arg="(callback, thisArg)">
    проверяет, удовлетворяют ли <i><u>все/какие-нибудь</u></i> элементы массива условию, заданному в передаваемой функции
    </v-method>

	<v-method-arg arg="callback">
	Функция проверки каждого элемента, принимает три аргумента:<br>
	<u>currentValue</u> - текущий обрабатываемый элемент массива<br>
	<u>index</u> - индекс текущего обрабатываемого элемента в массиве<br>
	<u>array</u> - массив, по которому осуществляется проход<br>
	</v-method-arg>

	<v-method-arg arg="thisArg">
	Необязательный параметр. Значение, используемое в качестве this при вызове функции callback
	</v-method-arg>

	<v-method-return>true если функция проверки возвращает truthy значение для <i><u>каждого/хотя бы одного</u></i> элемента массива. Иначе, false</v-method-return>
</div>

<ul class="list-point">
	<li>Используется для проверки массива</li>
	<li>Метод «arr.every(callback[, thisArg])» возвращает true, если вызов callback вернёт true для каждого элемента arr</li>
	<li>Метод «arr.some(callback[, thisArg])» возвращает true, если вызов callback вернёт true для какого-нибудь элемента arr</li>
</ul>

<pre><code class="js">
var arr = [1, -1, 2, -2, 3];
function isPositive(number) {
  return number > 0;
}
alert( arr.every(isPositive) ); // false, не все положительные
alert( arr.some(isPositive) );  // true, есть хоть одно положительное
</code></pre>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>reduce/reduceRight</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div class="v-method-wrapper">
    <v-method before="arr." method="reduce/reduceRight" after="" arg="(callback, initialValue)">
    применяет функцию reducer к каждому элементу массива <i><u>(слева-направо)/(справа-налево)</u></i>, возвращая одно результирующее значение
    </v-method>

	<v-method-arg arg="callback">
	Функция, выполняющаяся для каждого элемента массива, принимает четыре аргумента:<br>
	<u>accumulator/previousValue</u> - значение, возвращённое предыдущим выполнением функции callback, либо значение initialValue, если оно предоставлено<br>
	<u>currentValue</u> - текущий обрабатываемый элемент массива<br>
	<u>index</u> - индекс текущего обрабатываемого элемента в массиве<br>
	<u>array</u> - массив, по которому осуществляется проход<br>
	</v-method-arg>

	<v-method-arg arg="initialValue">
	Необязательный параметр. Объект, используемый в качестве первого аргумента при первом вызове функции callback
	</v-method-arg>
</div>

<pre><code class="js border">
array.reduceRight(function(previousValue, currentValue, index, array) {
	// ...
});
</code></pre>

<ul class="list-point">
	<li>Используется для последовательной обработки каждого элемента массива с сохранением промежуточного результата</li>
	<li><b>arr.reduce</b> идёт по массиву слева-направо</li>
	<li><b>arr.reduceRight</b> идёт по массиву справа-налево</li>
</ul>

<pre><code class="js">
<em>arr.reduce(callback[, initialValue])</em>
</code></pre>

<ul class="list-point">
	<b>callback(previousValue, currentItem, index, arr)</b>
	<li><u-code>previousValue</u-code> - последний результат вызова функции, «промежуточный результат»</li>
	<li><u-code>currentItem</u-code> - текущий элемент массива, элементы перебираются по очереди слева-направо</li>
	<li><u-code>index</u-code> - номер текущего элемента</li>
	<li><u-code>arr</u-code> - обрабатываемый массив</li>
</ul>

<ul class="list-point">
	<b>initialValue - начальное значение</b>
	<li>Если есть <u-code>initialValue</u-code>, то на первом вызове значение <u-code>previousValue</u-code> будет равно <u-code>initialValue</u-code></li>
	<li>Если нет <u-code>initialValue</u-code>, то оно равно первому элементу массива, а перебор начинается со второго</li>
</ul>

<pre><code class="js">
// сумма элементов массива
var arr = [1, 2, 3, 4, 5]

// для каждого элемента массива запустить функцию,
// промежуточный результат передавать первым аргументом далее
var result = arr.reduce(function(sum, current) {
  return sum + current
});

alert(result); // 15
</code></pre>
