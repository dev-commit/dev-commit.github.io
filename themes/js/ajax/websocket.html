<h2>WebSocket</h2>

<ul class="list-point">
	<li><u-text-define>Протокол WebSocket</u-text-define> предназначен для решения снятия ограничений обмена данными между браузером и сервером. Кросс-доменный, универсальный, безопасный. Позволяет пересылать любые данные, на любой домен, безопасно и почти без лишнего сетевого трафика. Позволяет создать <u>постоянное соединение</u> для отображения в реальном времени (н-р: сервис биржи и т.д.)</li>
	<li>Сервер должен поддерживать протокол WebSocket</li>
	<li>Протокол WebSocket работает над TCP</li>
	<li>Создать подобный XMLHttpRequest-запрос (подделать WebSocket) невозможно: указанные выше заголовки запрещены к установке методом setRequestHeader</li>
	<li>Сервер может проанализировать эти заголовки и решить, разрешает ли он WebSocket с данного домена Origin</li>
</ul>

<h4>Открыть соединеиние</h4>
<pre><code class="js">
// создание объекта WebSocket с указанием протокола ws
var socket = new WebSocket("<u-code>ws</u-code>://javascript.ru/ws");  // протокол "ws" над "http"
var socket = new WebSocket("<u-code>wss</u-code>://javascript.ru/ws"); // протокол "wss" над "https"
</code></pre>

<h4>Коллбэки у socket</h4>
<p>Один получение данных и три при изменениях в состоянии соединения</p>
<pre><code class="js">
<u-code>socket.onopen</u-code> = function() {
	alert("Соединение установлено.");
};
<u-code>socket.onclose</u-code> = function(event) {
	if (event.wasClean) {
		alert('Соединение закрыто чисто');
	} else {
		alert('Обрыв соединения'); // например, "убит" процесс сервера
	}
	alert('Код: ' + event.code + ' причина: ' + event.reason);
};
<u-code>socket.onmessage</u-code> = function(event) {
	alert("Получены данные " + event.data);
};
<u-code>socket.onerror</u-code> = function(error) {
	alert("Ошибка " + error.message);
};
</code></pre>

<h4>Посылка данных</h4>
<pre><code class="js">
socket.send("Привет");              // строка
socket.send(form.elements[0].file); // файл из формы
</code></pre>
