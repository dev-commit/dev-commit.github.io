<h2>WebRTC</h2>

<u-link-wrapper>
    <a href="https://www.youtube.com/watch?v=R0wcvVYst-M" target="_blank">YouTube: WebRTC под капотом</a>
</u-link-wrapper>

<ul class="list-point">
    <li><u-text-define>WebRTC</u-text-define> (real-time communications - коммуникации в реальном времени) - проект, предназначенный для организации передачи потоковых данных между браузерами или другими поддерживающими его приложениями по технологии точка-точка</li>
    <li>Технология WebRTC делает возможной видеосвязь через окно браузера, так что для присоединения к звонку необходимо только перейти по ссылке на соответствующую веб-страницу</li>
    <li>В WebRTC используются два аудиокодека, G.711 и Opus, а также видеокодеки VP8 и H.264</li>
    <li>Хотя WebRTC изначально рассчитано на соединения типа точка-точка и peer-to-peer, существует несколько готовых реализаций WebRTC-серверов, организующих сложные групповые конференции между разными браузерами. Такие серверы также обеспечивают присоединение к связи с браузерами сторонних устройств - IP-камер, использующих протокол RTSP/RTP, а также SIP и H.323-терминалов</li>
    <hr>
    <li>Просмотр в Chrome <u-code-text>chrome://webrtc-internals/</u-code-text></li>
</ul>

<!------------------------------------------------------------->
<h4>Преимущества</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li>Проведение конференции в браузере значительно упрощает процесс проведения конференции — пользователю не нужно устанавливать для этого отдельные приложения</li>
    <li>Используемые кодеки обеспечивают хорошее качество связи</li>
    <li>Возможность реализации любых элементов интерфейса средствами HTML5 и JavaScript</li>
    <li>Открытый исходный код даёт больше возможностей для использования</li>
</ul>

<!------------------------------------------------------------->
<h4>Недостатки</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li>Технология определяет только общий стандарт передачи данных (видео и звука), но отдельные решения разных браузеров относительно адресации абонентов и прочих управляющих процессов не совместимы между собой. Поэтому даже звонки между парой различных браузеров представляют отдельную сложность</li>
    <li>Обеспечение групповых конференций требует дополнительных разработок поверх WebRTC</li>
</ul>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>7 шагов</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
    <li><u>TCP</u> - WebSocket</li>
    <li><u>UDP</u> - WebRTC (+Media, +P2P)</li>
</ul>

<!------------------------------------------------------------->
<h4>1. Захват камеры</h4>
<!------------------------------------------------------------->
<ol class="list-num">
    <li>Получаем объект <u-code-text>MediaStream</u-code-text> из <u-code-text>navigator.getUserMedia</u-code-text></li>
    <li>Размер чистого потока:</li>
<v-code lang="js" title="">
○ изображение 640x480, 32bit: 1.2mb
○ 30 кадров, 1 секунда: 36mb
○ битрейт: 288mbps
</v-code>
</ol>

<!------------------------------------------------------------->
<h4>2. Кодирование - сжаие аудио и видео потоков</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
● JPEG, 640x480
    ○ 1.2mb -> 123kb
    ○ 288mbps -> 28mbps
● VP9, 1280x720 — 1.5mbps
● Диффы, keyframe, interframe
</v-code>

<!------------------------------------------------------------->
<h4>3. Запаковка в RTP</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li>Порядок - пакеты могут приходить в разном порядке</li>
    <li>Время - хранит информацию про время чтобы синхронизировать аудио и видео дорожку</li>
    <li>Треки</li>
    <li>Оверхед: ~5% (62 / 1204)</li>
    <li><u>RTCP (RPT Control Protocol)</u> - обмен информацией про потярянные пакеты, статистика их получения и т.д. Расширение основного протокола</li>
</ul>

<!------------------------------------------------------------->
<h4>4. Передача по сети через UDP</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
● Главный плюс UDP:
    ○ минимальный интервал между пакетами
● Минусы UDP
    ○ пакеты теряются
    ○ пакеты приходят поздно
    ○ пакеты приходят в другом порядке
</v-code>

<!------------------------------------------------------------->
<h4>5. Распаковка RTP</h4>
<!------------------------------------------------------------->
<ol class="list-num">
    <li>Восстанавливаем порядок</li>
    <li>Достаем видео-трафик</li>
    <li>Передаем в декодер</li>
</ol>

<!------------------------------------------------------------->
<h4>6. Декодирование</h4>
<!------------------------------------------------------------->
<ol class="list-num">
    <li>Передаем данные в правильном порядке</li>
    <li>На выходе - чистый видео-поток - <u-code-text>MediaStream</u-code-text></li>
</ol>

<!------------------------------------------------------------->
<h4>7. Отрисовка на экране &lt;video&gt;</h4>
<!------------------------------------------------------------->
<ol class="list-num">
    <li>Прикрепляем поток к элементу и получаем картинку</li>
</ol>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Потери пакетов</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
    <li>Остаются в стенах дома - Random loss или Lossy network</li>
    <li>Дропаются по ошибке: баги в ОС или сетевом оборудовании</li>
    <li>Дропаются из-за перегрузки сети - Network congestion</li>
</ul>

<!------------------------------------------------------------->
<h4>Решение №1: Jitter buffer: рендерим позже, даем себе время на повторный запрос</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
● Минус: дополнительная постоянная задержка
● Плюсы:
    ○ Есть время запросить недостающий пакет
    ○ При массовой потере, больше времени на запрос keyframe
</v-code>

<!------------------------------------------------------------->
<h4>Решение №2: Уменьшаем битрейт, деградируем качество</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
● Битрейт = FPS * качество * разрешение
● Минусы:
    ○ Хуже качество (временно)
    ○ Не поможет с random loss
● Плюс: поможет с network congestion
</v-code>

<!------------------------------------------------------------->
<h4>Решение №3: Forward Error Correction</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
● Умное дублирование данных на уровне кодека
● Минус: выше битрейт — усугубляет network congestion
● Плюс: выше шанс доставки контента с первого раза
</v-code>

<!------------------------------------------------------------->
<h4>Решение №4: Сетевой тюнинг</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
● Лучшие сетевые маршруты
● Настройка серверов и маршрутизаторов
</v-code>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Пример использования</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div class="v-method-wrapper">
    <v-method before="navigator." method="getUserMedia" after="" arg="(constraints)">
    Получение доступа к устройствам
    </v-method>

	<v-method-arg arg="constraints">объект, содераший вид устройства (аудио, видео или оба)</v-method-arg>

	<v-method-return>Возвращает Promise, который, в случае согласия пользователя, разрешается MediaStream объектом. Если пользователь отказывает в разрешении, или медиа устройсто не доступно, тогда промис отменяется с объектами типа NotAllowedError или NotFoundError соответственно</v-method-return>
</div>

<v-code lang="js" title="">
navigator.mediaDevices.getUserMedia(constraints)
	.then(stream => {
		// используем поток
	})
	.catch(err => {
		// обработка ошибки
	})
</v-code>
