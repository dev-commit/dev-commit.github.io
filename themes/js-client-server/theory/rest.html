<h2>REST API</h2>

<ul class="list-point">
    <li><u-text-define>REST</u-text-define> (REpresentational State Transfer - «передача состояния представления») - <u>архитектурный стиль</u> взаимодействия компонентов <u>распределённого</u> приложения в сети. Задает общие принципы организации взаимодействия приложения/сайта с сервером посредством протокола HTTP</li>
    <li>Каждый запрос (REST-запрос) клиента к серверу содержит в себе исчерпывающую информацию о желаемом ответе сервера (желаемом представительном состоянии), и сервер не обязан сохранять информацию о состоянии клиента («клиентской сессии»). Сервер не запоминает состояние пользователя между запросами - в каждом запросе передаётся информация, идентифицирующая пользователя (например, token, полученный через OAuth-авторизацию) и все параметры, необходимые для выполнения операции</li>
    <li>Для веб-служб, построенных с учётом REST (то есть не нарушающих накладываемых им ограничений), применяют термин <u>RESTful</u></li>
</ul>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Запросы</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
    <li><u-code-list>GET</u-code-list> <u-code-text>/rest/users</u-code-text> - получить представление ресурса (получить информацию о всех пользователях)</li>
    <li><u-code-list>GET</u-code-list> <u-code-text>/rest/users/125</u-code-text> - (получить информацию о пользователе с id=125)</li>
    <li><u-code-list>POST</u-code-list> <u-code-text>/rest/users</u-code-text> - создать новый ресурс (добавить нового пользователя)</li>
    <li><u-code-list>PUT</u-code-list> <u-code-text>/rest/users/125</u-code-text> - обновить / изменить существующий ресурс (или создать новый ресурс) (изменить информацию о пользователе с id=125)</li>
    <li><u-code-list>DELETE</u-code-list> <u-code-text>/rest/users/125</u-code-text> - удалить существующий ресурс (удалить пользователя с id=125)</li>
    <li><u-code-list>HEAD</u-code-list> - извлечь только метаданные представления (то есть представление метаданных)</li>
    <li><u-code-list>OPTIONS</u-code-list> - проверить, какие методы HTTP поддерживает конкретный ресурс</li>
</ul>

<!------------------------------------------------------------->
<h4>Отличие GET от POST</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li>GET может закешироваться браузерами. POST не кешируется</li>
</ul>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Отличия REST от SOAP</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<v-code lang="bash" title="">
REST архитектурный стиль               || SOAP протокол передачи данных на базе http
Кешируемый                             || Не кешируемый
Взаимодействие с JSON, XML, Text       || Формат XML
Работает с прикладным протоколом HTTP  || С любым прикладным протоколом
Передача без состояний                 || Есть состояния
</v-code>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Требования к архитектуре REST</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
    <li><u>1. Модель клиент-сервер</u> - позволяет отдельным частям развиваться независимо друг от друга</li>
    <li><u>2. Отсутствие состояния</u>. Протокол взаимодействия между клиентом и сервером требует соблюдения следующего условия: в период между запросами клиента никакая информация о состоянии клиента на сервере не хранится (Stateless Protocol). Все запросы от клиента должны быть составлены так, чтобы сервер получил всю необходимую информацию для выполнения запроса. Состояние сессии при этом сохраняется на стороне клиента. Информация о состоянии сессии может быть передана сервером какому-либо другому сервису (например, в службу базы данных) для поддержания устойчивого состояния, например, на период установления аутентификации. Клиент инициирует отправку запросов, когда он готов (возникает необходимость) перейти в новое состояние. Во время обработки клиентских запросов считается, что клиент находится в переходном состоянии. Каждое отдельное состояние приложения представлено связями, которые могут быть задействованы при следующем обращении клиента</li>
    <li><u>3. Кэширование</u> ответов сервера. Ответы сервера, в свою очередь, должны иметь явное или неявное обозначение как кэшируемые или некэшируемые с целью предотвращения получения клиентами устаревших или неверных данных в ответ на последующие запросы</li>
    <li><u>4. Единообразие интерфейса</u>. Унифицированные интерфейсы позволяют каждому из сервисов развиваться независимо. К унифицированным интерфейсам предъявляются следующие четыре ограничительных условия</li>
    <ul class="list-point">
        <li><u>Идентификация ресурсов</u>. Все ресурсы идентифицируются в запросах, например, с использованием URI в интернет-системах. Ресурсы концептуально отделены от представлений, которые возвращаются клиентам. Например, сервер может отсылать данные из базы данных в виде HTML, XML или JSON, ни один из которых не является типом хранения внутри сервера</li>
        <li><u>Манипуляция ресурсами через представление</u>. Если клиент хранит представление ресурса, включая метаданные — он обладает достаточной информацией для модификации или удаления ресурса</li>
        <li><u>«Самоописываемые» сообщения</u>. Каждое сообщение содержит достаточно информации, чтобы понять, каким образом его обрабатывать</li>
        <li><u>Гипермедиа как средство изменения состояния приложения (HATEOAS)</u>. Клиенты изменяют состояние системы только через действия, которые динамически определены в гипермедиа на сервере (к примеру, гиперссылки в гипертексте). Исключая простые точки входа в приложение, клиент не может предположить, что доступна какая-то операция над каким-то ресурсом, если не получил информацию об этом в предыдущих запросах к серверу.</li>
    </ul>

    <li><u>5. Слои</u>. Клиент обычно не способен точно определить, взаимодействует он напрямую с сервером или же с промежуточным узлом, в связи с иерархической структурой сетей (подразумевая, что такая структура образует слои). Применение промежуточных серверов способно повысить масштабируемость за счёт балансировки нагрузки и распределённого кэширования. Промежуточные узлы также могут подчиняться политике безопасности с целью обеспечения конфиденциальности информации</li>
    <li><u>6. Код по требованию</u> (необязательное ограничение). REST может позволить расширить функциональность клиента за счёт загрузки кода с сервера в виде апплетов или сценариев</li>
</ul>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Преимущества</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
    <li>Надёжность (за счёт отсутствия необходимости сохранять информацию о состоянии клиента, которая может быть утеряна)</li>
    <li>Производительность (за счёт использования кэша)</li>
    <li>Масштабируемость</li>
    <li>Прозрачность системы взаимодействия (особенно необходимая для приложений обслуживания сети)</li>
    <li>Простота интерфейсов</li>
    <li>Портативность компонентов</li>
    <li>Лёгкость внесения изменений</li>
    <li>Способность эволюционировать, приспосабливаясь к новым требованиям (на примере Всемирной паутины)</li>
</ul>

<ul class="list-point">
    <li><u-text-define>API</u-text-define> (Application Programming Interface, программный интерфейс приложения) - описание способов (набор классов, процедур, функций, структур или констант), которыми одна компьютерная программа может взаимодействовать с другой программой</li>
    <li>API определяет функциональность, которую предоставляет программа (модуль, библиотека), при этом API позволяет абстрагироваться от того, как именно эта функциональность реализована</li>
    <li>Программные компоненты взаимодействуют друг с другом посредством API. При этом обычно компоненты образуют иерархию — высокоуровневые компоненты используют API низкоуровневых компонентов, а те, в свою очередь, используют API ещё более низкоуровневых компонентов</li>
    <li>API библиотеки функций и классов включает в себя описание <u>сигнатур функций</u> и <u>семантики функций</u></li>
    <ul class="list-point">
        <li><u>Сигнатура функции</u> - часть общего объявления функции, позволяющая средствам трансляции идентифицировать функцию среди других</li>
        <li><u>Семантика функции</u> - описание того, что данная функция делает. Семантика функции включает в себя описание того, что является результатом вычисления функции, как и от чего этот результат зависит</li>
    </ul>
</ul>
