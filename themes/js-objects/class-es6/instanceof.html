<h2>Проверка класса: "instanceof"</h2>

<ul class="list-point">
	<li><u-text-define>instanceof</u-text-define> позволяет проверить, какому классу принадлежит объект, с учетом прототипного наследования</li>
	<li>Оператор obj instanceof Func проверяет что obj является результатом вызова new Func. Он учитывает цепочку <u>__proto__</u>, поэтому наследование поддерживается</li>
	<li>Оператор <u>instanceof</u> не сможет проверить тип значения, если объект создан в одном окне/фрейме, а проверяется в другом, т.к. в каждом окне своя иерархия объектов. Для точной проверки типов встроенных объектов можно использовать свойство <u>[[Class]]</u></li>
	<li>Оператор <u>instanceof</u> особенно востребован в случаях, когда мы работаем с иерархиями классов. Это наилучший способ проверить принадлежность тому или иному классу с учётом наследования</li>

	<b class="margin-top">Алгоритм проверки obj instanceof Constructor</b>
	<li>1. Получить obj.__proto__</li>
	<li>2. Сравнить obj.__proto__ с Constructor.prototype</li>
	<li>3. Если не совпадает, тогда заменить obj на obj.__proto__ и повторить проверку на шаге 2 до тех пор, пока либо не найдется совпадение (результат true), либо цепочка прототипов не закончится (результат false)</li>
</ul>

<pre><code class="js">
function ClassParent() {}
var parent = new ClassParent();
var a = parent instanceof ClassParent; // true
// parent.__proto__ == ClassParent.prototype;
</code></pre>

<pre><code class="js">
// массив arr принадлежит классу Array
// но также и является объектом Object
var arr = [];
var a = arr instanceof Array; // true
var a = arr instanceof Object; // true
// arr.__proto__.__proto__ == Object.prototype
</code></pre>

<pre><code class="js">
// сама функция-конструктор не участвует в процессе проверки, важна только цепочка прототипов для проверяемого объекта
// это может приводить к ошибкам в проверке при изменении prototype
function Rabbit() {}
var rabbit = new Rabbit();
Rabbit.prototype = {}; // изменили prototype...
var a = rabbit instanceof Rabbit; // false
</code></pre>
