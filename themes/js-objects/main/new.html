<h2>Конструктор new</h2>

<ul class="list-point">
    <li><u-code-text>new</u-code-text> недоступно у стрелочной функции</li>
</ul>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Функция, запущенная через new</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ol class="list-num">

<!-- 1 -->
<li>Создаётся новый пустой объект через <u-code-text>Object.create</u-code-text>, который является <u-code-text>this</u-code-text></li>
<pre><code class="js">
var instance = {};
</code></pre>

<!-- 2 -->
<li>Устанавливает <u-code-text>__proto__</u-code-text> этому объекту в которое записывается ссылка из <u-code-text>prototype</u-code-text> функции-конструктора <i>(устанавливается прототип)</i></li>
<pre><code class="js">
instance.__proto__ = FnClass.prototype;
</code></pre>

<!-- 3 -->
<li>
	<u-code-text>this</u-code-text> получает ссылку на этот объект. Модифицируется <u-code-text>this</u-code-text> (т.е. этот новый объект) и инициализируются методы и свойства. <br>
	<i>Применяет функцию-класс к нашему новосозданному объекту (т.е. исполняет функцию FnClass, передавая ей instance в качестве this и аргументы в виде массива arguments)</i>
</li>
<pre><code class="js">
constructorReturns = FnClass.apply(instance, arguments);
</code></pre>

<!-- 4 -->
<li>
	Неявно возвращается <u-code-text>this</u-code-text> без вызова <u-code-text>return</u-code-text><br>
	<i>Возвращает экземпляр функции-класса, но если FnClass нам вернул обьект, тогда его</i>
</li>
<pre><code class="js">
return constructorReturns instanceof Object ? constructorReturns : instance;
</code></pre>

</ol>

