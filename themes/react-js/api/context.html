<h2>Контекст</h2>

<ul class="list-point">
    <li><u-text-define>Контекст</u-text-define> - позволяет передавать данные через дерево компонентов без необходимости передавать пропсы на промежуточных уровнях</li>
    <li>Контекст разработан для передачи данных, которые можно назвать «глобальными» для всего дерева React-компонентов</li>
    <li>В типичном React-приложении данные передаются сверху вниз (от родителя к дочернему компоненту) с помощью пропсов. Однако, этот способ может быть чересчур громоздким для некоторых типов пропсов (например, выбранный язык, UI-тема), которые необходимо передавать во многие компоненты в приложении. Контекст предоставляет способ делиться такими данными между компонентами без необходимости явно передавать пропсы через каждый уровень дерева</li>
    <li>Усложняет переиспользование компонентов</li>
</ul>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>API</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<!------------------------------------------------------------->
<h4>1. React.createContext</h4>
<!------------------------------------------------------------->
<pre><code class="js none">
const MyContext = React.createContext(defaultValue);
</code></pre>

<ul class="list-point">
    <li><u-menu-code>React.createContext</u-menu-code> - создание объекта Context. Когда React рендерит компонент, который подписан на этот объект, React получит текущее значение контекста из ближайшего подходящего <u>Provider</u> выше в дереве компонентов</li>
    <ul class="list-point">
        <li><u-code-text>defaultValue</u-code-text> - аргумент используется только в том случае, если для компонента нет подходящего <u>Provider</u> выше в дереве. Если передать <u>undefined</u> как значение <u>Provider</u>, компоненты, использующие этот контекст, не будут использовать <u>defaultValue</u></li>
    </ul>
</ul>

<!------------------------------------------------------------->
<h4>2. Context.Provider</h4>
<!------------------------------------------------------------->
<pre><code class="js none">
&lt;MyContext.Provider value={/* некоторое значение */}&gt;
</code></pre>

<ul class="list-point">
    <li><u-menu-code>Context.Provider</u-menu-code> - компонент используется для передачи текущего значения по дереву. Любой дочерний компонент может использовать этот контекст</li>
    <li>Один Provider может быть связан с несколькими компонентами, потребляющими контекст. Так же Provider компоненты могут быть вложены друг в друга, переопределяя значение контекста глубже в дереве</li>
    <li>Все потребители, которые являются потомками <u>Provider</u>, будут повторно рендериться, как только проп <u>value</u> у <u>Provider</u> изменится. Потребитель перерендерится при изменении контекста, даже если его родитель, не использующий данный контекст, блокирует повторные рендеры с помощью <u>shouldComponentUpdate</u></li>
    <ul class="list-point">
        <li><u-code-text>value</u-code-text> - значение контекста. Проп <u>value</u> будут передан во все компоненты, использующие этот контекст и являющиеся потомками этого <u>Provider</u> компонента</li>
    </ul>
</ul>

<!------------------------------------------------------------->
<h4>3. Class.contextType</h4>
<!------------------------------------------------------------->
<pre><code class="js none">
class MyClass extends React.Component {
	static contextType = MyContext;
	render() {
		{this.context}
	}
}
</code></pre>

<ul class="list-point">
    <li><u-menu-code>Class.contextType</u-menu-code> - определяет <u>contextType</u>, чтобы получить значение контекста. React найдёт (выше по дереву) ближайший <u>Provider-компонент</u>, предоставляющий этот контекст, и использует его значение</li>
    <li>В свойство класса <u>contextType</u> может быть назначен объект контекста, созданный с помощью <u>React.createContext()</u>. Это позволяет использовать ближайшее и актуальное значение указанного контекста при помощи <u>this.context</u>. В этом случае вы получаете доступ к контексту, как во всех методах жизненного цикла, так и в рендер методе</li>
    <li>Можно подписаться только на один контекст, используя этот API</li>
</ul>

<!------------------------------------------------------------->
<h4>4. Context.Consumer</h4>
<!------------------------------------------------------------->
<pre><code class="html none">
&lt;MyContext.Consumer&gt;
	{value =&gt; /* отрендерить что-то, используя значение контекста */}
&lt;/MyContext.Consumer&gt;
</code></pre>

<ul class="list-point">
    <li><u-menu-code>MyContext.Consumer</u-menu-code> - React-компонент, который подписывается на изменения контекста. В свою очередь, это позволяет вам подписаться на контекст в функциональном компоненте</li>
    <li>Consumer принимает функцию в качестве дочернего компонента. Эта функция принимает текущее значение контекста и возвращает React-компонент. Передаваемый аргумент <u>value</u> будет равен ближайшему (вверх по дереву) значению этого контекста, а именно пропу <u>value Provider</u> компонента. Если такого <u>Provider</u> компонента не существует, аргумент <u>value</u> будет равен значению <u>defaultValue</u>, которое было передано в <u>createContext()</u></li>
</ul>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Пример</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<pre><code class="js">
import React, { Component } from 'react';

const ThemeContext = <u-code>React.createContext</u-code>('light');

export default class App extends Component {
	render() {
		return (
			<u-code>&lt;ThemeContext.Provider value="dark"&gt;</u-code>
				&lt;Toolbar /&gt;
			<u-code>&lt;/ThemeContext.Provider&gt;</u-code>
		);
	}
}
</code></pre>

<pre><code class="js">
// Компонент, который находится в середине,
// теперь не должен явно передавать UI-тему вниз
class Toolbar extends Component {
	render() {
		return (
			&lt;div&gt;
				&lt;ThemedButton /&gt;
			&lt;/div&gt;
		);
	}
}
</code></pre>

<pre><code class="js">
// 1. Используя contextType
class ThemedButton extends Component {
	<u-code>static contextType = ThemeContext;</u-code>
	render() {
		return (
			&lt;div&gt;
				<u-code>{this.context}</u-code>
			&lt;/div&gt;
		);
	}
}

// 2. Используя Context.Consumer
class ThemedButton extends Component {
	render() {
		return (
			&lt;div&gt;
				<u-code-wrapper>
				&lt;ThemeContext.Consumer&gt;
					{value =&gt; &lt;h2&gt;{value}&lt;/h2&gt;}
				&lt;/ThemeContext.Consumer&gt;
				</u-code-wrapper>
			&lt;/div&gt;
		);
	}
}
</code></pre>



