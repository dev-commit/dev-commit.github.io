<h2>componentDidCatch()</h2>

<div class="v-method-wrapper">
    <v-method before="" method="componentDidCatch" after="" arg="(error, info)">
    <u>ОБРАБОТКА ОШИБОК</u> если произошла ошибка в процессе рендеринга, методе жизненного цикла или конструкторе любого дочернего компонента
    </v-method>

	<v-method-arg arg="error">перехваченная ошибка</v-method-arg>
	<v-method-arg arg="info">объект с ключом <u>componentStack</u>, содержащий информацию о компоненте, в котором произошла ошибка</v-method-arg>
</div>

<ul class="list-point">
	<li>Компоненты, которые содержат componentDidCatch называются <u>Error Boundary</u> - ловят ошибки ниже себя по иерархии и ограничивают область действия этих ошибок</li>
	<li>Если в componentDidCatch произойдет ошибка, она в componentDidCatch выше по иерархиии</li>
	<li><u>Не будут обрабатываться</u> асинхронные ошибки, ошибки из eventListeners</li>
	<li>Метод вызывается во время этапа «фиксации», поэтому здесь можно использовать побочные эффекты. Метод можно использовать для <u>логирования ошибок</u></li>
	<li>В случае ошибки можно рендерить запасной интерфейс с помощью <u-code-text>getDerivedStateFromError()</u-code-text></li>
</ul>

<v-code lang="js" title="">
import React, { Component } from 'react';

export default class App extends Component {
	<u-code>componentDidCatch</u-code>(error, info) {
		// Можно также сохранить информацию об ошибке в соответствующую службу журнала ошибок
		logErrorToMyService(error, info);
	}
	render() {
		//
	}
}
</v-code>
