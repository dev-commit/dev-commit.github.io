<h2>Информация</h2>

<u-link-wrapper>
    <a href="https://react-redux.js.org/introduction/quick-start" target="_blank">Документация</a>
    <a href="https://maxfarseer.gitbooks.io/redux-course-ru-v2/" target="_blank">Максим Пацианский "React Redux" (книга)</a>
</u-link-wrapper>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>NPM</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<v-pre-npm>
npm i --save <u-code-npm>redux</u-code-npm>
npm i --save <u-code-npm>react-redux</u-code-npm>
</v-pre-npm>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Redux</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
    <li><u-text-define>Redux</u-text-define> - это инструмент управления состоянием приложения (предсказуемый контейнер состояния для JS приложений). Он подходит для одностраничных приложений, в которых управление состоянием может со временем становиться сложным. Redux не связан с каким-то определенным фреймворком, и хотя разрабатывался для React, может использоваться с Angular или jQuery</li>

    <li>В React «однонаправленный поток данных» - поток данных проходит в одном направлении, от родителя к ребенку. При этом не очевидно, как два компонента, не связанные отношением родитель-ребенок, будут взаимодействовать между собой</li>

    <li>Redux предлагает хранить все состояние приложения в одном месте, называемом <u>«store»</u> («хранилище»). Компоненты «отправляют» изменение состояния в хранилище, а не напрямую другим компонентам. Компоненты, которые должны быть в курсе этих изменений, «подписываются» на хранилище</li>
</ul>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Элементы</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
    <li><u-text-define>1. View</u-text-define> - компонент</li>

    <hr>
    <li><u-text-define>2. Store</u-text-define> - помещаются все данные приложения. Store иммутабельный: мы можем создавать всегда только новую копию данных, а не менять старое состояние store. ТОЛЬКО ОДИН объект Store. Store, "объединяет" Reducer и Actions</li>
    
    <hr>
    <li><u-text-define>3. Actions</u-text-define> - объект. Описывает факт, что что-то произошло, но не указывает, как состояние приложения должно измениться в ответ (Reducer). Изменение состоние происходит с помощью действий</li>

    <ul class="list-point">
        <li><u-menu-code>Actions</u-menu-code> </li>
        <ul class="list-point">
            <li><u-code-text>&#9776; type</u-code-text> - обязательное поле</li>
            <li><u-code-text>payload</u-code-text> - свойство в которое помещаются все данные, которые передаются вместе с действием</li>
        </ul>
    </ul>
    
    <li><u-text-underline>ActionsCreator</u-text-underline> - функция для вызова Action</li>

    <hr>
    <li><u-text-define>4. Reducer</u-text-define> - (преобразователь) - чистая функция, которая берет на вход <u>предыдущее состояние</u> и <u>action</u> и возвращает новое состояние. Не модифицирует данные, а всегда возвращает новые данные. Указывает, как состояние приложения должно измениться в ответ на Action</li>
    <li>Мы не мутировали наш state, мы создали новый state. В редьюсере, мы всегда должны возвращать новый объект, а не измененный предыдущий</li>
    <li>Объект, который мы возвращаем в редьюсере, далее с помощью функции <u-code-text>connect</u-code-text>, превратится в свойства для компонентов. Благодаря этому, внутри компонента <u-code-text>&lt;Component /&gt;</u-code-text>, мы сможем получить доступ к свойству <u-code-text>this.props.name_prop</u-code-text></li>
    
    <li><u-text-underline>Reducer Composition</u-text-underline> - фундаментальный шаблон построения redux приложений: мы разбиваем наше глобальное состояние на кусочки, за каждый кусочек отвечает свой <u-code-text>reducer</u-code-text>. Кусочки объединяются в <u-code-text>rootReducer</u-code-text> Корневом Редьюсере</li>


</ul>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Однонаправленный поток данных</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ol class="list-num">
    <li>Приложение получило начальное состояние (<u-code-text>initial state</u-code-text>)</li>
    <li>Пользователь нажав кнопку, отправил действие (<u-code-text>dispatch action</u-code-text>)</li>
    <li>Соответсвующий редьюсер обновил часть приложения, в согласии с тем, что узнал от действия</li>
    <li>Приложение изменилось и теперь отражает новое состояние</li>
    <li>... (все повторяется по кругу, с пункта 2)</li>
</ol>
