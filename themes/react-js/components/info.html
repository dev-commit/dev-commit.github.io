<h2>Компоненты</h2>

<ul class="list-point">
	<li><u-text-define>Компоненты</u-text-define> - позволяют разбить интерфейс на независимые части, про которые легко думать в отдельности. Их можно складывать вместе и использовать несколько раз</li>
	<li>Во многом компоненты ведут себя как обычные функции JavaScript. Они принимают произвольные входные данные («<u>пропсы</u>») и возвращают React-элементы, описывающие, что мы хотим увидеть на экране</li>
	<li>Принцип единственной ответственности: каждый компонент по-хорошему должен заниматься какой-то одной задачей</li>
    <li>Всегда называйте компоненты с заглавной буквы. Если компонент начинается с маленькой буквы, React принимает его за DOM-тег. Например, <u-code-text>&lt;div /&gt;</u-code-text> это div-тег из HTML, а <u-code-text>&lt;Welcome /&gt;</u-code-text> это уже наш компонент <u-code-text>Welcome</u-code-text>, который должен быть в области видимости</li>
</ul>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Виды компонентов</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<v-two><template v-slot:first>
<ul class="list-point">
	<li><u-text-define>Stateful Component</u-text-define> (компоненты с состоянием) - делают что-то с данными и работают со стором</li>
	<ul class="list-point">
		<li><b>Название: </b>Умные компоненты</li>
		<li><b>Директория: </b>containers</li>
		<li><b>Реализация: </b>классы</li>
		<li><b>Наличие state: </b>да</li>
	</ul>
</ul>
</template><template v-slot:last>
<ul class="list-point">
	<li><u-text-define>Stateless Functional Components</u-text-define> (функциональные компоненты без состояния) - получают данные и их отрисовывают</li>
	<ul class="list-point">
		<li><b>Название: </b>Глупые компоненты</li>
		<li><b>Директория: </b>components</li>
		<li><b>Реализация: </b>функции</li>
		<li><b>Наличие state: </b>нет</li>
	</ul>
</ul>
</template></v-two>

<img src="/img/react/components-type.png" width="650px">

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Функциональные и классовые компоненты</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<v-two-code type="js;js" comment="Функциональный;Классовый">
<template v-slot:first>
function Welcome(props) {
	return &lt;h1&gt;Привет, {props.name}&lt;/h1&gt;;
}
// она получает данные через props
// возвращает React-элемент
</template>
<template v-slot:last>
class Welcome extends React.Component {
	render() {
		return &lt;h1&gt;Привет, {this.props.name}&lt;/h1&gt;;
	}
}
</template>
</v-two-code>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Импорт</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<pre><code class="js">
<u-code>import</u-code> Header from '../Header';

<u-code>export default</u-code> class App extends React.Component { ... }

class App extends React.Component { ... }
<u-code>export default</u-code> App;
</code></pre>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Классовые компоненты на jsx и js</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div class="container-flex"><div class="container-half"><pre><code class="js"><u-code-title>jsx</u-code-title>
class App extends React.Component {
	render() {
		return &lt;button&gt;Кнопка&lt;/button&gt;;
	}
}
ReactDOM.render(
	&lt;App /&gt;,
	document.getElementById('root')
);
</code></pre></div><div class="container-half"><pre><code class="js"><u-code-title>js</u-code-title>
const e = React.<u-code>createElement</u-code>;
class App extends React.Component {
	render() {
		return <u-code>e</u-code>('button', null, 'Кнопка');
	}
}
ReactDOM.render(
	<u-code>e</u-code>(App),
	document.getElementById('root')
);
</code></pre></div></div>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Композиция компонентов</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
	<li>Компоненты могут ссылаться на другие компоненты в возвращённом ими дереве. Это позволяет нам использовать одну и ту же абстракцию - компоненты - на любом уровне нашего приложения</li>
	<li>компонент App может отрендерить компонент Child несколько раз</li>
</ul>

<pre><code class="js">
function App() {
	return (
		&lt;div&gt;
			&lt;Child /&gt;
			&lt;Child /&gt;
		&lt;/div&gt;
	);
}
</code></pre>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Классовые компоненты с пропсами</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<v-two-code type="js;js" comment="Классовый компонент;Функциональный компонент">
<template v-slot:first>
class App extends React.Component {
	<u-code>render()</u-code> {
		return (
			&lt;div&gt;
				&lt;Button name="Кнопка" /&gt;
			&lt;/div&gt;
		);
	}
}
class Button extends React.Component {
	<u-code>render()</u-code> {
		return &lt;button&gt;{<u-code>this.props.name</u-code>}&lt;/button&gt;;
	}
}
</template>
<template v-slot:last>
function App() {
	return (
		&lt;div&gt;
			&lt;Button name="Кнопка" /&gt;
		&lt;/div&gt;
	);
}
function Button(props) {
	return &lt;button&gt;{props.name}&lt;/button&gt;;
}
</template>
</v-two-code>
