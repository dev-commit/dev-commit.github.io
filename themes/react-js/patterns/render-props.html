<h2>Рендер-пропсы</h2>

<ul class="list-point">
    <li><u-text-define>Рендер-проп</u-text-define> - относится к возможности компонентов React разделять код между собой с помощью пропа, значение которого является функцией</li>

    <li><u-text-define>Рендер-функция</u-text-define> - паттерн React, когда в React-компонент передается функци, которая занимается рендерингом части компонента или всего компонента. Таакая функция обычно возвращает строку или React-элемент</li>

    <li>Рендер-проп - функция, которая сообщает компоненту что необходимо рендерить</li>
    <li>Любой проп, который используется компонентом и является функцией рендеринга, технически является и «рендер-пропом».</li>
    <li>Применяется в библиотеке React Router</li>
    <li><u>Цель:</u> инкапсулировать поведение с возможностью повторного использования</li>
    <li>Использование рендер-пропа может свести на нет преимущество, которое даёт <u>React.PureComponent</u>, если вы создаёте функцию внутри метода render. Это связано с тем, что поверхностное сравнение пропсов всегда будет возвращать false для новых пропсов и каждый render будет генерировать новое значение для рендер-пропа</li>
</ul>

<hr>

<ul class="list-point">
    <li>Компонент с рендер-пропом берёт функцию, которая возвращает React-элемент, и вызывает её вместо реализации собственного рендера</li>
</ul>
<pre><code class="html">
&lt;DataProvider <u-code>render</u-code>={data =&gt; (
	&lt;h1&gt;Привет, {data.target}&lt;/h1&gt;
)}/&gt;
</code></pre>

<pre><code class="html">
&lt;Mouse <u-code>render</u-code>={mouse =&gt; (
	&lt;Component {...this.props} mouse={mouse} /&gt;
)}/&gt;
</code></pre>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Примеры</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<!------------------------------------------------------------->
<h4>1. В проп можно передать функцию</h4>
<!------------------------------------------------------------->
<pre><code class="js">
class App extends Component {
	render() {
		return &lt;Child <u-code>name={arg =&gt; "Hello " + arg}</u-code> /&gt;;
	}
}
</code></pre>

<pre><code class="js">
class Child extends Component {
	render() {
		return &lt;div&gt;{<u-code>this.props.name("Tony")</u-code>}&lt;/div&gt;;
	}
}
</code></pre>

<pre><code class="js">
// => Hello Tony
</code></pre>

<!------------------------------------------------------------->
<h4>2. Реализация</h4>
<!------------------------------------------------------------->
<pre><code class="js">
// 1. App вызывает AppContainer и передает функцию с аргументом "name"
const App = (props) =&gt; (
	&lt;AppContainer 
		render={name =&gt; &lt;AppNames name={name} /&gt;}
	/&gt;
);

// 2. AppContainer читает prop с функцией и вызывает ее, передавая значение в аргумент "name"
// 3. Внутри функции аргумент "name" передается в prop для AppNames
const AppContainer = (props) =&gt; {
	const name = "Tony";
	return (
		&lt;div&gt;
			{props.render(name)}
		&lt;/div&gt;
	);
};

// 4. "AppNames" принимает prop "name" и рендерит JSX
const AppNames = (props) =&gt; (
	&lt;h2&gt;{props.name}&lt;/h2&gt;
);

// =&gt; Tony
</code></pre>
