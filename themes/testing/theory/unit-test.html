<h2>Юнит-тесты</h2>

<ul class="list-point">
    <li><u-text-define>Юнит-тесты</u-text-define> позволяет проверить на корректность отдельные модули исходного кода программы (функции, методы и классы) в изоляции от остальной программы (а всё остальное имитируется/заменяется). Они должны быть написаны на том же языке, что и тестируемый продукт и храниться в том же репозитории. Обычно пишутся разработчиками. Они часто прогоняются как часть сборки, чтобы сразу же увидеть успешно ли завершается тест или нет</li>
    <li>Тест является спецификацией метода класса, контрактом: какие входные параметры ожидает этот метод, и что остальные компоненты системы ждут от него на выходе</li>
    <li><u>Тесты белого ящика</u></li>
    <li><b>Цель</b>: изолировать отдельные части программы и показать, что по отдельности эти части работоспособны</li>

    <li><b>Идея</b>: писать тесты для каждой нетривиальной функции или метода. Это позволяет достаточно быстро проверить, не привело ли очередное изменение кода к регрессии, то есть к появлению ошибок в уже оттестированных местах программы, а также облегчает обнаружение и устранение таких ошибок</li>
</ul>

<h4>Преимущества</h4>
<ol class="list-num">
    <li><u>Поощрение изменений</u>. Поощряет программистов к изменениям кода, поскольку достаточно легко проверить, что код работает и после изменений</li>
    <li><u>Упрощение интеграции</u>. Может быть использовано для подхода к тестированию «снизу вверх»: сначала тестируя отдельные части программы, а затем программу в целом</li>
    <li><u>Документирование кода</u>. Можно рассматривать как «живой документ» для тестируемого класса</li>
    <li><u>Отделение интерфейса от реализации</u>. Поскольку некоторые классы могут использовать другие классы, тестирование отдельного класса часто распространяется на связанные с ним. Например, класс пользуется базой данных; в ходе написания теста программист обнаруживает, что тесту приходится взаимодействовать с базой. Это ошибка, поскольку тест не должен выходить за границу класса. В результате разработчик абстрагируется от соединения с базой данных и реализует этот интерфейс, используя свой собственный mock-объект. Это приводит к менее связанному коду, минимизируя зависимости в системе</li>
    
    <ul class="list-point">
        <li><u-text-define>Mock-объект (mock object «объект-имитация»)</u-text-define> - в ООП тип объектов, реализующих заданные аспекты моделируемого программного окружения. Mock-объект представляет собой конкретную фиктивную реализацию интерфейса, предназначенную исключительно для тестирования взаимодействия и относительно которого высказывается утверждение</li>
    </ul>
</ol>

<h4>Когда не работает</h4>
<ol class="list-num">
    <li><u>Сложный код</u></li>
    <li><u>Результат известен лишь приблизительно</u></li>
    <li><u>Код, взаимодействующий с системой</u>. Код, взаимодействующий с портами, таймерами и прочими «нестабильными» частями системы, крайне сложно проверить в изолированном окружении</li>
    <li><u>Ошибки интеграции и производительности</u>. При выполнении юнит-тестов происходит тестирование каждого из модулей по отдельности. Это означает, что ошибки интеграции, системного уровня, функций, исполняемых в нескольких модулях, не будут определены</li>
    <li><u>При общей низкой культуре программирования</u>. Для получения выгоды от модульного тестирования требуется строго следовать технологии тестирования на всём протяжении процесса разработки программного обеспечения. Нужно хранить не только записи обо всех проведённых тестах, но и обо всех изменениях исходного кода во всех модулях. С этой целью следует использовать систему контроля версий ПО. Таким </li>
    <li><u>Проблемы с объектами-заглушками</u></li>
</ol>

<h4>Библиотеки для JavaScript</h4>
<ul class="list-point">
    <li>Mocha (тестовый фреймворк)</li>
    <li>Jest</li>
    <li>Chai («assertion library», используется совместно с тестовым framework’ом)</li>
    <li>Sinon.JS (библиотека для создания mock’ов, stub’ов, spy’ев, используется совместно с тестовым framework’ом)</li>
    <li>Karma runner (от создателей Angular.JS, «test runner» — организует среду выполнения тестов)</li>
    <li>QUnit (от создателей jQuery)</li>
    <li>JsUnit (больше не поддерживается создателями)</li>
    <li>Jasmine (рекомендован создателями jsUnit)</li>
    <li>D.O.H</li>
</ul>
