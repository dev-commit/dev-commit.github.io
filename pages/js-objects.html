
        <!DOCTYPE html>
        <html>
        <head>
            <title>JavaScript: Объекты</title>
            <meta charset="utf-8">
            <link rel="icon" type="image/png" href="../src/img/favicon.png">
            <link href="../src/preloader/preloader.css" rel="stylesheet" type="text/css">
        </head>
        <body>
            <div id="preloader"></div>

            <div id="container">
                <div id="menu-left">
                    <div id="menu-left-starter">
                        <div id="menu-left-show"></div>
                        <a href="#menu-top">Starter</a>
                    </div>
                    <div id="menu-build"><div class="theme">Основное</div><a href="#main-inheritance">🔥 Наследование</a><a href="#main-new">🔥 <u-menu>new</u-menu></a><a href="#main-prototype">🔥 <u-menu>__proto__</u-menu> <u-menu>prototype</u-menu></a><a href="#main-constructor">🥥 <u-menu>constructor</u-menu></a><a href="#main-return">🥥 <u-menu>return</u-menu></a><a href="#main-new-target">⚾️ <u-menu>new.target</u-menu></a><div class="theme">Методы Object</div><a href="#objects-methods-object-create">🍕 <u-menu-unactive>Object.create</u-menu-unactive> <u-code-list>__proto__</u-code-list></a><a href="#objects-methods-object-assign">🍕 <u-menu-unactive>Object.assign</u-menu-unactive></a><a href="#objects-methods-set-prototype-of">🍕 <u-menu-unactive>Object.setPrototypeOf</u-menu-unactive> <u-code-list>__proto__</u-code-list></a><a href="#objects-methods-get-prototype-of">🍕 <u-menu-unactive>Object.getPrototypeOf</u-menu-unactive> <u-code-list>__proto__</u-code-list></a><a href="#objects-methods-is-prototype-of">🍕 <u-menu-unactive>isPrototypeOf</u-menu-unactive> <u-code-list>__proto__</u-code-list></a><a href="#objects-methods-instanceof">🍕 <u-menu-unactive>instanceof</u-menu-unactive></a><a href="#objects-for">Перебор объекта</a><a href="#objects-check-property">Проверка наличия свойства</a><a href="#objects-descriptor">Дескрипторы свойств</a><a href="#objects-extends">Расширяемость объектов</a><div class="theme">Объекты ES6+</div><a href="#objects-info">📑 Теория</a><a href="#objects-literal-notation">💥 Литеральная нотация</a><a href="#objects-constructor">Конструктор создания объекта</a><a href="#objects-prototype">Прототип</a><a href="#objects-conversion">🍩 <u-menu>toString</u-menu> <u-menu>valueOf</u-menu></a><a href="#objects-samples">Примеры</a><div class="theme">Классы ES6+</div><a href="#class-es6-info">📑 Теория</a><a href="#class-es6-create">🔥 Объявление</a><a href="#class-es6-inherit">🔥 Наследование</a><a href="#class-es6-class-properties">Свойства классов</a><a href="#class-es6-expression">Выражения классов</a><div class="theme">Классы ES5 «Функциональный стиль»</div><a href="#class-es5-functional-create">🍕 Объявление</a><a href="#class-es5-functional-methods-private">🍕 Приватный метод</a><a href="#class-es5-functional-getters-and-setters">🍕 Геттеры и сеттеры</a><a href="#class-es5-functional-inherit">🍕 Наследование</a><div class="theme">Классы ES5 «Прототипный стиль»</div><a href="#class-es5-prototype-info">📑 Теория</a><a href="#class-es5-prototype-methods">🍪 Добавление методов</a><a href="#class-es5-prototype-inherit">🍪 Наследование классов</a><a href="#class-es5-prototype-mixins">🍪 Примеси</a></div>
                </div>
                <div id="content-wrapper">
                    <div id="menu-top"><a href="/pages/assessment.html" class="menu menu-other">Ассессмент</a><a href="/pages/js-tasks.html" class="menu menu-other">🍕 Задачи</a><a href="/pages/theory.html" class="menu menu-other">📑 Теория</a><div style="width: 100%; flex-shrink: 0"></div><a href="/pages/theory-patterns.html" class="menu menu-other">⚡️ Паттерны</a><a href="/pages/theory-paradigms.html" class="menu menu-other">⚡️ Парадигмы</a><a href="/pages/theory-algoritms.html" class="menu menu-other">⚡️ Алгоритмы</a><a href="/pages/theory-data-structures.html" class="menu menu-other">⚡️ Структуры данных</a><div style="width: 100%; flex-shrink: 0"></div><a href="/pages/js.html" class="menu menu-js">🥑 JavaScript</a><a href="/pages/js-objects.html" class="menu menu-js">🥑 Классы</a><a href="/pages/js-async.html" class="menu menu-js">🍋 Асинхронность</a><a href="/pages/js-client-server.html" class="menu menu-js">🍋 Клиент-сервер</a><div style="width: 100%; flex-shrink: 0"></div><a href="/pages/js-web-api.html" class="menu menu-js">Web API</a><a href="/pages/js-web-components.html" class="menu menu-js">WebComponents</a><a href="/pages/canvas.html" class="menu menu-js">Canvas</a><div style="width: 100%; flex-shrink: 0"></div><a href="/pages/react-js.html" class="menu menu-fw">💥 React.js</a><a href="/pages/react-api.html" class="menu menu-fw">💥 React API</a><a href="/pages/react-hooks.html" class="menu menu-fw">💥 React Hooks</a><a href="/pages/redux.html" class="menu menu-fw">🍋 Redux</a><a href="/pages/react-router.html" class="menu menu-fw">React Router</a><a href="/pages/vue-js.html" class="menu menu-fw">Vue.js</a><div style="width: 100%; flex-shrink: 0"></div><a href="/pages/testing.html" class="menu menu-other">📑 Тестирование</a><a href="/pages/jest.html" class="menu menu-other">🔰 Jest</a><a href="/pages/enzyme.html" class="menu menu-other">🔰 Enzyme + Jest</a><a href="/pages/react-testing.html" class="menu menu-other">🍋 React Testing</a><a href="/pages/cypress.html" class="menu menu-other">🔰 Cypress</a><div style="width: 100%; flex-shrink: 0"></div><a href="/pages/html.html" class="menu menu-html">HTML</a><a href="/pages/css.html" class="menu menu-html">CSS</a><a href="/pages/css-flexbox.html" class="menu menu-html">Flexbox</a><a href="/pages/css-grid.html" class="menu menu-html">CSS Grid</a><a href="/pages/svg.html" class="menu menu-html">SVG</a><a href="/pages/sass.html" class="menu menu-html">Sass</a><a href="/pages/bootstrap.html" class="menu menu-html">Bootstrap</a><div style="width: 100%; flex-shrink: 0"></div><a href="/pages/git.html" class="menu menu-php">🥥 Git</a><a href="/pages/typescript.html" class="menu menu-php">🍋 TypeScript</a><a href="/pages/flow.html" class="menu menu-php">🍋 Flow</a><a href="/pages/npm.html" class="menu menu-php">🥥 Webpack</a><a href="/pages/webpack.html" class="menu menu-php">NPM</a><a href="/pages/material-ui.html" class="menu menu-php">Material-UI</a><a href="/pages/ramda.html" class="menu menu-php">Ramda</a><div style="width: 100%; flex-shrink: 0"></div><a href="/pages/other.html" class="menu menu-other">📑 Other</a><a href="/pages/node-js.html" class="menu menu-other">Node.js</a><a href="/pages/php.html" class="menu menu-other">PHP</a><a href="/pages/python.html" class="menu menu-other">Python</a><a href="/pages/mysql.html" class="menu menu-other">mySql</a><a href="/pages/linux.html" class="menu menu-other">Linux</a><a href="/pages/jquery.html" class="menu menu-other">jQuery</a></div>
                    <div id="content"><div id="main-inheritance"><h2>Наследование</h2>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>ES5</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
	<li><u-text-define>Класс</u-text-define> - <u>функция-конструктор</u> вместе с её <u>prototype</u></li>
	<li><u>Класс</u> - конструктор объектов</li>
</ul>

<v-code lang="js" title="Родитель">
function User(name) {
	this.name = name;
}
User.<u-code>prototype</u-code>.getName = function() {
	console.log(this.name);
}
</v-code>

<v-code lang="js" title="Наследник">
function Admin() {
	// Для наследования собственных свойств User()
	<u-code>User.apply</u-code>(this, arguments);
}

// В прототип Admin добавили всё из прототипа User
Admin.prototype = <u-code>Object.create</u-code>(User.prototype);
</v-code>

<v-code lang="js" title="Результат">
const admin = new Admin('Tony');

admin.getName();    // => "Tony"
console.log(admin); // => Object { getName() {}, name: "Tony" }
</v-code>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Установка прототипа</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<!------------------------------------------------------------->
<h4>1. Object.create (верно)</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
User.prototype = Object.create(Person.prototype);
</v-code>

<ul class="list-point">
    <li><u>Object.create</u> создает новый пустой объект, прототипом которого устанавливает ссылку на <u>Person.prototype</u></li>
    <li>При вызове <u>User</u> через <u>new</u>, создастся новый объект и в свойство <u>__proto__</u> установится ссылка на свой <u>prototype</u></li>
</ul>

<!------------------------------------------------------------->
<h4>2. Простое присваивание прототипов (неверно)</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
User.prototype = Person.prototype;
</v-code>

<ul class="list-point">
    <li>Если добавлять методы в <u>User.prototype</u>, они попадут в <u>Person.prototype</u></li>
    <li>Перезатрется текущий прототип у <u>User</u>: в <u>User.prototype</u> будет пустой объект со свойством <u>constructor</u>, который ссылается на <u>User</u>. Если в коде могут быть добавлены методы, они перезатрутся</li>
</ul>

<!------------------------------------------------------------->
<h4>3. Через new (неверно)</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
User.prototype = new Person; 
</v-code>

<ul class="list-point">
    <li>При вызове <u>new</u> получаем объект, наполненный свойствами с прототипом, но нужно получить пустой объект, чтобы не было свойств</li>
    <li>При <u>new Person</u> прилетит мусор в виде собственных свойств класса <u>Person</u></li>
</ul>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>ES6-классы</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
    <li><u-text-define>Класс</u-text-define> - функция/шаблон, предназначенный для создания объектов и методов</li>
    <li><u-text-define>Конструктор</u-text-define> - метод, который вызывается в момент создания объекта т.е. когда используется ключевое слово new он создает свойства и инициализирует, т.е. подготавливает объект к использованию</li>
</ul>

<ul class="list-point">
    <li>Если у подкласса нет конструктора, он будет использовать конструктор родителя</li>
    <li>Если подклассу указать конструктор, то он должен вызывать в начале конструктор родительского класса <u-code-text>super()</u-code-text></li>
    <li>Метод <u-code-text>super()</u-code-text> позволяет наследовать свойства и методы из прототипа</li>
</ul>

<v-code lang="js" title="">
class User {
	constructor(name) {
		this.name = name;
	}
	getName() {
		console.log(this.name);
	}
}

class Admin <u-code>extends</u-code> User {
	constructor(name) {
		<u-code>super</u-code>(name);
	}
}

const admin = new Admin('Tony');
admin.getName();    // => "Tony"
console.log(admin); // => Object { name: "Tony" }
</v-code>
</div><div id="main-new"><h2>Конструктор new</h2>

<ul class="list-point">
    <li><u-code-text>new</u-code-text> недоступно у стрелочной функции</li>
</ul>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Полифил</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<v-code lang="js" title="">
function Person(name) {
	this.name = name;
}

function Foo(Constructor, ...props) {
	// 1. Создаётся новый пустой объект через Object.create
	// Устанавливает __proto__ этому объекту в которое записывается ссылка из <u>prototype</u>
	const instance = Object.create(Constructor.prototype);

	// 2. Модифицируется <u>this</u> (т.е. этот новый объект) и инициализируются методы и свойства
	// Применяет функцию-класс к нашему новосозданному объекту
	// instance.name = 'Tony';
	Constructor.apply(instance, props);

	// 3. Неявно возвращается <u>this</u> без вызова <u>return</u>
	// Если в return объект, то вернется он
	// return (typeof instance === 'object' && instance !== null) ? instance : {};
	return instance instanceof Object ? instance : {};
}

const foo = Foo(Person, 'Tony');
console.log(foo); // => Object { name: "Tony" }
</v-code>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Использование new</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<v-code lang="js" title="">
function Foo(name) {
	this.name = name;
}

const foo = new Foo('Tony');
console.log(foo); // => Object { name: "Tony" }
</v-code>
</div><div id="main-prototype"><h2>__proto__ и prototype</h2>

<v-two-fix><template v-slot:first>

<ul class="list-point">
    <li><u-text-define>__proto__</u-text-define> - свойство <u-text-underline>объекта</u-text-underline> <u-code-text>Object.prototype</u-code-text>, хранящее ссылку на свойство <u-code-text>prototype</u-code-text> конструктора</li>
    <hr>

    <li><u-text-define>prototype</u-text-define> - свойство <u-text-underline>функции</u-text-underline> с единственным свойством <u-code-text>constructor</u-code-text>, которое ссылается на саму функцию</li>
 	<li><b>Используется:</b> как прототип при создании новых объектов оператором <u-code-text>new</u-code-text></li>
	<li><b>Цель:</b> указывать <u-code-text>__proto__</u-code-text> для новых объектов. При создании объекта через <u-code-text>new</u-code-text>, в его прототип <u-code-text>__proto__</u-code-text> записывается ссылка из <u-code-text>prototype</u-code-text> функции-конструктора</li>
	<hr>

    <li><u-text-define>constructor</u-text-define> - свойство, ссылающеется на саму функцию</li>
</ul>

</template><template v-slot:last>
<img src="/img/js/prototype/prototype.png" width="650">
</template></v-two-fix>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>__proto__</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
    <li>При обращении к любому свойству объекта, оно в первую очередь ищется в самом объекте. Но если его там нет, поиск происходит в свойстве <u-code-text>__proto__</u-code-text>. Если его нет и там, оно ищется дальше по цепочке (<u>prototype chain</u>)</li>
	<li>__proto__ - наследование на уровне объектов</li>
</ul>

<img src="/img/js/prototype/prototype-chain.png">

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>prototype</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
	<li>
		<img src="/img/js/prototype/prototype-prop.png">
	</li>
	<li><u>Прототип</u> - ссылка на другой объект, предоставляющий методы и свойства</li>
	<li>Есть у каждой функции, кроме стрелочной</li>
	<li>Имеет смысл только у <u>конструктора</u>, когда есть вызов <u-code-text>new</u-code-text></li>
	<li>Значением prototype может быть только объект</li>
</ul>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Схемы</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<img src="/img/js/prototype/prototype-scheme.png" width="650px">

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Примеры</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<!------------------------------------------------------------->
<h4>1. Перетирание прототипа</h4>
<!------------------------------------------------------------->

<ul class="list-point">
    <li>При создании объекта его <u-code-text>__proto__</u-code-text> 1 раз получает ссылку на <u-code-text>prototype</u-code-text> функции конструктора</li>
    <li>Эта ссылка остаётся при <u-code-text>Fn.prototype = {};</u-code-text> и по-прежнему указывает на старое значение, но к функции конструктору уже не имеет отношения</li>
    <li>При <u-code-text>Fn.prototype = {}</u-code-text> не просто добавили объект, а поменяли ссылку и новые отнаследованные объекты получат уже ее</li>
</ul>

<img src="/img/js/prototype/prototype-clear-link.jpg" width="400px">

<v-two-code type="js;js" comment="Всё стандартно;Перетирание протоипа">
<template v-slot:first>
function Fn() {}

Fn.prototype = {
	isConnected: true
};

let connect = new Fn();

console.log(connect.isConnected); // => true

Fn.prototype.isConnected = false;

console.log(connect.isConnected); // => false
</template>
<template v-slot:last>
function Fn() {}

Fn.prototype = {
    isConnected: true
};

let connect = new Fn();

console.log(connect.isConnected); // true

Fn.prototype = {};

console.log(connect.isConnected); // true
</template>
</v-two-code>

<!------------------------------------------------------------->
<h4>2</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
function User() {
    this.name = 'Tony';
}
function Admin() {
    this.id = 77;
}
Admin.<u-code>prototype</u-code> = new User();
// Admin.__proto__ = new User();
var admin = new Admin(); // => Admin {id: 77, __proto__: User name: "Tony"}
</v-code>

<!------------------------------------------------------------->
<h4>3</h4>
<!------------------------------------------------------------->
<img src="/img/js/prototype/proto-tree.jpg" class="center" height="250px">

<v-code lang="js" title="">
function User() {
    this.name = 'Tony';
}
User.prototype.myFunc = function() {}
Object.prototype.myFuncObject = function() {}
let obj = new User();
</v-code>
</div><div id="main-constructor"><h2>Свойство constructor</h2>

<!------------------------------------------------------------->
<h4>Свойство constructor по умолчанию</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
// у каждой функции по умолчанию есть свойство prototype, содержащее объект
function MyFunc() {}
MyFunc.prototype = { 
	<u-code>constructor</u-code>: MyFunc 
};
var a = new MyFunc(); // => MyFunc {} __proto__: constructor: ƒ MyFunc()
</v-code>

<!------------------------------------------------------------->
<h4>Перезапись свойства constructor</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
function MyFunc() {}
MyFunc.prototype = { 
	jumps: true 
};
var a = new MyFunc(); // => MyFunc {} __proto__: jumps: true 
</v-code>

<!------------------------------------------------------------->
<h4>Создание объекта с тем же конструктором, что и данный</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
function User(name) {
    this.name = name;
    console.log(name);
}
var user1 = new User('Tony');
var user2 = new user1.<u-code>constructor</u-code>('Jack');
</v-code></div><div id="main-return"><h2>Правила обработки return</h2>

<ul class="list-point">
	<li>При вызове <u>return</u> с объектом, будет возвращён объект, а не <u>this</u></li>
	<li>При вызове <u>return</u> с примитивным значением, оно будет отброшено и возвращен <u>this</u></li>
</ul>

<!------------------------------------------------------------->
<h4>1. Возвращает объект</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
function BigAnimal() {
	this.name = "Мышь";
	return { name: "Годзилла" };  // <-- возвратим объект
}
alert( new BigAnimal().name );  // Годзилла, получили объект вместо this
</v-code>

<!------------------------------------------------------------->
<h4>2. Возвращает примитивное значение</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
function BigAnimal() {
	this.name = "Мышь";
	return "Годзилла"; // <-- возвратим примитив
}
alert( new BigAnimal().name ); // Мышь, получили this (а Годзилла пропала)
</v-code>

<!------------------------------------------------------------->
<h4>3. Возвращает пустое значение</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
function SmallAnimal() {
	this.name = "Мышь";
	return; // <-- возвращает this
}

alert( new SmallAnimal().name );  // Мышь
</v-code>
</div><div id="main-new-target"><h2>Проверка на вызов в режиме конструктора: new.target</h2>

<ul class="list-point">
    <li>Используя специальное свойство <u-code-text>new.target</u-code-text> внутри функции, можно проверить, вызвана ли функция при помощи оператора <u-code-text>new</u-code-text> или без него</li>
    <li>В случае, если функция вызвана при помощи <u-code-text>new</u-code-text>, то в <u-code-text>new.target</u-code-text> будет сама функция, в противном случае <u>undefined</u></li>
</ul>

<v-code lang="js" title="">
function User() {
	alert(new.target);
}

// без "new":
<u-code>User(); // undefined</u-code>

// с "new":
<u-code>new User(); // function User { ... }</u-code>
</v-code>

<ul class="list-point">
    <li>Это можно использовать, чтобы отличить обычный вызов от вызова «в режиме конструктора». В частности, вот так можно сделать, чтобы функцию можно было вызывать как с, так и без new</li>
    <li>Такой подход иногда используется в библиотеках для создания более гибкого синтаксиса, который позволяет разработчикам вызывать функции при помощи оператора new или без него</li>
</ul>

<v-code lang="js" title="">
function User(name) {
	if (!new.target) { // в случае, если вы вызвали без оператора new
		return new User(name); // ...добавим оператор new за вас
	}
	this.name = name;
}

let vasya = User("Вася"); // переадресовывает вызовы на new User
alert(vasya.name); // Вася
</v-code>
</div><div id="objects-methods-object-create"><h2>Object.create</h2>

<div class="v-method-wrapper">
    <v-method before="Object." method="create" after="" arg="(proto, propertiesObject)">
    добавление прототипа при создании объекта (создаёт пустой объект с __proto__, равным первому аргументу, второй содержит дескрипторы свойств)
    </v-method>

	<v-method-arg arg="proto">объект, который станет прототипом вновь созданного объекта (__proto__)</v-method-arg>
	<v-method-arg arg="descriptors">дескрипторы свойств. Необязательный параметр. Если указан и не равен undefined, должен быть объектом, чьи собственные перечисляемые свойства (то есть такие, которые определены на самом объекте, а не унаследованы по цепочке прототипов) указывают дескрипторы свойств, добавляемых в новый объект. Имена добавляемых свойств совпадают с именами свойств в этом объекте. Эти свойства соответствуют второму аргументу метода Object.defineProperties()</v-method-arg>

	<v-method-return>Новый объект с заданным прототипом и свойствами</v-method-return>
</div>

<v-code lang="js" title="">
var obj = Object.create(
	{ name: 'Tony' }
);
// => {} => __proto__: name: "Tony"
</v-code>
</div><div id="objects-methods-object-assign"><h2>Object.assign</h2>

<div class="v-method-wrapper">
    <v-method before="Object." method="assign" after="" arg="(target, ...sources)">
    копирование значений всех собственных перечисляемых свойств (при обходе в цикле for..in его можно будет получить) из одного или более исходных объектов в целевой объект. Происходит создание поверхностной копии
    </v-method>

	<v-method-arg arg="target">целевой объект</v-method-arg>
	<v-method-arg arg="sources">исходные объекты</v-method-arg>

	<v-method-return>Получившийся целевой объект</v-method-return>
</div>

<v-code lang="js" title="">
let obj = Object.assign(
	{ name: 'Tony' }, 
	{ age: 25 }
);
// obj {name: "Tony", age: 25}
</v-code>
</div><div id="objects-methods-set-prototype-of"><!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Object.setPrototypeOf</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div class="v-method-wrapper">
    <v-method before="Object." method="setPrototypeOf" after="" arg="(obj, prototype)">
	Устанавливает прототип (то есть, внутреннее свойство [[Prototype]]) указанного объекта в другой объект после создания объекта или null.
	Устанавливает obj.__proto__ = prototype
    </v-method>

	<v-method-arg arg="obj">Объект, которому устанавливается прототип</v-method-arg>
	<v-method-arg arg="prototype">Новый прототип объекта (объект или null)</v-method-arg>
</div>

<v-code lang="js" title="">
var dict = Object.setPrototypeOf({}, null);
</v-code>

<ul class="list-point">
    <li>Плохо сказывается на производительности</li>
</ul>

<!------------------------------------------------------------->
<h4>Примеры</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
const animal = {
	say() {
		console.log(this.name);
	}
}
const cat = {
	name: 'cat'
}
Object.setPrototypeOf(cat, animal);
cat.say(); // => "cat"
</v-code>
</div><div id="objects-methods-get-prototype-of"><!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Object.getPrototypeOf</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<div class="v-method-wrapper">
    <v-method before="Object." method="getPrototypeOf" after="" arg="(obj)">
    Возвращает прототип (то есть, внутреннее свойство [[Prototype]]) указанного объекта.
	Возвращает obj.__proto__
    </v-method>

	<v-method-arg arg="obj">Объект, чей прототип будет возвращён</v-method-arg>
</div>

<v-code lang="js" title="">
var proto = {};
var obj = Object.create(proto);
Object.getPrototypeOf(obj) === proto; // true
</v-code>
</div><div id="objects-methods-is-prototype-of"><!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>isPrototypeOf</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<div class="v-method-wrapper">
    <v-method before="prototypeObj." method="isPrototypeOf" after="" arg="()">
	проверяет, входит ли объект в цепочку прототипов другого объекта
    </v-method>

	<v-method-arg arg="prototypeObj">объект, проверяемый на каждую ссылку в цепочке прототипов аргумента object</v-method-arg>
	<v-method-arg arg="object">объект, в чьей цепочке прототипов производится поиск</v-method-arg>

	<v-method-return></v-method-return>
</div>

<ul class="list-point">
    <li>Отличие от <u-code-text>instanceof</u-code-text>: выражение <u-code-text>object instanceof AFunction</u-code-text> проверяет, присутствует ли в цепочке прототипов объекта <u-code-text>object</u-code-text> объект <u-code-text>AFunction.prototype</u-code-text>, а не сам объект <u-code-text>AFunction</u-code-text></li>
</ul>

<v-code lang="js" title="">
// является ли объект ObjParent прототипом для объекта ObjChild
ObjChild.<u-code>isPrototypeOf</u-code>(ObjParent);
</v-code>
</div><div id="objects-methods-instanceof"><h2>instanceof</h2>

<div class="v-method-wrapper">
    <v-method before="" method="instanceof" after="" arg="">
    проверка, какому классу принадлежит объект, с учетом прототипного наследования
    </v-method>
</div>

<v-code lang="js" title="">
function Car(make, model) {
	this.make = make;
	this.model = model;
}
const auto = new Car('Honda', 'Accord');

const a = auto instanceof Car; // => true
const a = auto instanceof Object; // => true
</v-code>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Информация</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
	<li>Оператор obj instanceof Func проверяет что obj является результатом вызова new Func. Он учитывает цепочку <u>__proto__</u>, поэтому наследование поддерживается</li>
	<li>Оператор <u>instanceof</u> не сможет проверить тип значения, если объект создан в одном окне/фрейме, а проверяется в другом, т.к. в каждом окне своя иерархия объектов. Для точной проверки типов встроенных объектов можно использовать свойство <u>[[Class]]</u></li>
	<li>Оператор <u>instanceof</u> особенно востребован в случаях, когда мы работаем с иерархиями классов. Это наилучший способ проверить принадлежность тому или иному классу с учётом наследования</li>

	<hr>
	<b>Алгоритм проверки obj instanceof Constructor</b>
	<li>1. Получить obj.__proto__</li>
	<li>2. Сравнить obj.__proto__ с Constructor.prototype</li>
	<li>3. Если не совпадает, тогда заменить obj на obj.__proto__ и повторить проверку на шаге 2 до тех пор, пока либо не найдется совпадение (результат true), либо цепочка прототипов не закончится (результат false)</li>
</ul>

<v-code lang="js" title="">
function ClassParent() {}
var parent = new ClassParent();
var a = parent instanceof ClassParent; // true
// parent.__proto__ == ClassParent.prototype;
</v-code>

<v-code lang="js" title="">
// массив arr принадлежит классу Array
// но также и является объектом Object
var arr = [];
var a = arr instanceof Array; // true
var a = arr instanceof Object; // true
// arr.__proto__.__proto__ == Object.prototype
</v-code>

<v-code lang="js" title="">
// сама функция-конструктор не участвует в процессе проверки, важна только цепочка прототипов для проверяемого объекта
// это может приводить к ошибкам в проверке при изменении prototype
function Rabbit() {}
var rabbit = new Rabbit();
Rabbit.prototype = {}; // изменили prototype...
var a = rabbit instanceof Rabbit; // false
</v-code>
</div><div id="objects-for"><h2>Перебор объекта</h2>

<div class="v-method-wrapper">
    <v-method before="for (variable" method=" in" after="object) {...}" arg="">
    Проходит через перечисляемые свойства объекта и его цепочку прототипов. Он пройдёт по каждому отдельному элементу.
    Порядок перебора соответствует порядку объявления для нечисловых ключей, а числовые или числовые строки сортируются
    </v-method>

	<v-method-arg arg="variable">Другое (очередное) имя свойства назначается переменной на каждой итерации</v-method-arg>
	<v-method-arg arg="object">Объект, по чьим свойствам мы проходим</v-method-arg>
</div>

<v-code lang="js" title="">
for(let key <u-code>in</u-code> obj) {
	console.log(key);      // ключи 
	console.log(obj[key]); // значения
} 
</v-code>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Перечисление всех свойств объекта</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<v-code lang="js" title="">
var a = Object.<u-code>keys</u-code>(obj);                // возвращает массив со всеми собственными (те, что в цепочке прототипов, не войдут в массив) именами перечисляемых свойств объекта
var a = Object.<u-code>keys</u-code>(obj).<u-code>length</u-code>;         // количество свойств
var a = Object.<u-code>getOwnPropertyNames</u-code>(obj); // возвращает массив содержащий все имена своих свойств (перечисляемых и неперечисляемых) объекта
</v-code>
</div><div id="objects-check-property"><h2>Проверка наличия свойства</h2>

<ul class="list-point">
	<li>Можно обратиться к любому свойству объекта, даже если его нет. Если свойство не существует, вернется undefined</li>
</ul>

<v-code lang="js" title="">
var a = obj.name;                        // проверка наличия свойсва 'name' в объекте (не различает отсутствующие свойства и те что были установлен в undefined)
var a = 'name' <u-code>in</u-code> obj;                   // проверка наличия свойсва 'name' в объекте (различает отсутствующие свойства и те что были установлен в undefined)
var a = obj.<u-code>hasOwnProperty</u-code>('name');      // проверка наличия свойства 'name' в объекте (не берет наследованные свойства)
</v-code>

</div><div id="objects-descriptor"><h2>Дескрипторы свойств</h2>

<ul class="list-point">
	<li><u-text-define>Свойства объекта</u-text-define> имеют: <u>имя</u>, <u>значение</u> (атрибут value), <u>атрибуты</u> (writable, enumerable, configurable)</li>
</ul>

<v-code lang="js" title="">
Object.<u-code>getOwnPropertyDescriptor</u-code>(obj, 'name');  // получение дескриптора свойств
Object.<u-code>defineProperty</u-code>(obj, prop, descriptor);  // переопределение дескриптора свойств
Object.<u-code>defineProperties</u-code>(obj, descriptors);     // позволяет объявить сразу несколько свойств
</v-code>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Получение дескриптора свойств</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<v-code lang="js" title="">
const person = {
	name: 'Tony',
	age: 20
}
const a = Object.<u-code>getOwnPropertyDescriptor</u-code>(person, 'name');
// {value: "Tony", writable: true, enumerable: true, configurable: true } 
</v-code>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Переопределение дескриптора свойств</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<v-code lang="js" title="">
Object.<u-code>defineProperty</u-code>(obj, prop, descriptor)
	obj        // объект, в котором объявляется свойство
	prop       // имя свойства, которое нужно объявить или модифицировать
	descriptor // дескриптор - объект, который описывает поведение свойства
</v-code>

<v-code lang="js" title="">
// 1-объект, 2-свойство, 3-дескриптор
Object.<u-code>defineProperty</u-code>(person, 'name', {
	<em>value</em>: 'Jack',       // значение свойства (по умолчанию undefined)
	<em>writable</em>: false,     // значение свойства можно менять (по умолчанию false)
	<em>configurable</em>: false, // возможность удаление свойства и изменения атрибутов свойства при помощи новых вызовов defineProperty (по умолчанию false)
	<em>enumerable</em>: false,   // свойство просматривается в цикле for..in и методе Object.keys() (по умолчанию false)
	<em>get()</em> {}             // функция, которая возвращает значение свойства (по умолчанию undefined)
	<em>set()</em> {}             // функция, которая записывает значение свойства (по умолчанию undefined)
});
</v-code>

<!------------------------------------------------------------->
<h4>Объект с парами свойсво:дескриптор</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
// 1-объект, 2-объект с парами свойсво:дескриптор
Object.<u-code>defineProperties</u-code>(person, {
	name: {
		value: 'Jack',
		writable: false
	}, 
	age: {
		value: 25,
		writable: false
	}
});
</v-code>

<!------------------------------------------------------------->
<h4>Обычное свойство</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
// оба вызова добавляют в объект user обычное (удаляемое, изменяемое, перечисляемое) свойство
const user = {};
user.name = 'Tony';
Object.defineProperty(user, 'name', { value:'Tony', configurable:true, writable:true, enumerable:true });
</v-code>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Геттеры и сеттеры</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<v-code lang="js" title="">
const user = {
	firstName: "Вася",
	surname: "Петров"
}

Object.defineProperty(user, "fullName", {
	get() {
		return this.firstName + ' ' + this.surname;
	},
	set(value) {
		const split = value.split(' ');
		this.firstName = split[0];
		this.surname = split[1];
	}
});

user.fullName = "Петя Иванов";
alert(user.fullName);   // Вася Петров
alert(user.firstName ); // Петя
alert(user.surname );   // Иванов
</v-code>
</div><div id="objects-extends"><h2>Расширяемость объектов</h2>

<ul class="list-point">
	<li><u-text-define>Расширяемость объектов</u-text-define> - возможность добавления новых свойств</li>
</ul>

<v-code lang="js" title="">
const person = {
	name: 'Tony',
	age: 20
}
</v-code>

<v-code lang="js" title="">
Object.<u-code>preventExtensions</u-code>(person);    // запрещает добавление свойств в объект (применяется только к самому объекту)
const a = Object.<u-code>isExtensible</u-code>(person); // проверяет применение preventExtensions
</v-code>

<v-code lang="js" title="">
Object.<u-code>seal</u-code>(person);                 // аналогичен preventExtensions, дополнительно задает атрибут configurable:false для всех свойств
const a = Object.<u-code>isSealed</u-code>(person);     // проверяет применение seal
</v-code>

<v-code lang="js" title="">
Object.<u-code>freeze</u-code>(person);               // аналогичен seal, дополнительно делает все свойства доступные только для чтения (configurable:false, writable:false)
const a = Object.<u-code>isFrozen</u-code>(person);     // проверяет применение freeze
</v-code>
</div><div id="objects-info"><h2>Теория</h2>

<img src="/img/js/proto.png" height="450px" class="center">

<ul class="list-point">
	<b>ХРАНЕНИЕ И КОПИРОВАНИЕ</b>

	<li><u>Примитивные типы данных</u> - хранение и копирование <u>«по значению»</u>. Передаются копированием значения. В результате копирования получатся две полностью независимые переменные</li>
	<li>Если в функцию отправить число, то будем работать с копией числа: оригинальное число не изменится</li>
	
	<li><u>Объекты</u> - хранение и копирование <u>«по ссылке»</u>. Передаются копированием ссылки. В переменной, которой присвоен объект, хранится не сам объект, а «адрес его места в памяти», иными словами – «ссылка» на него. При копировании переменной с объектом – копируется эта ссылка, а объект по-прежнему остается в единственном экземпляре. Получили две переменные, в которых находятся ссылки на один и тот же объект</li>
	<li>Если в функцию отправить объект, функция получит ссылку на него, а не копию при измененении объекта внутрни функции: изменяется оригинальный объект</li>
</ul>
</div><div id="objects-literal-notation"><h2>Литеральная нотация</h2>

<!------------------------------------------------------------->
<h4>Литеральная нотация</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
const property = 'lastName'; // в константе находится название свойства
const nickname = 'Sawyer';   // константа совпадает с названием свойства

const person = {
	firstName: 'Brad',
	[property]: 'Stark',
	nickname,
	age: 25,
	children: ['Liza', 'Petro'],
	address: {
		street: '555 Some st',
		city: 'Boston',
		state: 'MA'
	},
	getName() {
		return this.firstName;
	}, 
	<u-code>get</u-code> fullName() {
		return this.firstName + ' ' + this.lastName;
	}, 
	<u-code>set</u-code> fullName(value) {
		this.firstName = value;
	}
}
</v-code>

<!------------------------------------------------------------->
<h4>Обращение к свойствам и методам</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
const a = person.firstName;      // точечная нотация (Dot notation)
const a = person['firstName'];   // скобочная нотация (Bracket notation)
const a = person.children[0];    // обращение к свойству (массив)
const a = person.address.street; // обращение к свойству (объект)
const a = person.getName();      // обращение к методу
</v-code>

<!------------------------------------------------------------->
<h4>Обновление и удаление свойства</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
person.firstName = 'Tony';     // обновление свойства
person.height = 190;           // задание нового свойства
delete person.firstName;       // удаление свойства (можно удалить только ненаследованные свойства объекта, наследованные свойства удаляются у прототипа)
</v-code>

<!------------------------------------------------------------->
<h4>Добавление метода</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
person.greet = function() {
	console.log('hi');
}
</v-code>

<!------------------------------------------------------------->
<h4>Геттеры и сеттеры</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
person.fullName = 'Steve';  // сеттер
const a = person.fullName;  // геттер (result = Steve Stark)
</v-code>
</div><div id="objects-constructor"><h2>Конструктор создания объекта</h2>

<v-code lang="js" title="">
var apple = new Object();
apple.color = 'green';
apple.shape = 'round';
apple.describe = function() {
	return 'An apple is ' + this.color;
}

var a = apple.color;
var a = apple.describe();
</v-code>
</div><div id="objects-prototype"><h2>Создание прототипа</h2>

<ul class="list-point">
	<b>ПРОТОТИП</b>
	<li>У каждого <u>объекта</u> есть <u>прототип</u>, от которого он наследует <u>свойства</u> и <u>методы</u>. Если объект не включает в себя запрошенное свойство, JavaScript выполнит поиск этого свойства в прототипе объекта. При этом поиск будет выполняться по <u>цепочке прототипов</u> до тех пор, пока не будет найдено то, что нужно. Если же поиск успехом не увенчается, будет возвращена ошибка</li>
	<br>
</ul>

<v-code lang="js" title="">
// объект
var Human = {
	type: "Human",
	head: 1,
	legs: 2
};
// прототип
var Megahuman = <u-code>Object.create</u-code>(Human);
</v-code>

<v-two-code type="js;js" comment=";">
<template v-slot:first>
Megahuman.type; // Human
Megahuman.head; // 1
</template>
<template v-slot:last>
Megahuman.head = 2; // 2
Human.head;         // 1
</template>
</v-two-code>

<v-two-code type="js;js" comment=";">
<template v-slot:first>
Megahuman.hands = 10; // 10
Human.hands;          // undefined
</template>
<template v-slot:last>
Human.face;     // undefined
Megahuman.face; // undefined
</template>
</v-two-code>

<v-two-code type="js;js" comment=";">
<template v-slot:first>
Human.face = "okay"; // okay
Megahuman.face;      // okay
</template>
<template v-slot:last>
Megahuman.face = "awesome"; // awesome
Human.face;                 // okay
</template>
</v-two-code>

<v-code lang="js" title="">
Human.<u-code>isPrototypeOf</u-code>(Megahuman); // является ли объект Human прототипом для объекта Megahuman
</v-code>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Удаление свойств</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<v-code lang="js" title="">
// объект
var Human = {
	type: "Human",
	head: 1,
	legs: 2
};

// прототип
var Megahuman = Object.create(Human);
Megahuman.head = 2; // 2
delete Megahuman.head;
Megahuman.head;     // 1
</v-code>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Конструктор прототипа</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<v-code lang="js red" title="">
var Person = {
    constructor(name, age) {
        this.name = name;
        this.age = age;
        return this;
    },
    greet() {
        console.log('Hi ' + this.name);
    }
}

var person = Object.create(Person).constructor("Jack", 25);

var a = person.name;
person.greet();
</v-code>

<!------------------------------------------------------------->
<h4>Изменение конструктора</h4>
<!------------------------------------------------------------->
<v-code lang="js red" title="">
var WebDeveloper = Object.create(Person);

WebDeveloper.constructor = function(name, age, skills) {
    Person.constructor.apply(this, arguments);
    this.skills = skills || [];
    return this;
}
WebDeveloper.develop = function() {
    console.log('In Work');
}
var developer = Object.create(WebDeveloper).constructor('Jack', 25, ['html', 'css', 'js']);

console.log(developer.skills);
developer.develop();
console.log(developer.name);
</v-code>
</div><div id="objects-conversion"><h2>Преобразование объектов: toString и valueOf</h2>

<ul class="list-point">
	<li>В <u-text-define>логическом</u-text-define> контексте объект - всегда <u>true</u></li>
	<li>При <u-text-define>строковом</u-text-define> преобразовании объекта используется его метод <u>toString</u>. Он должен возвращать примитивное значение, причём не обязательно именно строку</li>
	<li>Для <u-text-define>численного</u-text-define> преобразования используется метод <u>valueOf</u>, который также может возвратить любое примитивное значение. У большинства объектов valueOf не работает (возвращает сам объект и потому игнорируется), при этом для численного преобразования используется toString</li>
</ul>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Логическое преобразование</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<v-code lang="js" title="">
// любой объект в логическом контексте – true, даже если это пустой массив [] или объект {}.
if ({} && []) {
	alert( "Все объекты - true!" ); // alert сработает
}
</v-code>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Строковое преобразование</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<v-code lang="js" title="">
const user = {
	name: 'Tony'
};

alert( user ); // [object Object]
</v-code>

<v-code lang="js" title="">
// eсли в объекте присутствует метод toString, который возвращает примитив, то он используется для преобразования
const obj = {
	name: 'Tony',
	<u-code>toString</u-code>() {
		return this.name;
	}
};

alert( obj ); // Tony
</v-code>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Численное преобразование</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<v-code lang="js" title="">
const room = {
	number: 777,
};

alert( +room ); // NaN
</v-code>

<ul class="list-point">
    <li>Для численного преобразования объекта используется метод <u>valueOf</u>, а если его нет – то <u>toString</u></li>
</ul>

<v-code lang="js" title="">
const room = {
	number: 777,
	<u-code>valueOf</u-code>() { return this.number; },
	<u-code>toString</u-code>() { return this.number; }
};

alert( +room );      // 777, вызвался valueOf
delete room.valueOf; // valueOf удалён
alert( +room );      // 777, вызвался toString
</v-code>
</div><div id="objects-samples"><h2>Примеры</h2>

<!------------------------------------------------------------->
<h4>Задание свойств объекта</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
const text = 'Some text';
function getId() {
	return 7;
}
let obj = {
	text,
	['prop_' + getId()]: 'some prop'
}
console.log(obj); // Object {text: 'Some text', prop_7: 'Some prop'}
</v-code>

<!------------------------------------------------------------->
<h4>Метод для разных объектов</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
var speak = function() {
	console.log(this.sound, this.name);
}
</v-code>

<v-code lang="js" title="">
var animal = {
	sound: 'Mrr',
	name: 'Cat',
	speak: speak
}

animal.speak(); // Mrr, Cat
</v-code>

<!------------------------------------------------------------->
<h4>Функция, возвращающая объект</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
function createCar(property, value) {
	return {
		[property]: value,
		['_' + property]: value,
		[property.toUpperCase()]: value,
		['get' + property]() {
			return this[property];
		}
	};
}
var a = createCar('vin', 1);
</v-code>
</div><div id="class-es6-info"><h2>Теория</h2>

<!------------------------------------------------------------->
<h4>Основное</h4>
<!------------------------------------------------------------->
<ul class="list-point">
	<li><u-text-define>Класс</u-text-define> - функция/шаблон, предназначенный для создания объектов и методов</li>
	<li>Класс должен отвечать за что-то одно (SOLID. Single Responsibility)</li>
	<li>Классы не засоряют глобальное пространство имен (объект window)</li>
	<li>В ES6 нельзя указывать класс до его объявления</li>
	<li>Методы добавляются в прототип</li>
	
	<hr>
	<li><u-text-define>Объект</u-text-define> - это экземпляр, представитель класса, т.е. объект, созданный по шаблону со свойствами и методами, указанными в классе</li>
	<li><u-text-define>Конструктор</u-text-define> - метод, который вызывается в момент создания объекта т.е. когда используется ключевое слово <u>new</u> он создает свойства и инициализирует, т.е. подготавливает объект к использованию. В классе может быть только 1 конструктор. Если не указать конструктор, то JS создаст пустой конструктор. Свойства указываются только в конструкторе</li>
</ul>

<!------------------------------------------------------------->
<h4>Статические свойства и методы</h4>
<!------------------------------------------------------------->
<ul class="list-point">
	<li><u>Статические свойства и методы</u> принадлежат самому классу, а не объектам, созданным на его основе</li>
	<li><u>Статические свойства</u> - используются для хранения вспомогательной информации</li>
	<li><u>Статические методы</u> - используются для создания вспомогательных функций. task.getDefaultColor(); нельзя вызывать напрямую</li>
</ul>

<!------------------------------------------------------------->
<h4>Геттеры и Сеттеры</h4>
<!------------------------------------------------------------->
<ul class="list-point">
	<li><u-text-define>Геттеры и Сеттеры</u-text-define> - аксессоры. Внутри класса выглядят и ведут себя как методы, а снаружи выглядят и ведут себя как свойства. Эти свойства-методы позволяют получить доступ и присвоить значения "настоящим" свойствам объекта, т.е. выступают в роли фильтра. Названия свойств get и set не должны совпадать с названиями основных свойств объекта</li>
</ul>

</div><div id="class-es6-create"><h2>Создание класса</h2>

<ul class="list-point">
	<b><u-code-text>constructor()</u-code-text></b> - функция-конструктор
</ul>

<v-code lang="js" title="">
// создание класса
class Task {
	constructor(name = '', color = Task.getDefaultColor()) {
		this.title = 'Выучить JS';
		this.name = name;
		this.color = color;
		this._done = false;
		Task.count += 1;
		console.log('Создание задачи');
		// сохранит лексический this конструктора
		this.increment = () => {
			this.count++;
		}
	}
	// свойство get связывает свойство объекта с функцией, которая будет вызываться 
	// при обращении к этому свойству
	get done() {
		return this._done === true ? 'Выполнена' : 'Не выполнена';
	}
	set done(value) {
		if(value != undefined && typeof value === 'boolean') {
			this._done = value;
		} else {
			console.error('Ошибка! Укажите значение true или false');
		}
	}
	complete() {
		this.done = true;
		console.log(`Задача ${this.title} выполнена`);
	}
	// статический метод, позволяющий получить значение цвета по умолчанию,
	// если цвет не был передан
	static getDefaultColor() {
		return 'Orange';
	}
}

let task = new Task('Новая задача'); // создание экземпляра класса (объекта)

Task.count = 0;                      // задание статического свойства
console.log(task instanceof Task);   // является ли объект представителем класса
console.log(task.title);             // обращение к свойству title
console.log(task.name);              // обращение к свойству name
console.log(task.color);             // обращение к свойству color, не передавая color
console.log(Task.count);             // обращение к статическому свойству count
task.complete();                     // обращение к методу complete
console.log(task.done, task._done);
</v-code>

<v-code lang="js" title="">
// переопределение стандартных методов
Task.prototype.toString = function() {
	return this.name;
}
</v-code>
</div><div id="class-es6-inherit"><h2>Наследование</h2>

<ul class="list-point">
	<b><u-code-text>super()</u-code-text></b> - вызов супер-конструктора
    <li>Если у подкласса нет конструктора, он будет использовать конструктор родителя</li>
    <li>Если подклассу указать конструктор, то он должен вызывать в начале конструктор родительского класса <u>super()</u></li>
    <li>метод <u>super()</u> позволяет наследовать свойства и методы из прототипа</li>
    <li><u>super()</u> должен вызываться первым объявлением <u>this</u></li>
</ul>

<v-code lang="js" title="">
// создание супер-класса
class Task {
	constructor(title, comment) {
		this._comment = comment; 
		this.title = title;
		this.done = false;
		Task.count += 1;
		console.log('create task');
	}
	get comment() {
		return this._comment;
	}
	set comment(value) {
		this._comment = value;
	}
	static getDefaultComment() {
		return 'Задача';
	}
	complete() {
		this.done = true;
		console.log(`Задача ${this.title} выполнена`);
	}
}
Task.count = 0; // общее кол-во задач
</v-code>

<v-code lang="js" title="">
// наследование между двумя классами
class SubTask extends Task {
	constructor(title, comment, parent) {
		super(title, comment); // использование конструктора из супер-класса
		super.complete();      // использование методов из супер-класса
		this.parent = parent;
		console.log('create subtask');
	}
	// переопределение родительского метода
	complete() {
		// this.done = true;
		// вызываем, если не сделали этого в конструкторе
		// можно обратиться к методу и получить значение при необходимости
		// super.complete();
		console.log(`Подзадача ${this.title} выполнена`);	
	}
}
</v-code>

<v-code lang="js" title="">
let task = new Task('Изучить JavaScript', 'Comment Task');
let subtask = new SubTask('Изучить ES6', 'Comment SubTask', task);

task.complete();
subtask.complete();

console.log(SubTask.getDefaultComment());
console.log(SubTask.count);
</v-code>
</div><div id="class-es6-class-properties"><h2>Class Properties - Свойства классов</h2>

<ul class="list-point">
    <li>Не является стандартом, для транспиляци нужен Babel</li>
</ul>

<ol class="list-num">
    <li><u>Инициализация свойств в теле класса</u> - когда свойства не зависят от внешних параметров, нет необходимости использовать конструктор</li>
    <li><u>Функции, автоматичеки привязанные к объекту, который создаеся</u> - вне зависимости от того как будет вызвана функция, <u>this</u> будет тот объект с которым она была создана. Применение: при регистрации функции как <u>EventListener</u></li>
</ol>

<v-code lang="js" title="">
class Counter {
	count = 1;

	inc = () => {
		this.count++;
		console.log(this.count);
	}
}

const cnt = new Counter();
console.log(cnt.count);    // => 1
cnt.inc();                 // => 2
setTimeout(cnt.inc, 1000); // => 3
</v-code>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Статические свойства и методы</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
    <li><u-code-text>static</u-code-text> - свойства, которые принадлежат классу, а не конкретным объектам</li>
</ul>

<v-code lang="js" title="">
class Counter {
	count = 1;

	inc = () => {
		this.count += Counter.incrementStep;
		console.log(this.count);
	}

	static incrementStep = 2;
	static incrementAll = function(arr) {
		arr.forEach((c) => c.inc());
	}
}

Counter.incrementAll([]);
</v-code>
</div><div id="class-es6-expression"><h2>Выражения классов</h2>

<ul class="list-point">
	<li>Классы являются функциями, поэтому класс можно объявить двумя способами</li>
</ul>

<!------------------------------------------------------------->
<h4>1. Class Declaration</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
class Task {
	constructor() {
		//
	}
}
</v-code>

<!------------------------------------------------------------->
<h4>2. Class Expression (выражение класса)</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
var Task = class Task {
	constructor() {
		console.log('Create a task');
	}
}

var SubTask = class extends Task {
	constructor() {
		super();
		console.log('Create a subtask');
	}
}

var task = new Task();
var subtask = new SubTask();
</v-code>



</div><div id="class-es5-functional-create"><h2>Объявление</h2>

<v-code lang="js" title="">
function User(name) {
	this.name = name;
	this.avatar = 'Photo';
	<u-code>this.deleteAvatar</u-code> = function() {
		this.avatar = null;
	}
}
var user = new User('Jack'); // => User {name: "Jack", avatar: "Photo", deleteAvatar: ƒ}
user.deleteAvatar();
console.log(user);           // => User {name: "Jack", avatar: null, deleteAvatar: ƒ}
</v-code></div><div id="class-es5-functional-methods-private"><h2>Приватный метод</h2>

<!------------------------------------------------------------->
<h4>Простой приватный метод и свойство</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
function User() {
    var privateProperty = 77;
	this.publicMethod = function() {
        <u-code>privateMethod</u-code>();
    }
    var <u-code>privateMethod</u-code> = function() {
        console.log('private method call' + privateProperty);
    }
}
var user = new User();
user.publicMethod(); // => 'private method call77
</v-code>

<!------------------------------------------------------------->
<h4>Сохранение this в замыкании</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
function User() {
    this.name = 'Tony';
    <u-code>var self = this;</u-code>
	this.publicMethod = function() {
        privateMethod();
    }
    var privateMethod = function() {
        console.log(<u-code>self.name</u-code>);
    }
}
var user = new User();
user.publicMethod(); // => 'Tony'
</v-code>

<!------------------------------------------------------------->
<h4>Стрелочная функция</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
function User() {
    this.name = 'Tony';
	this.publicMethod = function() {
        privateMethod();
    }
    var privateMethod = () => {
        console.log(this.name);
    }
}
var user = new User();
user.publicMethod(); 
</v-code>
</div><div id="class-es5-functional-getters-and-setters"><h2>Геттеры и сеттеры</h2>

<v-code lang="js" title="">
function User() {
    var count = 0;
	this.counter = function(i) {
        // вызов без параметра, значит режим геттера, возвращаем свойство
        if (!arguments.length) return count;
        count = i;
    }
}
var user = new User();
user.counter(77); 
user.counter(); // => 77
</v-code>
</div><div id="class-es5-functional-inherit"><h2>Наследование</h2>

<!------------------------------------------------------------->
<h4>Без аргументов</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
// Admin вызывает функцию User, передавая ей в качестве контекста this текущий объект
// User, в процессе выполнения, записывает в this свойства и методы, в данном случае this.name
function User() {
    this.name = 'Tony';
}
function Admin() {
    <u-code>User.call(this);</u-code>
    this.id = 77;
}
var admin = new Admin(); // => Admin {name: "Tony", id: 77}
</v-code>

<!------------------------------------------------------------->
<h4>Передача аргументов</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
function User(id, name) {
	this.id = id;
	this.name = name;
}
function Admin() {
	<u-code>User.apply(this, arguments);</u-code>
}
var admin = new Admin(77, 'Tony'); // => Admin {id: 77, name: "Tony"}
</v-code>

<!------------------------------------------------------------->
<h4>Переопределение наследованных методов</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
function User() {
    this.name = 'Tony';
    this.getName = function() {
        console.log(this.name);
    }
}
function Admin() {
    User.call(this);
    <u-code>var parentFunc = this.getName;</u-code>
    this.getName = function() {
        <u-code>parentFunc.call(this);</u-code> // то что было в this.getName
        console.log('Jack');   // добавлено в метод getName
    }
}
var admin = new Admin();
admin.getName(); // => 'Tony', 'Jack'
</v-code>
</div><div id="class-es5-prototype-info"><h2>Теория</h2>

<ul class="list-point">
	<b>Основное</b>
	<li><u-text-define>Класс</u-text-define> - <u>функция-конструктор</u> вместе с её <u>prototype</u>. Такой способ объявления классов называют <u>«прототипным стилем»</u>. При наследовании часть методов переопределяется, например, у массива Array есть свой toString</li>
	<li><u>Функциональный стиль</u> записывает в каждый объект и свойства и методы, а <u>прототипный</u> – только свойства</li>
	<li>При создании методов через прототип, мы теряем возможность использовать локальные переменные как приватные свойства, у них больше нет общей области видимости с конструктором</li>
</ul>
</div><div id="class-es5-prototype-methods"><h2>Добавление методов</h2>

<!------------------------------------------------------------->
<h4>Добавление метода в прототип класса</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
function User(name) {
	this.name = name;
	this.avatar = 'Photo';
}
<u-code>User.prototype.deleteAvatar</u-code> = function() {
	this.avatar = null;
}
var user = new User('Jack'); // => User {name: "Jack", avatar: "Photo", __proto__: deleteAvatar: ƒ () }
user.deleteAvatar();
console.log(user);           // => User {name: "Jack", avatar: null, __proto__: deleteAvatar: ƒ ()}
</v-code>

<!------------------------------------------------------------->
<h4>Изменение встроенных прототипов</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
<u-code>Object.prototype.myFunc</u-code> = function() {
    alert('myFunc');
}
let obj = {}
obj.myFunc(); // => 'myFunc'
</v-code>
</div><div id="class-es5-prototype-inherit"><h2>Наследование классов</h2>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Пример наследования</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<!------------------------------------------------------------->
<h4>1. Задание классов и прототипов</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
function User() {
	this.userName = 'userName';
}
User.prototype.userFunc = function() {
	alert('userFunc');
}
User.prototype.userProp = 'userProp';
</v-code>

<v-code lang="js" title="">
function Admin() {
	this.adminName = 'adminName';
}
</v-code>

<!------------------------------------------------------------->
<h4>2. Наследование. В прототип Admin добавлили всё из прототипа User</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
<u-code>Admin.prototype = Object.create(User.prototype);</u-code>
var admin = new Admin();
</v-code>

<!------------------------------------------------------------->
<h4>2. Наследование. Без добавления в прототип Admin (результат аналогичен)</h4>
<!------------------------------------------------------------->
<v-code lang="js red" title="">
var admin = Object.setPrototypeOf(new Admin(), User.prototype);
</v-code>

<!------------------------------------------------------------->
<h4>3. Добавление методов к Admin.prototype (при необходимости)</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
// добавлять после <u-code>Admin.prototype = Object.create(User.prototype)</u-code> чтобы не перетерло
Admin.prototype.adminFunc = function() {
	alert('adminFunc');
}
</v-code>

<!------------------------------------------------------------->
<h4>4. Переопределение метода родителя (при необходимости)</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
Admin.prototype.userFunc = function() {
	alert('not userFunc');
}
</v-code>

<!------------------------------------------------------------->
<h4>5. Вызов метода родителя внутри своего (при необходимости)</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
Admin.prototype.adminUserFunc = function() {
	// вызвать метод родителя передав ему текущие аргументы
	// если вызвать просто Animal.prototype.run(), то в качестве this функция run получит Animal.prototype, а это неверно, нужен текущий объект
	User.prototype.userFunc.apply(this, arguments);
}
</v-code>

<!------------------------------------------------------------->
<h4>6. Обращение к методам и свойствам</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
admin.userFunc(); // => alert('userFunc')
admin.userProp;   // => 'userProp'
</v-code>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Вызов конструктора родителя</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<v-code lang="js" title="">
function Animal(name) {
    this.name = name;
    this.speed = 0;
}
function Rabbit(name) {
    Animal.apply(this, arguments);
}
</v-code>
</div><div id="class-es5-prototype-mixins"><h2>Примеси (mixins)</h2>

<ul class="list-point">
	<li>Невозможно унаследовать от двух и более объектов, т.к. ссылка <u>__proto__</u> только одна</li>
	<li><u-text-define>Примесь (mixin)</u-text-define> – класс или объект, содержащий методы и свойства для реализации конкретного функционала. Используется для уточнения поведения других классов, не предназначен для самостоятельного использования</li>
	<li>Методы примеси активно используют <u>this</u> и предназначены именно для запуска в контексте «объекта-носителя примеси»</li>
	<li>Если какие-то из методов примеси не нужны – их можно перезаписать своими после копирования</li>
	<li>Для добавления примеси в класс – её просто «подмешивают» в прототип. «Подмешать» можно сколько угодно примесей, но если имена методов в разных примесях совпадают, то возможны конфликты.</li>
</ul>

<v-code lang="js" title="">
var mixinGreeting = {
    greet() {
        console.log(this.name);
    }
};
function User(name) {
    this.name = name;
}
for(var key in mixinGreeting) {
    <u-code>User.prototype[key] = mixinGreeting[key];</u-code>
}
new User('Tony').greet(); // => Tony
</v-code>
</div></div>
                </div>
            </div>
        
            <!-- OWN JAVASCRIPT !!! -->
            <script src="../src/libs/jquery.js"></script>
            <script src="../src/preloader/preloader.js"></script>
            <script src="../src-core/js/utils.js"></script>
            <script src="../src/js/main.js"></script>
        
            <!-- CSS -->
            <link rel="stylesheet" type="text/css" href="../src-core/css/basic.css">
            <link rel="stylesheet" type="text/css" href="../src/css/index.css">
        
            <!-- Libraries -->
            <script src="../src-core/libs/highlight/highlight.pack.js"></script>
            <script src="../src-core/libs/vue.js"></script>
        
            <!-- Custom Elements -->
            <script src="../src-core/components-web/custom-elements.js"></script>
            <link rel="stylesheet" type="text/css" href="../src-core/components-web/custom-elements.css">
        
            <!-- Vue.js Components -->
            <script src="../src-core/components-vue/vue-components.js"></script>
            <link rel="stylesheet" type="text/css" href="../src-core/components-vue/vue-components.css">
        
            <!-- JavaScript -->
            <script src="../src-core/js/init.js"></script>
        </body>
        </html>
    