<h2>Critical Rendering Path</h2>

<ul class="list-point">
	<li><u-text-define>Critical Rendering Path</u-text-define> (Критический путь рендеринга) - последовательность шагов, необходимая для первого отображения страницы (прежде чем HTML-ответ от сервера будет преобразован в пиксели на экране)</li>
	<li>Знания о CRP необходимы для улчшения производительности</li>
</ul>

<img src="/__img__/js/critical-rendering-path.png" class="center">

<!------------------------------------------------------------->
<h4>1. Построение DOM-дерева ✔️</h4>
<!------------------------------------------------------------->
<ul class="list-point">
	<li>Из полученного от сервера HTML-документа формируется DOM</li>
	<li><u-text-define>DOM</u-text-define> (объектная модель документа) дерево это объект, представляющий полностью разобранную HTML-страницу. Начиная с корневого элемента <u-code-text>html</u-code-text>, узлы создаются для каждого элемента/текста на странице. Элементы, вложенные в другие элементы, представлены в виде дочерних узлов, и каждый узел содержит полный набор атрибутов для этого элемента</li>
	<li>HTML может быть исполнен по частям. <b>Документ не должен быть загружен полностью</b> для того, чтобы контент начал появляться на странице</li>
</ul>

<!------------------------------------------------------------->
<h4>2. Построение CSSOM-дерева ❌</h4>
<!------------------------------------------------------------->
<ul class="list-point">
	<li>Загружаются и распознаются стили, формируется CSSOM</li>
	<li><u-text-define>CSSOM</u-text-define> (CSS Object Model) - объект, представляющий стили, связанные с DOM. Он выглядит так же как DOM, но с соответствующими стилями для каждого узла. Не имеет значения были ли стили объявлены явно или наследуются</li>
	<li>CSS считается <b>«блокирующим обработку ресурсом»</b>. Это значит, что Render-дерево не может быть построено без полного первоначального разбора CSS</li>
	<li>В отличии от HTML, CSS не может быть использован по частям в силу своей каскадной природы. Стили, описанные в документе ниже, могут переопределять и изменять стили, определённые ранее. Так что если мы начнём использовать CSS-стили до того, как будет разобрана таблица стилей, мы можем столкнуться с ситуацией, когда стили будут применяться неверно. Это означает, что для перехода к следующему шагу, необходимо полностью разобрать CSS</li>
</ul>

<!------------------------------------------------------------->
<h4>3. Запуск JavaScript ❌ при async ✔️</h4>
<!------------------------------------------------------------->
<ul class="list-point">
	<li>JavaScript является блокирующим ресурсом для парсера. Это означает, что JavaScript блокирует разбор самого HTML-документа</li>
	<li>Когда парсер доходит до тега <u-code-text>script</u-code-text> (не важно внутренний он или внешний), он останавливается, забирает файл (если он внешний) и запускает его</li>
	<li>JavaScript можно загружать асинхронно, указав атрибут <u-code-text>async</u-code-text>, для того, чтобы избежать блокировки парсера</li>
</ul>

<!------------------------------------------------------------->
<h4>4. Создание Render Tree</h4>
<!------------------------------------------------------------->
<ul class="list-point">
	<li><u-text-define>Render-дерево</u-text-define> - совокупность DOM и CSSOM</li>
	<li>Это дерево, которое даёт представление о том, что в конечном итоге будет отображено на странице. Это означает, что оно захватывает только видимый контент и не включает, например, элементы, которые были скрыты с помощью CSS-правила <u-code-text>display: none</u-code-text> или <u-code-text>&lt;head&gt;</u-code-text></li>
</ul>

<!------------------------------------------------------------->
<h4>5. Layout (генерация раскладки)</h4>
<!------------------------------------------------------------->
<ul class="list-point">
	<li><u-text-define>Раскладка</u-text-define> - для каждого элемента Render Tree рассчитывается его положение на странице</li>
	<li>Браузеры используют поточный метод (<u>flow</u>), при котором в большинстве случаев достаточно одного прохода для размещения всех элементов (для таблиц проходов требуется больше)</li>
	<hr>
	<li>Определяется размер видимой области документа (<u-code-text>viewport</u-code-text>), которая обеспечивает контекст для стилей CSS, зависимых от него, например, проценты или единицы viewport</li>
	<li>Размер viewport определяется метатэгом, находящемся в <u-code-text>head</u-code-text> документа или, если тэг не представлен, будет использовано стандартное значение viewport 980px</li>
</ul>

<!------------------------------------------------------------->
<h4>6. Painting (отрисовка в браузере)</h4>
<!------------------------------------------------------------->
<ul class="list-point">
	<li><u-text-define>Отрисовка</u-text-define> - видимый контент страницы может быть преобразован в пиксели, чтобы появиться на экране</li>
	<li>Время, которое займет этот этап, зависит как от величины DOM, так и от того, какие стили применяются. Некоторые стили требуют больше усилий, чтобы быть применёнными, чем другие. Например, сложное градиентное фоновое изображение потребует больше времени, чем простой сплошной цвет на фоне</li>
</ul>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Chrome Dev Tools</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<v-code lang="bash" title="">
Chrome Dev Tools -> Performance -> Event Log
Chrome Dev Tools -> Сеть -> Запись активности
</v-code>

<ol class="list-num">
	<li><b>Send Request</b> - GET-запрос, отправленный для index.html</li>
	<li><b>Parse HTML and Send Request</b> - начать разбор HTML и построение DOM. Отправить GET запрос для style.css и main.js</li>
	<li><b>Parse Stylesheet</b> - CSSOM, созданный для style.css</li>
	<li><b>Evaluate Script</b> - вычислить (выполнить) main.js</li>
	<li><b>Layout</b> - генерация раскладки, основанной на значении метатега viewport</li>
	<li><b>Paint</b> - отрисовка пикселей в документе</li>
</ol>

