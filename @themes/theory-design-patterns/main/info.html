<h2>Паттерны проектирования</h2>

<u-link-wrapper>
    <a href="https://refactoring.guru/ru/design-patterns/catalog" target="_blank">Refactoring Guru. Каталог паттернов проектирования</a>
    <hr class="small">
    <a href="https://habr.com/ru/company/ruvds/blog/427293/" target="_blank">Паттерны проектирования в JavaScript</a>
    <a href="https://medium.com/@marina.kovalyova/java-script-design-patterns-569c627d25f9" target="_blank">Шаблоны проектирования в JavaScript</a>
</u-link-wrapper>

<ul class="list-point">
    <li><u-text-define>Design Patterns</u-text-define> (паттерны проектирования) - это часто встречающееся решение определённой проблемы при проектировании архитектуры программ</li>
    <li>В отличие от готовых функций или библиотек, паттерн нельзя просто взять и скопировать в программу. Паттерн представляет собой не какой-то конкретный код, а общую концепцию решения той или иной проблемы, которую нужно будет ещё подстроить под нужды программы</li>
    <li>Паттерны часто путают с <u>алгоритмами</u>, ведь оба понятия описывают типовые решения каких-то известных проблем. Но если алгоритм - это чёткий набор действий, то паттерн - это высокоуровневое описание решения, реализация которого может отличаться в  разных программах</li>
</ul>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Classification of Design Patterns</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<!------------------------------------------------------------->
<h4>1. Creational (Порождающие)</h4>
<!------------------------------------------------------------->
<u-message-ok>
    <ul class="list-flat">
        <li><u-text-define>Порождающие</u-text-define> - отвечают за удобное и безопасное создание новых объектов или даже целых семейств объектов без внесения в программу лишних зависимостей</li>
    </ul>
</u-message-ok>

<ul class="list-point">
    <li><u-text-accent>Factory Method</u-text-accent> (Фабричный метод) - определяет общий интерфейс для создания объектов в суперклассе, позволяя подклассам изменять тип создаваемых объектов</li>
    <li><u-text-accent>Abstract Factory</u-text-accent> (Абстрактная фабрика) - позволяет создавать семейства связанных объектов, не привязываясь к конкретным классам создаваемых объектов. Интерфейс, который группирует другие фабрики, логически связанные друг с другом</li>
    <li><u-text-accent>Builder</u-text-accent> (Строитель) - позволяет создавать сложные объекты пошагово. Строитель даёт возможность использовать один и тот же код строительства для получения разных представлений объектов</li>
    <li><u-text-accent>Prototype</u-text-accent> (Прототип) - позволяет копировать объекты, не вдаваясь в подробности их реализации</li>
    <li><u-text-accent>Singleton</u-text-accent> (Одиночка) - гарантирует, что у класса есть только один экземпляр, и предоставляет к нему глобальную точку доступа</li>
</ul>

<!------------------------------------------------------------->
<h4>2. Structural (Структурные)</h4>
<!------------------------------------------------------------->
<u-message-ok>
    <ul class="list-flat">
        <li><u-text-define>Структурные</u-text-define> - отвечают за построение удобных в поддержке иерархий классов. Показывают различные способы построения связей между объектами</li>
    </ul>
</u-message-ok>

<ul class="list-point">
    <li><u-text-accent>Adapter</u-text-accent> (Адаптер) - позволяет объектам с несовместимыми интерфейсами работать вместе</li>
    <li><u-text-accent>Bridge</u-text-accent> (Мост) - разделяет один или несколько классов на две отдельные иерархии - абстракцию и реализацию, позволяя изменять их независимо друг от друга</li>
    <li><u-text-accent>Composite</u-text-accent> (Компоновщик) - позволяет сгруппировать объекты в древовидную структуру, а затем работать с ними так, как будто это единичный объект</li>
    <li><u-text-accent>Decorator</u-text-accent> (Декоратор) - позволяет динамически добавлять объектам новую функциональность, оборачивая их в полезные «обёртки»</li>
    <li><u-text-accent>Facade</u-text-accent> (Фасад) - предоставляет простой интерфейс к сложной системе классов, библиотеке или фреймворку</li>
    <li><u-text-accent>Flyweight</u-text-accent> (Легковес) - позволяет вместить бóльшее количество объектов в отведённую оперативную память. Легковес экономит память, разделяя общее состояние объектов между собой, вместо хранения одинаковых данных в каждом объекте</li>
    <li><u-text-accent>Proxy</u-text-accent> (Заместитель) - позволяет подставлять вместо реальных объектов специальные объекты-заменители. Эти объекты перехватывают вызовы к оригинальному объекту, позволяя сделать что-то до или после передачи вызова оригиналу</li>
</ul>

<!------------------------------------------------------------->
<h4>3. Behavioral (Поведенческие)</h4>
<!------------------------------------------------------------->
<u-message-ok>
    <ul class="list-flat">
        <li><u-text-define>Поведенческие</u-text-define> - решают задачи эффективного и безопасного взаимодействия между объектами программы</li>
    </ul>
</u-message-ok>

<ul class="list-point">
    <li><u-text-accent>Observer</u-text-accent> (Наблюдатель) - создаёт механизм подписки, позволяющий одним объектам следить и реагировать на события, происходящие в других объектах</li>
    <li><u-text-accent>Chain of Responsibility</u-text-accent> (Цепочка обязанностей) - позволяет передавать запросы последовательно по цепочке обработчиков. Каждый последующий обработчик решает, может ли он обработать запрос сам и стоит ли передавать запрос дальше по цепи</li>
    <li><u-text-accent>Command</u-text-accent> (Команда) - превращает запросы в объекты, позволяя передавать их как аргументы при вызове методов, ставить запросы в очередь, логировать их, а также поддерживать отмену операций</li>
    <li><u-text-accent>Iterator</u-text-accent> (Итератор) - даёт возможность последовательно обходить элементы составных объектов, не раскрывая их внутреннего представления</li>
    <li><u-text-accent>Mediator</u-text-accent> (Посредник) - позволяет уменьшить связанность множества классов между собой, благодаря перемещению этих связей в один класс-посредник</li>
    <li><u-text-accent>Memento</u-text-accent> (Снимок) - позволяет делать снимки состояния объектов, не раскрывая подробностей их реализации. Затем снимки можно использовать, чтобы восстановить прошлое состояние объектов</li>
    <li><u-text-accent>State</u-text-accent> (Состояние) - позволяет объектам менять поведение в зависимости от своего состояния. Извне создаётся впечатление, что изменился класс объекта</li>
    <li><u-text-accent>Strategy</u-text-accent> (Стратегия) - пределяет семейство схожих алгоритмов и помещает каждый из них в собственный класс, после чего алгоритмы можно взаимозаменять прямо во время исполнения программы</li>
    <li><u-text-accent>Template Method</u-text-accent> (Шаблонный метод) - определяет скелет алгоритма, перекладывая ответственность за некоторые его шаги на подклассы. Паттерн позволяет подклассам переопределять шаги алгоритма, не меняя его общей структуры</li>
    <li><u-text-accent>Visitor</u-text-accent> (Посетитель) - позволяет создавать новые операции, не меняя классы объектов, над которыми эти операции могут выполняться</li>
</ul>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Назначение</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
    <li><u>Проверенные решения</u>. Использовать готовые решения быстрее, чем писать каждый раз заново</li>
    <li><u>Стандартизация кода</u>. Меньше просчётов при проектировании, используя типовые унифицированные решения, т.к. большинство скрытых проблем уже найдено</li>
    <li><u>Общий программистский словарь</u>. Другие разработчики узнают паттерн по названию</li>
</ul>
