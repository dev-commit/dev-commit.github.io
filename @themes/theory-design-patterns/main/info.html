<h2>Паттерны проектирования</h2>

<u-link-wrapper>
    <a href="https://refactoring.guru/ru/design-patterns/catalog" target="_blank">Refactoring Guru. Каталог паттернов проектирования</a>
    <hr class="small">
    <a href="https://www.youtube.com/playlist?list=PLNkWIWHIRwMGzgvuPRFkDrpAygvdKJIE4" target="_blank">YouTube Playlist: JavaScript Паттерны</a>
</u-link-wrapper>

<ul class="list-point">
    <li><u-text-define>Design Patterns</u-text-define> (паттерны проектирования) - это часто встречающееся решение определённой проблемы при проектировании архитектуры программ</li>
    <li>В отличие от готовых функций или библиотек, паттерн нельзя просто взять и скопировать в программу. Паттерн представляет собой не какой-то конкретный код, а общую концепцию решения той или иной проблемы, которую нужно будет ещё подстроить под нужды программы</li>
    <li>Паттерны часто путают с <u>алгоритмами</u>, ведь оба понятия описывают типовые решения каких-то известных проблем. Но если алгоритм - это чёткий набор действий, то паттерн - это высокоуровневое описание решения, реализация которого может отличаться в  разных программах</li>
</ul>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Classification of Design Patterns</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<!------------------------------------------------------------->
<h4>1. Creational (Порождающие)</h4>
<!------------------------------------------------------------->
<u-message-ok>
    <ul class="list-flat">
        <li><u-text-define>Порождающие</u-text-define> - отвечают за удобное и безопасное создание новых объектов или даже целых семейств объектов без внесения в программу лишних зависимостей</li>
    </ul>
</u-message-ok>

<ul class="list-point">
    <li><b>Singleton</b> (Одиночка) - гарантирует, что у класса есть только один экземпляр, и предоставляет к нему глобальную точку доступа</li>
    <li><b>Constructor</b> (Конструктор) - создание новых объектов определенного типа</li>
    <li><b>Builder</b> (Строитель) - позволяет создавать сложные объекты пошагово. Строитель даёт возможность использовать один и тот же код строительства для получения разных представлений объектов</li>
    <li><b>Prototype</b> (Прототип) - можно создавать объекты, взяв за основу другие объекты</li>
    <li><b>Factory Method</b> (Фабричный метод) - определяет общий интерфейс для создания объектов в суперклассе, позволяя подклассам изменять тип создаваемых объектов (их значения)</li>
    <li><b>Abstract Factory</b> (Абстрактная фабрика) - интерфейс, который группирует другие фабрики, логически связанные друг с другом. Помогает создавать объекты со схожей структурой, но разными данными</li>
</ul>

<!------------------------------------------------------------->
<h4>2. Structural (Структурные)</h4>
<!------------------------------------------------------------->
<u-message-ok>
    <ul class="list-flat">
        <li><u-text-define>Структурные</u-text-define> - отвечают за построение удобных в поддержке иерархий классов. Показывают различные способы построения связей между объектами</li>
        <li>Внедрение нового функционала, без конфликтов со старым</li>
    </ul>
</u-message-ok>

<ul class="list-point">
    <li><b>Decorator</b> (Декоратор) - позволяет динамически добавлять объектам новую функциональность, оборачивая их в полезные «обёртки»</li>
    <li><b>Adapter</b> (Адаптер) - позволяет объектам с несовместимыми интерфейсами работать вместе</li>
    <li><b>Facade</b> (Фасад) - предоставляет простой интерфейс к сложной системе классов, библиотеке или фреймворку</li>
    <li><b>Flyweight</b> (Легковес) - позволяет вместить бóльшее количество объектов в отведённую оперативную память. Легковес экономит память, разделяя общее состояние объектов между собой, вместо хранения одинаковых данных в каждом объекте</li>
    <li><b>Proxy</b> (Заместитель) - позволяет подставлять вместо реальных объектов специальные объекты-заменители. Эти объекты перехватывают вызовы к оригинальному объекту, позволяя сделать что-то до или после передачи вызова оригиналу</li>
    <hr>
    <li><b>Bridge</b> (Мост) - разделяет один или несколько классов на две отдельные иерархии - абстракцию и реализацию, позволяя изменять их независимо друг от друга</li>
    <li><b>Composite</b> (Компоновщик) - позволяет сгруппировать объекты в древовидную структуру, а затем работать с ними так, как будто это единичный объект</li>
</ul>

<!------------------------------------------------------------->
<h4>3. Behavioral (Поведенческие)</h4>
<!------------------------------------------------------------->
<u-message-ok>
    <ul class="list-flat">
        <li><u-text-define>Поведенческие</u-text-define> - эффективное и безопасное взаимодействие между объектами разного типа</li>
    </ul>
</u-message-ok>

<ul class="list-point">
    <li><b>Observer</b> (Наблюдатель) - создаёт механизм подписки, позволяющий одним объектам следить и реагировать на события, происходящие в других объектах</li>
    <li><b>Chain of Responsibility</b> (Цепочка обязанностей) - позволяет передавать запросы последовательно по цепочке обработчиков. Каждый последующий обработчик решает, может ли он обработать запрос сам и стоит ли передавать запрос дальше по цепи</li>
    <li><b>Command</b> (Команда) - превращает запросы в объекты, позволяя передавать их как аргументы при вызове методов, ставить запросы в очередь, логировать их, а также поддерживать отмену операций</li>
    <li><b>Iterator</b> (Итератор) - даёт возможность последовательно обходить элементы составных объектов, не раскрывая их внутреннего представления</li>
    <li><b>Mediator</b> (Посредник) - позволяет уменьшить связанность множества классов между собой, благодаря перемещению этих связей в один класс-посредник</li>
    <li><b>State</b> (Состояние) - позволяет объектам менять поведение в зависимости от своего состояния. Извне создаётся впечатление, что изменился класс объекта</li>
    <li><b>Strategy</b> (Стратегия) - пределяет семейство схожих алгоритмов и помещает каждый из них в собственный класс, после чего алгоритмы можно взаимозаменять прямо во время исполнения программы</li>
    <li><b>Template Method</b> (Шаблонный метод) - определяет скелет алгоритма, перекладывая ответственность за некоторые его шаги на подклассы. Паттерн позволяет подклассам переопределять шаги алгоритма, не меняя его общей структуры</li>
    <hr>
    <li><b>Memento</b> (Снимок) - позволяет делать снимки состояния объектов, не раскрывая подробностей их реализации. Затем снимки можно использовать, чтобы восстановить прошлое состояние объектов</li>
    <li><b>Visitor</b> (Посетитель) - позволяет создавать новые операции, не меняя классы объектов, над которыми эти операции могут выполняться</li>
</ul>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Назначение</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
    <li><u>Проверенные решения</u>. Использовать готовые решения быстрее, чем писать каждый раз заново</li>
    <li><u>Стандартизация кода</u>. Меньше просчётов при проектировании, используя типовые унифицированные решения, т.к. большинство скрытых проблем уже найдено</li>
    <li><u>Общий программистский словарь</u>. Другие разработчики узнают паттерн по названию</li>
</ul>
