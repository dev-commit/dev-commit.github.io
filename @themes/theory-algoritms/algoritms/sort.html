<h2>Алгоритмы сотрировки (Sorting Algorithms)</h2>

<!------------------------------------------------------------->
<h4>Метод sort в JavaScript</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
arr.sort(function(a, b){ 
    if(a < b) {
        return 1;
    } else {
        return -1
    }
});
</v-code>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Виды алгоритмов</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ol class="list-num">
    <li>Пузырьковая сортировка (Bubble sort)</li>
    <li>Сортировка выбором (Selection sort)</li>
    <li>Сортировка вставками (Insertion sort)</li>
    <li>Быстрая сортировка</li>
    <li>Сортировка слиянием (Merge Sort)</li>
</ol>

<!------------------------------------------------------------->
<h4>1. Пузырьковая сортировка</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li><b>Суть</b>: сравнение соседних элементов и их обмене, если они находятся не в надлежащем порядке. Неоднократно выполняя это действие, мы заставляем наибольший элемент "всплывать" к концу массива. Следующий проход приведет к всплыванию второго наибольшего элемента, и так до тех пор, пока после n-1 итерации массив не будет полностью отсортирован</li>
    <li><b>Плюс</b>: простая реализация</li>
    <li><b>Минусы</b>: эффективен он лишь для небольших массивов</li>
    <li><b>Сложность</b>: O(N<sup>2</sup>)</li>
</ul>

<v-code lang="js" title="">
function BubbleSort(A){
    const n = A.length;
    for (let i = 0; i < n-1; i++) { 
        for (let j = 0; j < n-1-i; j++) { 
            if (A[j+1] < A[j]) { 
                const t = A[j+1]; A[j+1] = A[j]; A[j] = t; 
            }
        }
    }                     
    return A;
}
</v-code>

<!------------------------------------------------------------->
<h4>2. Сортировка выбором</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li><b>Суть</b>: начинается с поиска наименьшего элемента в списке и обмена его с первым элементом (таким образом, наименьший элемент помещается в окончательную позицию в отсортированном массиве). Затем мы сканируем массив, начиная со второго элемента, в поисках наименьшего среди оставшихся n-1 элементов и обмениваем найденный наименьший элемент со вторым, т.е. помещаем второй наименьший элемент в окончательную позицию в отсортированном массиве. В общем случае, при i-ом проходе по списку (0<=i<=n-2) алгоритм ищет наименьший элемент среди последних n-i элементов и обменивает его с A[i]. После выполнения n-1 проходов список оказывается отсортирован</li>
</ul>

<v-code lang="js" title="">
function SelectionSort(A) {
    const n = A.length;
    for (let i = 0; i < n - 1; i++) {
        const min = i;
        for (let j = i + 1; j < n; j++) {
            if (A[j] < A[min]) min = j;
        }
        const t = A[min];
        A[min] = A[i];
        A[i] = t;
    }
    return A;
}
</v-code>

<!------------------------------------------------------------->
<h4>3. Сортировка вставками</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li><b>Суть</b>: На каждом шаге алгоритма сортировки встаками выбирается один из элементов входного массива и вставляется на нужную позицию в уже отсортированном массиве, до тех пор, пока входных элементы не будут исчерпана. Метод выбора очередного элемента из исходного массива произволен; может использоваться практически любой алгоритм выбора</li>
</ul>

<v-code lang="js" title="">
function InsertionSort(A) {
    const n = A.length;
    for (let i = 0; i < n; i++) {
        const v = A[i],
            j = i - 1;
        while (j >= 0 && A[j] > v) {
            A[j + 1] = A[j];
            j--;
        }
        A[j + 1] = v;
    }
    return A;
}
</v-code>

<!------------------------------------------------------------->
<h4>4. Быстрая сортировка</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
function QuickSort(A) {
    if (A.length == 0) return [];
    const a = [],
        b = [],
        p = A[0];
    for (let i = 1; i < A.length; i++) {
        if (A[i] < p) a[a.length] = A[i];
        else b[b.length] = A[i];
    }
    return QuickSort(a).concat(p, QuickSort(b));
}
</v-code>
