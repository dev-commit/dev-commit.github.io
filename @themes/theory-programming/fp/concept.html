<!-- TODO:
<f-search>Программирование -> ФП -> Концепции</f-search>
-->

<h2>Концепции</h2>

<!------------------------------------------------------------->
<h4>Чистые функции (Pure Functions)</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li><u-text-define>Чистые функции</u-text-define></li>
    <li>Возвращает один и тот же результат для одинаковых входных данных</li>
    <li>Не изменяет входные данные (иммутабельность)</li>
    <li>Не зависит от внешнего состояния (базы данных, DOM или глобальной переменной)</li>
    <li>Не имеет побочных эффектов (side effects): не влияют на состояние программы</li>
    <li>Чистые функции могут вызывать только чистые функции</li>
</ul>

<h5>Условия</h5>
<ul class="list-point">
    <li><u>Детерменированная</u> - для одного и того же набора входных значений возвращает одинаковый результат</li>
    <li><u>Без побочных эффектов</u> В императивных языках некоторые функции в процессе выполнения своих вычислений могут модифицировать значения глобальных переменных, осуществлять операции ввода-вывода, реагировать на исключительные ситуации, вызывая их обработчики. Они называются функциями с побочными эффектами</li>
    <li>Для замены циклов в JS можно использовать map и reduce</li>
</ul>

<h5>Пример</h5>
<ul class="list-point">
    <li>Функция, которая вызвала <em>console.log()</em> не является чистой</li>
    <li><em>console.log()</em> имеет Side effect, т.к. изменяет состояние консоли</li>
</ul>

<!------------------------------------------------------------->
<h4>Функции высшего порядка (Higher Order Functions)</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li><u-text-define>Функции высшего порядка</u-text-define> - функция принимающая в качестве аргументов другие функции или возвращающая другую функцию в качестве результата</li>
</ul>

<v-code lang="js" title="">
function higherOrderFunction(param, callback) {
    return callback(param)
}
</v-code>

<!------------------------------------------------------------->
<h4>Иммутабельность</h4>
<!------------------------------------------------------------->
<ul class="list-point">
	<li><u-text-define>Иммутабельность</u-text-define> - свойство объектов не изменяться (н-р строка. строку нельзя поменять на месте, для изменения нужно создать новую строку). Применяется для списков, словарей и т.д. Иммутабельный список - список в который нельзя добавить / удалить элемент, можно только итерироваться по ним. Можно создать новый список который содежит все элементы +1, при этом старый остается валадным</li>
</ul>

<!------------------------------------------------------------->
<h4>Каррирование функций</h4>
<!------------------------------------------------------------->
<ul class="list-point">
	<li><u-text-define>Каррирование функций</u-text-define> - все функции могут быть от одного аргумента. Преобразование функции от пары аргументов в функцию, берущую свои аргументы по одному</li>
</ul>

<!------------------------------------------------------------->
<h4>Функции первого класса</h4>
<!------------------------------------------------------------->
<ul class="list-point">
	<li><u-text-define>Функции первого класса</u-text-define> - функция трактуются как объект, то есть может быть передана другим функциям и ее можно вернуть из функций. Так же ее можно присваивать переменным <u-code-light>const foo = function() {}</u-code-light></li>
</ul>

<!------------------------------------------------------------->
<h4>Рекурсия</h4>
<!------------------------------------------------------------->
<ul class="list-point">
	<li><u-text-define>Рекурсия</u-text-define> (рекурсивные функции) вызывают сами себя, позволяя операции выполняться снова и снова. В функциональных языках цикл обычно реализуется в виде рекурсии</li>
</ul>

<!------------------------------------------------------------->
<h4>Лямбда-исчисление</h4>
<!------------------------------------------------------------->
<ul class="list-point">
	<li><u-text-define>Лямбда-исчисление</u-text-define> - механизм «анонимных функций» (Callback-функций), которые можно определить прямо в том месте, где они используются, и которые имеют доступ к локальным переменным текущей функции</li>
</ul>
