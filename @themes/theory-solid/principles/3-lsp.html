<h2>3. The Liskov Substitution Principle</h2>

<ul class="list-point">
    <li><u-text-define>The Liskov Substitution Principle</u-text-define> - Принцип подстановки Барбары Лиско́в</li>
    <li>Объекты в программе должны быть заменяемыми на экземпляры их подтипов без изменения правильности выполнения программы</li>
    <hr>
    <li>Наследующий класс должен дополнять, а не изменять базовый класс и не должен противоречить поведению, заданному базовым классом</li>
    <li>Необходимо чтобы подклассы могли служить заменой для своих суперклассов</li>
    <li>Если гарантируется функциональность для базового класса, то гарантируется функциональность для всех его потомков (поведение программы не изменится)</li>
    <li>Функции, которые используют базовый тип, должны уметь взаимодействовать с ним и его подтипами, при этом не зная ничего про это</li>
    <li>Поведение в методах-наследниках менять нельзя</li>
</ul>


Принцип служит для того, чтобы делать поведение класса более разнообразным, не вмешиваясь в текущие операции, которые он выполняет. Благодаря этому вы избегаете ошибок в тех фрагментах кода, где задействован этот класс.

Если П является подтипом Т, то любые объекты типа Т, присутствующие в программе, могут заменяться объектами типа П без негативных последствий для функциональности программы.

В случаях, когда класс-потомок не способен выполнять те же действия, что и класс-родитель, возникает риск появления ошибок.

Если у вас имеется класс и вы создаете на его базе другой класс, исходный класс становится родителем, а новый – его потомком. Класс-потомок должен производить такие же операции, как и класс-родитель. Это называется наследственностью.

Необходимо, чтобы класс-потомок был способен обрабатывать те же запросы, что и родитель, и выдавать тот же результат. Или же результат может отличаться, но при этом относиться к тому же типу. На картинке это показано так: класс-родитель подаёт кофе (в любых видах), значит, для класса-потомка приемлемо подавать капучино (разновидность кофе), но неприемлемо подавать воду.

Если класс-потомок не удовлетворяет этим требованиям, значит, он слишком сильно отличается от родителя и нарушает принцип.



<!------------------------------------------------------------->
<h5>Результат применения</h5>
<!------------------------------------------------------------->
<ul class="list-point">
    <li>Обеспечение постоянства: класс-родитель и класс-потомок могут использоваться одинаковым образом без нарушения работы программы.</li>
</ul>

<!------------------------------------------------------------->
<h5>Принцип помогает</h5>
<!------------------------------------------------------------->
<ul class="list-point">
    <li>Выявлять проблемные абстракции и скрытые связи между сущностями</li>
    <li>Делать поведение модулей предсказуемым</li>
    <li>Вводить ограничение на наследование, чтобы потомки не противоречили базовому поведению</li>
</ul>

<!------------------------------------------------------------->
<h5>Реализация</h5>
<!------------------------------------------------------------->
<ul class="list-point">
    <li>Общий интерфейс для обоих классов</li>
    <li>Вместо наследования одного класса от другого использовать интерфейс</li>
</ul>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Примеры</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<!------------------------------------------------------------->
<h4>Пример 1</h4>
<!------------------------------------------------------------->

<v-two-border title="Fine;Badly"><template v-slot:first>
<ul class="list-point">
    <li>Нужно правильно выбирать слои абстракции</li>
    <li>Просто наследоваться от человека некорректно</li>
    <li>Добавляем еще один уровень абстракции в виде базовых классов</li>
</ul>

<v-code lang="js border" title="">
class Person {
    //
}
class Member extends Person {
    access() {
        console.log('Есть доступ');
    }
}
class Guest extends Person {
    isGuest = true;
}
</v-code>
<v-code lang="js border" title="">
class Frontend extends Member {}
class Backend extends Member {}

class PersonFromDifferentCompany extends Guest {
    access() {
        throw new Error('Нет доступа');
    }
}
</v-code>
<v-code lang="js border" title="">
// функция должна работать со всеми классами-наследниками
// от Person
function openSecretDoor(member) {
    member.access();
}

openSecretDoor(new Frontend());
openSecretDoor(new Backend());
// должен быть member
// openSecretDoor(new PersonFromDifferentCompany());
</v-code>

</template><template v-slot:last>
<v-code lang="js" title="">
class Person {
    access() {
        console.log('Есть доступ');
    }
}
</v-code>
<v-code lang="js" title="">
class Frontend extends Person {}
class Backend extends Person {}

class PersonFromDifferentCompany extends Person {
    access() {
        throw new Error('Нет доступа');
    }
}
</v-code>
<v-code lang="js" title="">
// функция должна работать со всеми классами-наследниками
// от Person
function openSecretDoor(person) {
    person.access();
}

openSecretDoor(new Frontend());
openSecretDoor(new Backend());
// получаем ошибку. нарушение принципа [L] LSP
openSecretDoor(new PersonFromDifferentCompany());
</v-code>

</template></v-two-border>

<!------------------------------------------------------------->
<h4>Пример 2</h4>
<!------------------------------------------------------------->

<v-two-border title="Fine;Badly"><template v-slot:first>
<v-code lang="js border" title="Базовые классы">
class Component {}
class ComponentWithTemplate extends Component {
    render() {
        return `&lt;div&gt;Component&lt;/div&gt;`
    }
}
class HigherOrderComponent extends Component {}
</v-code>
<v-code lang="js border" title="Наследники">
class HeaderComponent extends ComponentWithTemplate {
    onInit() {}
}
class FooterComponent extends ComponentWithTemplate {
    afterInit() {}
}
class HOC extends HigherOrderComponent {
    render() {
        throw new Error('Рендер невозможен');
    }
}
</v-code>
<v-code lang="js border" title="Функция">
function renderComponent(component) {
    console.log(component.render());
}

renderComponent(new HeaderComponent());
renderComponent(new FooterComponent());
// вызов невозможен
// renderComponent(new HOC());
</v-code>

</template><template v-slot:last>
<v-code lang="js" title="Базовый класс">
class Component {
    render() {
        return `&lt;div&gt;Component&lt;/div&gt;`
    }
}
</v-code>
<v-code lang="js" title="Наследники">
class HeaderComponent extends Component {
    onInit() {}
}
class FooterComponent extends Component {
    afterInit() {}
}
class HOC extends Component {
    // не должно быть реализации метода render
    render() {
        throw new Error('Рендер невозможен');
    }
}
</v-code>
<v-code lang="js" title="Функция">
function renderComponent(component) {
    console.log(component.render());
}

renderComponent(new HeaderComponent());
renderComponent(new FooterComponent());
// ошибка
renderComponent(new HOC());
</v-code>

</template></v-two-border>
