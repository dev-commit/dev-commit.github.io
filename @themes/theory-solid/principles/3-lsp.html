<h2>3. The Liskov Substitution Principle</h2>

<ul class="list-point">
    <li><u-text-define>The Liskov Substitution Principle</u-text-define> - Принцип подстановки Барбары Лиско́в</li>
    <li>Объекты в программе должны быть заменяемыми на экземпляры их подтипов без изменения правильности выполнения программы. Если П является подтипом Т, то любые объекты типа Т, присутствующие в программе, могут заменяться объектами типа П без негативных последствий для функциональности программы</li>
    <li>В случаях, когда класс-потомок не способен выполнять те же действия, что и класс-родитель, возникает риск появления ошибок</li>
    
    <hr>

    <li>Наследующий класс должен дополнять, а не изменять базовый класс и не должен противоречить поведению, заданному базовым классом</li>
    <li>Необходимо чтобы подклассы могли служить заменой для своих суперклассов</li>
    <li>Если гарантируется функциональность для базового класса, то гарантируется функциональность для всех его потомков (поведение программы не изменится)</li>
    <li>Функции, которые используют базовый тип, должны уметь взаимодействовать с ним и его подтипами, при этом не зная ничего про это</li>
    <li>Поведение в методах-наследниках менять нельзя</li>
</ul>

<!------------------------------------------------------------->
<h5>Результат применения</h5>
<!------------------------------------------------------------->
<ul class="list-point">
    <li>Позволяет гарантировать, что любой созданный нами подкласс будет корректно использоваться ранее реализованными модулями, которые работали с классом-родителем</li>
</ul>

<!------------------------------------------------------------->
<h5>Принцип помогает</h5>
<!------------------------------------------------------------->
<ul class="list-point">
    <li>Выявлять проблемные абстракции и скрытые связи между сущностями</li>
    <li>Делать поведение модулей предсказуемым</li>
    <li>Вводить ограничение на наследование, чтобы потомки не противоречили базовому поведению</li>
</ul>

<!------------------------------------------------------------->
<h5>Реализация</h5>
<!------------------------------------------------------------->
<ul class="list-point">
    <li>Общий интерфейс для обоих классов</li>
    <li>Вместо наследования одного класса от другого использовать интерфейс</li>
</ul>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Примеры</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<!------------------------------------------------------------->
<h4>Пример 1</h4>
<!------------------------------------------------------------->

<v-two-border title="Fine;Badly"><template v-slot:first>
<ul class="list-point">
    <li>Нужно правильно выбирать слои абстракции</li>
    <li>Просто наследоваться от человека некорректно</li>
    <li>Добавляем еще один уровень абстракции в виде базовых классов</li>
</ul>

<v-code lang="js border" title="">
class Person {
    //
}
class Member extends Person {
    access() {
        console.log('Есть доступ');
    }
}
class Guest extends Person {
    isGuest = true;
}
</v-code>
<v-code lang="js border" title="">
class Frontend extends Member {}
class Backend extends Member {}

class PersonFromDifferentCompany extends Guest {
    access() {
        throw new Error('Нет доступа');
    }
}
</v-code>
<v-code lang="js border" title="">
// функция должна работать со всеми классами-наследниками
// от Person
function openSecretDoor(member) {
    member.access();
}

openSecretDoor(new Frontend());
openSecretDoor(new Backend());
// должен быть member
// openSecretDoor(new PersonFromDifferentCompany());
</v-code>

</template><template v-slot:last>
<v-code lang="js" title="">
class Person {
    access() {
        console.log('Есть доступ');
    }
}
</v-code>
<v-code lang="js" title="">
class Frontend extends Person {}
class Backend extends Person {}

class PersonFromDifferentCompany extends Person {
    access() {
        throw new Error('Нет доступа');
    }
}
</v-code>
<v-code lang="js" title="">
// функция должна работать со всеми классами-наследниками
// от Person
function openSecretDoor(person) {
    person.access();
}

openSecretDoor(new Frontend());
openSecretDoor(new Backend());
// получаем ошибку. нарушение принципа [L] LSP
openSecretDoor(new PersonFromDifferentCompany());
</v-code>

</template></v-two-border>

<!------------------------------------------------------------->
<h4>Пример 2</h4>
<!------------------------------------------------------------->

<v-two-border title="Fine;Badly"><template v-slot:first>
<v-code lang="js border" title="Базовые классы">
class Component {}
class ComponentWithTemplate extends Component {
    render() {
        return `&lt;div&gt;Component&lt;/div&gt;`
    }
}
class HigherOrderComponent extends Component {}
</v-code>
<v-code lang="js border" title="Наследники">
class HeaderComponent extends ComponentWithTemplate {
    onInit() {}
}
class FooterComponent extends ComponentWithTemplate {
    afterInit() {}
}
class HOC extends HigherOrderComponent {
    render() {
        throw new Error('Рендер невозможен');
    }
}
</v-code>
<v-code lang="js border" title="Функция">
function renderComponent(component) {
    console.log(component.render());
}

renderComponent(new HeaderComponent());
renderComponent(new FooterComponent());
// вызов невозможен
// renderComponent(new HOC());
</v-code>

</template><template v-slot:last>
<v-code lang="js" title="Базовый класс">
class Component {
    render() {
        return `&lt;div&gt;Component&lt;/div&gt;`
    }
}
</v-code>
<v-code lang="js" title="Наследники">
class HeaderComponent extends Component {
    onInit() {}
}
class FooterComponent extends Component {
    afterInit() {}
}
class HOC extends Component {
    // не должно быть реализации метода render
    render() {
        throw new Error('Рендер невозможен');
    }
}
</v-code>
<v-code lang="js" title="Функция">
function renderComponent(component) {
    console.log(component.render());
}

renderComponent(new HeaderComponent());
renderComponent(new FooterComponent());
// ошибка
renderComponent(new HOC());
</v-code>

</template></v-two-border>
