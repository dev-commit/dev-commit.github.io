<h2>Перебор массива</h2>

<ul class="list-point">
	<li><u-code-list>map</u-code-list> - для трансформации массива в массив</li>
	<li><u-code-list>forEach</u-code-list> - для перебора массива</li>
	<li><u-code-list>reduce/reduceRight</u-code-list> - для прохода по массиву с вычислением значения</li>
	<li><u-code-list>filter</u-code-list> - для фильтрации массива</li>
	<li><u-code-list>every/some</u-code-list> - для проверки массива</li>
</ul>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>map</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div class="v-method-wrapper">
    <v-method before="arr." method="map" after="" arg="(callback, thisArg)">
    создаёт новый массив с результатом вызова указанной функции для каждого элемента массива
    </v-method>

	<v-method-arg arg="callback">
	Функция, создающая элемент в новом массиве, принимает три аргумента:<br>
	<u>currentValue</u> - текущий обрабатываемый элемент массива<br>
	<u>index</u> - индекс текущего обрабатываемого элемента в массиве<br>
	<u>array</u> - массив, по которому осуществляется проход<br>
	</v-method-arg>

	<v-method-arg arg="thisArg">
	Необязательный параметр. Значение, используемое в качестве this при вызове функции callback
	</v-method-arg>

	<v-method-return>Новый массив, где каждый элемент является результатом callback функции</v-method-return>
</div>

<v-code lang="js border" title="">
const newArray = arr.map((currentValue, index, array) => { 
	// Возвращает элемент для newArray 
}[, thisArg]);
</v-code>

<v-code lang="js" title="">
const numbers = [1, 2, 3];
const doubles = numbers.map((num) => {
	return num * 2;
});

console.log(numbers); // => [1, 2, 3]
console.log(doubles); // => [2, 4, 6]
</v-code>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>forEach</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div class="v-method-wrapper">
    <v-method before="arr." method="forEach" after="" arg="(callback, thisArg)">
    Выполняет указанную функцию один раз для каждого элемента в массиве
    </v-method>

	<v-method-arg arg="callback">
	Функция, которая будет вызвана для каждого элемента массива; в нее будет передано три аргумента:<br>
	<u>currentValue</u> - текущий обрабатываемый элемент массива<br>
	<u>index</u> - индекс текущего обрабатываемого элемента в массиве<br>
	<u>array</u> - массив, по которому осуществляется проход<br>
	</v-method-arg>

	<v-method-arg arg="thisArg">
	Необязательный параметр. Значение, используемое в качестве this при вызове функции callback
	</v-method-arg>
</div>

<v-code lang="js border" title="">
arr.forEach((currentValue, index, array) => {
	// Your iterator
}[, thisArg]);
</v-code>

<ul class="list-point">
	<li>Ничего не возвращает, используется только для перебора</li>
</ul>
<v-code lang="js" title="">
const arr = ['Яблоко', 'Апельсин', 'Груша'];
arr.forEach((element, index, arr) => {
	console.log(element, index, arr);
});

// => 'Яблоко'   0  Array(3)
// => 'Апельсин' 1  Array(3)
// => 'Груша'    2  Array(3)
</v-code>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>reduce/reduceRight</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div class="v-method-wrapper">
    <v-method before="arr." method="reduce/reduceRight" after="" arg="(callback, initialValue)">
    применяет функцию reducer к каждому элементу массива <i><u>(слева-направо)/(справа-налево)</u></i>, возвращая одно результирующее значение
    </v-method>

	<v-method-arg arg="callback">
	Функция, выполняющаяся для каждого элемента массива, принимает четыре аргумента:<br>
	<u>accumulator/previousValue</u> - значение, возвращённое предыдущим выполнением функции callback, либо значение initialValue, если оно предоставлено<br>
	<u>currentValue</u> - текущий обрабатываемый элемент массива<br>
	<u>index</u> - индекс текущего обрабатываемого элемента в массиве<br>
	<u>array</u> - массив, по которому осуществляется проход<br>
	</v-method-arg>

	<v-method-arg arg="initialValue">
	Необязательный параметр. Объект, используемый в качестве первого аргумента при первом вызове функции callback
	</v-method-arg>
</div>

<v-code lang="js border" title="">
array.reduceRight(function(previousValue, currentValue, index, array) {
	// ...
});
</v-code>

<ul class="list-point">
	<li>Используется для последовательной обработки каждого элемента массива с сохранением промежуточного результата</li>
	<li><b>arr.reduce</b> идёт по массиву слева-направо</li>
	<li><b>arr.reduceRight</b> идёт по массиву справа-налево</li>
</ul>

<v-code lang="js" title="">
arr.reduce(callback[, initialValue])
</v-code>

<ul class="list-point">
	<b>callback(previousValue, currentItem, index, arr)</b>
	<li><u-code>previousValue</u-code> - последний результат вызова функции, «промежуточный результат»</li>
	<li><u-code>currentItem</u-code> - текущий элемент массива, элементы перебираются по очереди слева-направо</li>
	<li><u-code>index</u-code> - номер текущего элемента</li>
	<li><u-code>arr</u-code> - обрабатываемый массив</li>
</ul>

<ul class="list-point">
	<b>initialValue - начальное значение</b>
	<li>Если есть <u-code>initialValue</u-code>, то на первом вызове значение <u-code>previousValue</u-code> будет равно <u-code>initialValue</u-code></li>
	<li>Если нет <u-code>initialValue</u-code>, то оно равно первому элементу массива, а перебор начинается со второго</li>
</ul>

<v-code lang="js" title="">
// сумма элементов массива
const arr = [1, 2, 3, 4, 5];

// для каждого элемента массива запустить функцию,
// промежуточный результат передавать первым аргументом далее
const result = arr.reduce((sum, current) => {
  return sum + current;
});

console.log(result); // 15
</v-code>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>filter</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div class="v-method-wrapper">
    <v-method before="arr." method="filter" after="" arg="(callback, thisArg)">
    создаёт новый массив со всеми элементами, прошедшими проверку, задаваемую в передаваемой функции
    </v-method>

	<v-method-arg arg="callback">
	Функция, которая будет вызвана для каждого элемента массива. Если функция возвращает true, то элемент остаётся в массиве, если false, то удаляется. Три аргумента:<br>
	<u>currentValue</u> - текущий обрабатываемый элемент массива<br>
	<u>index</u> - индекс текущего обрабатываемого элемента в массиве<br>
	<u>array</u> - массив, по которому осуществляется проход<br>
	</v-method-arg>

	<v-method-arg arg="thisArg">
	Необязательный параметр. Значение, используемое в качестве this при вызове функции callback
	</v-method-arg>

	<v-method-return>Новый массив с элементами для которых callback вернёт true. Если ни один элемент не пройдет тест, то будет возвращен пустой массив</v-method-return>
</div>

<ul class="list-point">
	<li>Используется для фильтрации массива через функцию</li>
	<li>Создаёт новый массив, в который войдут только те элементы arr, для которых вызов callback(item, i, arr) возвратит true</li>
</ul>

<v-code lang="js" title="">
// Выбор положительных элементов массива
const arr = [1, -1, 2, -2, 3];
const result = arr.filter(number => {
	return number > 0;
});

console.log(result); // => [1, 2, 3]
</v-code>

<v-code lang="js" title="">
// Поиск вхождения подстроки в массив
let arr = ['Tony', 'Jack', 'Nick', 'Tony and Jane'];
let result = arr.filter(item => item.<u-code>includes</u-code>('Tony')); // => ["Tony", "Tony and Jane"]
</v-code>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>every/some</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<div class="v-method-wrapper">
    <v-method before="arr." method="every/some" after="" arg="(callback, thisArg)">
    проверяет, удовлетворяют ли <i><u>все/какие-нибудь</u></i> элементы массива условию, заданному в передаваемой функции
    </v-method>

	<v-method-arg arg="callback">
	Функция проверки каждого элемента, принимает три аргумента:<br>
	<u>currentValue</u> - текущий обрабатываемый элемент массива<br>
	<u>index</u> - индекс текущего обрабатываемого элемента в массиве<br>
	<u>array</u> - массив, по которому осуществляется проход<br>
	</v-method-arg>

	<v-method-arg arg="thisArg">
	Необязательный параметр. Значение, используемое в качестве this при вызове функции callback
	</v-method-arg>

	<v-method-return>true если функция проверки возвращает truthy значение для <i><u>каждого/хотя бы одного</u></i> элемента массива. Иначе, false</v-method-return>
</div>

<ul class="list-point">
	<li>Используется для проверки массива</li>
	<li>Метод «arr.every(callback[, thisArg])» возвращает true, если вызов callback вернёт true для каждого элемента arr</li>
	<li>Метод «arr.some(callback[, thisArg])» возвращает true, если вызов callback вернёт true для какого-нибудь элемента arr</li>
</ul>

<v-code lang="js" title="">
const arr = [1, -1, 2, -2, 3];

function isPositive(number) {
  return number > 0;
}

console.log( arr.every(isPositive) ); // false, не все положительные
console.log( arr.some(isPositive) );  // true, есть хоть одно положительное
</v-code>
