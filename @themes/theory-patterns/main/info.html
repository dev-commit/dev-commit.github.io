<h2>Паттерны проектирования</h2>

<u-link-wrapper>
    <a href="https://refactoring.guru/ru/design-patterns/catalog" target="_blank">Каталог паттернов проектирования</a>
    <a href="https://habr.com/ru/company/ruvds/blog/427293/" target="_blank">Паттерны проектирования в JavaScript</a>
    <a href="https://medium.com/@marina.kovalyova/java-script-design-patterns-569c627d25f9" target="_blank">Шаблоны проектирования в JavaScript</a>
</u-link-wrapper>

<ul class="list-point">
    <li><u-text-define>Паттерн проектирования (design pattern)</u-text-define> - это часто встречающееся решение определённой проблемы при проектировании архитектуры программ</li>
    <li>В отличие от готовых функций или библиотек, паттерн нельзя просто взять и скопировать в программу. Паттерн представляет собой не какой-то конкретный код, а общую концепцию решения той или иной проблемы, которую нужно будет ещё подстроить под нужды программы</li>
    <li>Паттерны часто путают с <u>алгоритмами</u>, ведь оба понятия описывают типовые решения каких-то известных проблем. Но если алгоритм — это чёткий набор действий, то паттерн — это высокоуровневое описание решения, реализация которого может отличаться в двух разных программах</li>
</ul>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Классификация</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ol class="list-num">
    <li><u-text-define>Порождающие</u-text-define> отвечают за удобное и безопасное создание новых объектов или даже целых семейств объектов без внесения в программу лишних зависимостей</li>
    <ul class="list-point">
        <li><u-text-underline>Фабричный метод (Factory Method)</u-text-underline> Определяет общий интерфейс для создания объектов в суперклассе, позволяя подклассам изменять тип создаваемых объектов</li>
        <li><u-text-underline>Абстрактная фабрика (Abstract Factory)</u-text-underline> Позволяет создавать семейства связанных объектов, не привязываясь к конкретным классам создаваемых объектов. Интерфейс, который группирует другие фабрики, логически связанные друг с другом</li>
        <li><u-text-underline>Строитель (Builder)</u-text-underline> Позволяет создавать сложные объекты пошагово. Строитель даёт возможность использовать один и тот же код строительства для получения разных представлений объектов</li>
        <li><u-text-underline>Прототип (Prototype)</u-text-underline> Позволяет копировать объекты, не вдаваясь в подробности их реализации</li>
        <li><u-text-underline>Одиночка (Singleton)</u-text-underline> Гарантирует, что у класса есть только один экземпляр, и предоставляет к нему глобальную точку доступа</li>
    </ul>

    <li><u-text-define>Структурные</u-text-define> отвечают за построение удобных в поддержке иерархий классов. Показывают различные способы построения связей между объектами</li>
    <ul class="list-point">
        <li><u-text-underline>Адаптер (Adapter)</u-text-underline> Позволяет объектам с несовместимыми интерфейсами работать вместе</li>
        <li><u-text-underline>Мост (Bridge)</u-text-underline> Разделяет один или несколько классов на две отдельные иерархии - абстракцию и реализацию, позволяя изменять их независимо друг от друга</li>
        <li><u-text-underline>Компоновщик (Composite)</u-text-underline> Позволяет сгруппировать объекты в древовидную структуру, а затем работать с ними так, как будто это единичный объект</li>
        <li><u-text-underline>Декоратор (Decorator)</u-text-underline> Позволяет динамически добавлять объектам новую функциональность, оборачивая их в полезные «обёртки»</li>
        <li><u-text-underline>Фасад (Facade)</u-text-underline> Предоставляет простой интерфейс к сложной системе классов, библиотеке или фреймворку</li>
        <li><u-text-underline>Легковес (Flyweight)</u-text-underline> Позволяет вместить бóльшее количество объектов в отведённую оперативную память. Легковес экономит память, разделяя общее состояние объектов между собой, вместо хранения одинаковых данных в каждом объекте</li>
        <li><u-text-underline>Заместитель (Proxy)</u-text-underline> Позволяет подставлять вместо реальных объектов специальные объекты-заменители. Эти объекты перехватывают вызовы к оригинальному объекту, позволяя сделать что-то до или после передачи вызова оригиналу</li>
    </ul>

    <li><u-text-define>Поведенческие</u-text-define> решают задачи эффективного и безопасного взаимодействия между объектами программы</li>
    <ul class="list-point">
        <li><u-text-underline>Цепочка обязанностей (Chain of Responsibility)</u-text-underline> Позволяет передавать запросы последовательно по цепочке обработчиков. Каждый последующий обработчик решает, может ли он обработать запрос сам и стоит ли передавать запрос дальше по цепи</li>
        <li><u-text-underline>Команда (Command)</u-text-underline> Превращает запросы в объекты, позволяя передавать их как аргументы при вызове методов, ставить запросы в очередь, логировать их, а также поддерживать отмену операций</li>
        <li><u-text-underline>Итератор (Iterator)</u-text-underline> Даёт возможность последовательно обходить элементы составных объектов, не раскрывая их внутреннего представления</li>
        <li><u-text-underline>Посредник (Mediator)</u-text-underline> Позволяет уменьшить связанность множества классов между собой, благодаря перемещению этих связей в один класс-посредник</li>
        <li><u-text-underline>Снимок (Memento)</u-text-underline> Позволяет делать снимки состояния объектов, не раскрывая подробностей их реализации. Затем снимки можно использовать, чтобы восстановить прошлое состояние объектов</li>
        <li><u-text-underline>Наблюдатель (Observer)</u-text-underline> Создаёт механизм подписки, позволяющий одним объектам следить и реагировать на события, происходящие в других объектах</li>
        <li><u-text-underline>Состояние (State)</u-text-underline> Позволяет объектам менять поведение в зависимости от своего состояния. Извне создаётся впечатление, что изменился класс объекта</li>
        <li><u-text-underline>Стратегия (Strategy)</u-text-underline> Определяет семейство схожих алгоритмов и помещает каждый из них в собственный класс, после чего алгоритмы можно взаимозаменять прямо во время исполнения программы</li>
        <li><u-text-underline>Шаблонный метод (Template method)</u-text-underline> Определяет скелет алгоритма, перекладывая ответственность за некоторые его шаги на подклассы. Паттерн позволяет подклассам переопределять шаги алгоритма, не меняя его общей структуры</li>
        <li><u-text-underline>Посетитель (Visitor)</u-text-underline> Позволяет создавать новые операции, не меняя классы объектов, над которыми эти операции могут выполняться</li>
    </ul>

</ol>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Зачем?</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ol class="list-num">
    <li><b>Проверенные решения</b> Вы тратите меньше времени, используя готовые решения, вместо повторного изобретения велосипеда</li>
    <li><b>Стандартизация кода</b> Вы делаете меньше просчётов при проектировании, используя типовые унифицированные решения, так как все скрытые проблемы в них уже давно найдены</li>
    <li><b>Общий программистский словарь</b> Вы произносите название паттерна, вместо того, чтобы час объяснять другим программистам, какой крутой дизайн вы придумали и какие классы для этого нужны</li>
</ol>
