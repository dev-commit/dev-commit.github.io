<h2>Архитектура среды выполнения JS</h2>

<u-message-comment>
На примере движка <u>V8</u> (Chrome, Node.js)
</u-message-comment>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Движок V8</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
    <li><u-text-define>V8</u-text-define> - движок JavaScript с открытым исходным кодом</li>
    <li>Входит в релиз Chromium</li>
</ul>

<!------------------------------------------------------------->
<h4>Составные части</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li><u-text-underline>Куча (Memory Heap)</u-text-underline> - место, где происходит выделение памяти</li>
    <li><u-text-underline>Стек вызовов (Call Stack)</u-text-underline> - место, куда в процессе выполнения кода попадают так называемые стековые кадры</li>
</ul>


<v-two><template v-slot:first>
    <!------------------------------------------------------------->
    <h4>1. Heap</h4>
    <!------------------------------------------------------------->
    <ul class="list-point">
        <li><u-text-define>Heap (куча)</u-text-define> - структура данных, с помощью которой реализована динамически распределяемая память приложения</li>
        <li>Куча - ссылка на определённую неструктурированную область памяти</li>
        <li>Содержит объекты, на которые ссылаются переменные программы</li>
        <li>memory allocation</li>
    </ul>

    <!------------------------------------------------------------->
    <h4>2. Call Stack</h4>
    <!------------------------------------------------------------->
    <ul class="list-point">
        <li><u-text-define>Call Stack</u-text-define> - <u>стек вызовов</u> LIFO структура (последний вошедший выходит первым)</li> 
        <li>В стек помещаются и удаляются аргументы, локальные переменные функций по мере выполнения программы. Синхронные функции помещаются в стек вызова сразу. Асинхронные откладываются в специальную таблицу - <u>Event Table</u>, где ожидают дальнейшей обработки, чтобы не блокировать процесс выполнения программы. Видно какая функция какую вызвала (<u>execution context</u>)</li>
        <li>Стек вызовов - это структура данных, которая, записывает сведения о месте в программе, где мы находимся. Если мы переходим в функцию, мы помещаем запись о ней в верхнюю часть стека. Когда мы из функции возвращаемся, мы вытаскиваем из стека самый верхний элемент и оказываемся там, откуда вызывали эту функцию. Каждая запись в стеке вызовов называется стековым кадром</li>
        <li>Если будет достигнут максимальный размер стека (16 000), возникнет переполнение стека</li>
    </ul>

    <!------------------------------------------------------------->
    <h4>3. Web API</h4>
    <!------------------------------------------------------------->
    <ul class="list-point">
        <li><u-text-define>Web API</u-text-define> - <u>расширения браузера</u></li>
        <li>Event Table и Event Queue являются частью Web API, который реализуют браузеры для того, чтобы использовать такие возможности, как асинхронные запросы, таймеры, обрабатывать DOM события и другое асинхронное поведение. Это не является стандартным функционалом JavaScript и в различных средах данное API может быть реализовано по разному</li>
        <li>Web API - это потоки, к которым у нас нет прямого доступа, мы можем лишь выполнять обращения к ним. Они встроены в браузер, где и выполняются асинхронные действия</li>
    </ul>

    <hr>

    <ul class="list-point">
        <li><u-text-define>3.1 Event Table</u-text-define> - <u>таблица</u> в которой находится информация о том, по какому событию необходимо поместить функцию в <u>Event Queue</u> (очередь событий)</li>
        <li><u-text-define>3.2 Callback/Event/Task Queue</u-text-define> - <u>очередь задач/событий</u> - FIFO структура (раньше выходят элементы, которые раньше были помещены). В ней находятся асинхронные функции, для которых наступило время запуска</li>
        <li><u-text-define>3.3 Job Queue (ES6)</u-text-define> - <u>очередь заданий (микротаски)</u> Эта конструкцию можно считать слоем, расположенном поверх очереди цикла событий. Очередь заданий — это очередь, которая присоединена к концу каждого тика в очереди цикла событий</li>
    </ul>

    <!------------------------------------------------------------->
    <h4>4. Event Loop</h4>
    <!------------------------------------------------------------->
    <ul class="list-point">
        <li><u-text-define>Event Loop</u-text-define> - <u>цикл/петля событий</u> - наблюдает за стеком вызовов и очередью коллбэков (callback queue). Если стек вызовов пуст, цикл берёт первое событие из очереди и помещает его в стек, что приводит к запуску этого события на выполнение. Подобная итерация называется тиком (tick) цикла событий. Каждое событие - это просто коллбэк</li>
        <li>Позволяет запланировать выполнение асинхронного кода сразу после выполнения синхронного кода</li>
    </ul>
</template><template v-slot:last>
    <h4>Общая структура</h4>
    <img src="/@img/js/event-loop/event-loop1.png" width="500px">
    
    <h4>Виды очередей</h4>
    <img src="/@img/js/event-loop/event-loop3.png" width="500px">
    
    <h4>Анимация работы</h4>
    <img src="/@img/js/event-loop/event-loop-animation.gif" width="500px">
</template></v-two>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Краеугольные камни движка V8</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
    <li>Компиляция исходного кода JavaScript непосредственно в собственный машинный код, минуя стадию промежуточного байт-кода</li>
    <li>Эффективная система управления памятью, приводящая к быстрому объектному выделению и маленьким паузам сборки «мусора»</li>
    <li>Введение скрытых классов и встроенных кэшей, ускоряющих доступ к свойствам и вызовам функций</li>
</ul>
