<h2>История версий</h2>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>⭐️ React 19 (2024)</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<!------------------------------------------------------------->
<h4>Серверные компоненты</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li>Директива "use server"</li>
    <li>Код в этом блоке будет запускаться только на сервере</li>
</ul>

<!------------------------------------------------------------->
<h4>Фиксы гидрации</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li>Проблема гидрации: стейт на сервере должен совпадть со стетом на клиенте, чтобы не делать повторно одни и те же запросы</li>
    <li>Будет меньше сложностей с гидрацией</li>
</ul>

<!------------------------------------------------------------->
<h4>Мета теги в JSX</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li>Мета теги можно указывать в JSX. React будет ставить их в  &lt;head&gt;</li>
</ul>

<!------------------------------------------------------------->
<h4>Подгрузка css-файлов из JSX</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li>Можно добавлать тег &lt;link&gt; с указанием ссылки на CSS-файл и дополнительно указывать приоритетность стилей</li>
</ul>

<!------------------------------------------------------------->
<h4>Suspense при подгрузке стилей</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li>Можно добавить компонент загрузки при подгрузке стилей</li>
</ul>

<!------------------------------------------------------------->
<h4>Методы для быстрой загрузки файлов</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li>Дополнительные методы: preinit, preload, prefetchDNS, preconnect, preinitModule, preloadModule</li>
    <li>Методы позволяют ускорить загрузку файлов с сервера</li>
</ul>

<!------------------------------------------------------------->
<h4>Работа с формами в React</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li>Добавился атрибут action у тега &lt;form&gt;. Можно указать асинхронную функцию, куда придут данные из формы</li>
</ul>

<!------------------------------------------------------------->
<h4>Новые методы форм</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li>useOptimistic, useFormStatus, useActionState</li>
</ul>

<!------------------------------------------------------------->
<h4>Ref как свойство</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li>Можно пробрасывать как props в другие компоненты</li>
</ul>

<!------------------------------------------------------------->
<h4>Хук useMemo больше не нужен</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li>React будет использовать по-умолчанию</li>
</ul>

<!------------------------------------------------------------->
<h4>Функция use</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li>Похожа на хук, но можно использовать в условных операторах и т.д.</li>
</ul>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>⭐️ React 18 (2022, March)</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<!------------------------------------------------------------->
<h4>Automatic batching</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li><u-text-define>Batching в React</u-text-define> (батчинг) - процесс группировки нескольких вызовов обновления состояний в один этап ререндера. Другими словами, пакетная обработка</li>
    <li>Добавилась возможность автоматического батчинга обновления состояний для асинхронных операций: <u>promise</u>, <u>timeouts</u>, <u>fetch-запросы</u>, что положительно сказывается на производительности</li>
    <li>Раньше группировка происходила только внутри обработчиков событий</li>
</ul>

<v-details title="Пример"><v-code lang="js" title="">
const App = () => {
    const [count, setCount] = useState(0);
    const [flag, setFlag] = useState(false);

    const handleClick = () => {
        // До React 18 следующие вызовы не батчились
        // Установка состояния происходит «после» события в колбэке асинхронного вызова
        fetchSomething().then(() => {
            setCount(c => c + 1); // Спровоцирует ререндер
            setFlag(f => !f); // Спровоцирует ререндер
        });

        // В React 18
        fetchSomething().then(() => {
            setCount(c => c + 1); // Не вызывает ререндер
            setFlag(f => !f); // Не вызывает ререндер
            // React будет вызывать ререндер только один раз, в конце
        })
    }

    return (
        &lt;div&gt;
            &lt;button onClick={handleClick}&gt;Next&lt;/button&gt;
            &lt;h1 style=<span v-pre>{{ color: flag ? "blue" : "black" }}</span>&gt;{count}&lt;/h1&gt;
        &lt;/div&gt;
    );
}
</v-code></v-details>

<!------------------------------------------------------------->
<h4>Concurrent rendering</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li><u-text-define>Concurrent rendering</u-text-define> (конкурентный режим) предназначен для более плавной работы приложения на устройстве пользователя. Одна из областей применения —  прерываемый рендеринг. Представьте, что пользователь вводит в строку поиска текст. Событие обновляет состояние компонента, и происходит рендер нового списка результатов. Во время этого процесса залипает ввод: браузер не может обновить введенный в поле текст, т.к. занимается рендером нового списка результатов. Конкурентный режим исправляет это ограничение и делает рендер прерываемым</li>
</ul>

<!------------------------------------------------------------->
<h4>Новые хуки</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li><em>useTransition</em></li>
    <li><em>useDeferredValue</em></li>
    <li><em>useId</em></li>
    <li><em>useSyncExternalStore</em></li>
    <li><em>useInsertionEffect</em></li>
</ul>

<!------------------------------------------------------------->
<h4>Concurrent Suspense</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li>Существенное изменение для пользователей заключается в рендере дочерних элементов внутри Suspense</li>
    <li>В React 17 компонент <u>&lt;Sibling /&gt;</u> будет смонтирован и вызваны его эффекты. Затем он будет скрыт</li>
    <li>В React 18 компонент <u>&lt;Sibling /&gt;</u> смонтируется только после того, как <u>&lt;SuspendedComponent /&gt;</u> загрузится</li>
</ul>
<v-details title="Пример">
<v-code lang="js" title="">
const App = () => {
    return (
    &lt;Suspense fallback={&lt;Loading /&gt;}&gt;
        &lt;SuspendedComponent /&gt;
        &lt;Sibling /&gt;
    &lt;/Suspense&gt;
    );
};
</v-code>
</v-details>

<!------------------------------------------------------------->
<h4>Потоковый SSR</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li><b>Выборочная гидратация</b></li>
    <li>Метод <u>hydrate()</u> используется в SSR и позволяет повесить обработчики событий на узлы DOM-дерева, которые были отрендерены на стороне сервера. Это позволяет улучшить опыт клиента при первой загрузки страницы</li>
    <li>React не будет блокировать UI во время гидратации — этот процесс будет происходить во время простоя браузера. Поэтому пользовательские события будут обрабатываться сразу</li>
    <li><b>Потоковая отправка HTML</b></li>
    <li>Позволяет отправить HTML клиенту без загрузки всех данных для рендера на сервер. Как только данные будут получены, они отрендерятся на сервере и отправятся на клиент. Например, есть блок с комментариями, и мы можем асинхронно загружать по ним информацию, отдавая HTML. Когда комментарии будут получены, отрендерить их и отправить клиенту в конце HTML-документа</li>
</ul>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>⭐️ React 17 (2020, October)</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<!------------------------------------------------------------->
<h4>Изменение в делегировании событий</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li>React использует делегирование событий и <u>привязывал все события к объекту document</u>. Теперь все обработчики крепятся к корневому элементу <u>root</u>, а не объекту document</li>
</ul>
<v-code lang="js" title="">
const rootNode = document.getElementById('<u-code-mod>root</u-code-mod>');
ReactDOM.render(&lt;App /&gt;, rootNode);
</v-code>

<!------------------------------------------------------------->
<h4>SyntheticEvent Even Pooling</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li>Убрана оптимизация событий, которая более не актуальна в современных браузерах</li>
</ul>
<v-details title="Такой код не будет валиться с ошибкой"><v-code lang="js" title="">
function handleChange(event) {
    // это работает в 16 React только если добавить event.persist()
    setData(data => ({
        ...data,
        // This crashes in React 16 and earlier:
        text: event.target.value
    }));
}
</v-code></v-details>

<!------------------------------------------------------------->
<h4>Браузерные события</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li>Событие <u-code-text>onScroll</u-code-text> больше не всплывает, чтобы избежать текущей путаницы</li>
    <li>События <u-code-text>onFocus</u-code-text> и <u>onBlur</u> изменены "под капотом" на нативные <u>focusin</u> и <u>focusout</u></li>
    <li><u-code-text>onClickCapture</u-code-text> и другие Capture-события теперь используют браузерные обработчики событий</li>
</ul>

<!------------------------------------------------------------->
<h4>useEffect() теперь полностью асинхронный</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
useEffect(() => {
    // This is the effect itself
    return () => {
        // This is its cleanup
    };
});
</v-code>
<ul class="list-point">
    <li>Если раньше только функция эффекта запускалась асинхронно, тогда как возвращаемая функция для очистки подписок запускалась синхронно, так же как и метод <u>componentWillUnmount()</u>, то теперь и эта функция работает асинхронно, что улучшает производительность в случае перерисовки большого количества элементов, например, когда на сайте присутствуют вкладки, или при переходе со страницы на страницу</li>
    <li>Для синхронной работы, можно по-прежнему использовать <u-code-text>useLayoutEffect()</u-code-text>, который остался незатронутым</li>
</ul>

<!------------------------------------------------------------->
<h4>Улучшенный стек вызовов при ошибках</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li>Когда выбрасывается ошибка, браузер показывает stack trace с названиями функций и их местоположения. К сожалению, довольно трудно по этому стеку вызовов понять, в каком месте и в каком компоненте была вызвана ошибка на самом деле</li>
    <li>В React 17 используется новых механизм по генерации стека вызовов, что позволяет увидеть дерево React-компонентов, которое привело к ошибке, даже в production-среде</li>
</ul>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>⭐️ React 16 (2017, September)</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
    <li><em>Фрагменты</em> - позволяют формировать список дочерних элементов, не создавая лишних узлов в DOM</li>
    <li><em>Обработка ошибок (error boundaries)</em> - специальные компоненты, которые перехватывают ошибки в своём поддереве и позволяют вывести резервный UI</li>
    <li><em>Порталы</em> - рендера дочерних компонентов в DOM-узел, который находится за пределами дерева родительского компонента</li>
    <li><em>Поддержка произвольных DOM-атрибутов</em> - вместо игнорирования неизвестных HTML и SVG атрибутов, теперь React будет просто передавать их в DOM</li>
    <li><em>Улучшения в серверном рендере</em> - поддерживает стриминг, так что вы можете быстрее начинать отправлять байты клиенту. И благодаря новой стратегии сборки, которая убирает из кода обращения к process.env (хотите верьте, хотите — нет, но чтение process.env в Node очень медленное!), вам больше не надо бандлить React для получения хорошей производительности серверного рендеринга</li>
    <li><em>Уменьшенный размер файла</em></li>
    <li><em>Зависимость от коллекций Map и Set</em></li>
</ul>
