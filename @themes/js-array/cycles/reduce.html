<!-- TODO:
<f-search>JS -> Array -> reduce</f-search>
<f-search>JS -> Array -> reduceRight</f-search>
-->

<h2>reduce / reduceRight</h2>

<div class="v-method-wrapper">
    <v-method before="arr." method="reduce/reduceRight" after="" arg="(callback, initialValue)">
    применяет функцию reducer к каждому элементу массива <i><u>(слева-направо)/(справа-налево)</u></i>, возвращая одно результирующее значение
    </v-method>

	<v-method-arg arg="callback">
	Функция, выполняющаяся для каждого элемента массива, принимает четыре аргумента:<br>
	<u>accumulator/previousValue</u> - значение, возвращённое предыдущим выполнением функции callback, либо значение initialValue, если оно предоставлено<br>
	<u>currentValue</u> - текущий обрабатываемый элемент массива<br>
	<u>index</u> - индекс текущего обрабатываемого элемента в массиве<br>
	<u>array</u> - массив, по которому осуществляется проход<br>
	</v-method-arg>

	<v-method-arg arg="initialValue">
	Необязательный параметр. Объект, используемый в качестве первого аргумента при первом вызове функции callback
	</v-method-arg>
</div>

<v-code lang="js border" title="">
array.reduceRight((previousValue, currentValue, index, array) => {
	// ...
});
</v-code>

<ul class="list-point">
	<li>Используется для последовательной обработки каждого элемента массива с сохранением промежуточного результата</li>
	<li><b>arr.reduce</b> идёт по массиву слева-направо</li>
	<li><b>arr.reduceRight</b> идёт по массиву справа-налево</li>
</ul>

<v-code lang="js" title="">
arr.reduce(callback[, initialValue])
</v-code>

<ul class="list-point">
	<b>callback(previousValue, currentItem, index, arr)</b>
	<li><u-code>previousValue</u-code> - последний результат вызова функции, «промежуточный результат»</li>
	<li><u-code>currentItem</u-code> - текущий элемент массива, элементы перебираются по очереди слева-направо</li>
	<li><u-code>index</u-code> - номер текущего элемента</li>
	<li><u-code>arr</u-code> - обрабатываемый массив</li>
</ul>

<ul class="list-point">
	<b>initialValue - начальное значение</b>
	<li>Если есть <u-code>initialValue</u-code>, то на первом вызове значение <u-code>previousValue</u-code> будет равно <u-code>initialValue</u-code></li>
	<li>Если нет <u-code>initialValue</u-code>, то оно равно первому элементу массива, а перебор начинается со второго</li>
</ul>

<!------------------------------------------------------------->
<h4>Пример 1: Сумма элементов массива</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
// сумма элементов массива
const arr = [1, 2, 3, 4, 5];

// для каждого элемента массива запустить функцию,
// промежуточный результат передавать первым аргументом далее
const result = arr.reduce((sum, current) => {
  return sum + current;
});

console.log(result); // 15
</v-code>

<!------------------------------------------------------------->
<h4>Пример 2: Перебор объекта</h4>
<!------------------------------------------------------------->
<v-code lang="js" title="">
const data = {
	name: 'Tony',
	age: 23,
	stars: 100,
};

const res = Object.keys(data).reduce(
	(result, key) => {
		const value = data[key];
		result[key] = value;
		return result;
	},
	{ greet: 'Hello' }
);

console.log(res);
</v-code>

<v-code lang="js" title="">
// {
// 	greet: 'Hello',
// 	name: 'Tony',
// 	age: 23,
// 	stars: 100,
// }
</v-code>
