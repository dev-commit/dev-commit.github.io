<!-- TODO:
<f-search>Парадигмы -> DDD</f-search>
-->

<h2>DDD</h2>

<ul class="list-point">
    <li><u-text-define>Domain-Driven Design, DDD (Предметно-ориентированное проектирование)</u-text-define> - набор принципов и схем, направленных на создание оптимальных систем объектов. Сводится к созданию программных абстракций, которые называются моделями предметных областей. В эти модели входит бизнес-логика, устанавливающая связь между реальными условиями области применения продукта и кодом</li>
    <li>DDD - набор правил, которые позволяют принимать правильные проектные решения. Данный подход позволяет значительно ускорить процесс проектирования программного обеспечения в незнакомой предметной области</li>
    <li>DDD - набор подходов для организации кода в системах со сложной предметной областью</li>
    <li>Подход DDD особо полезен в ситуациях, когда разработчик не является специалистом в области разрабатываемого продукта. К примеру: программист не может знать все области, в которых требуется создать ПО, но с помощью правильного представления структуры, посредством проблемно-ориентированного подхода, может без труда спроектировать приложение, основываясь на ключевых моментах и знаниях рабочей области</li>
    <li>Приложение должно максимально рассказыать какую предметную область решаем</li>
</ul>

<!------------------------------------------------------------->
<h4>Применение</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li>Проекты с тяжелой бизнес-логикой</li>
    <li>Проекты, которые сложно разграничить</li>
</ul>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Структура</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
    <li><u-text-underline>Domain</u-text-underline> (Область) - сущность или действия реального мира, которые пытаемся автоматизировать. Предметная область, к которой применяется разрабатываемое ПО</li>
    <li><u-text-underline>Model</u-text-underline> (Модель) - описывает отдельные аспекты области и может быть использована для решения проблемы</li>
    <li><u-text-underline>Ubiquitous Language</u-text-underline> - (Единый язык домена) - набор терминов, применяемых в модели домена для объяснения связей и дейтствий. Используется для единого стиля описания домена и модели. Необходим для постоения правильного взаимодействия между доменными специалистами (бизнес-аналитиками, аналитиками, PM, заказчиком) и разработчиками, чтобы могли общаться на одном языке</li>
    <li><u-text-underline>Bounded Context</u-text-underline> - контекст, ограничивающий Domain Model и Ubiquitous Language</li>
</ul>

<v-two><template v-slot:first>
<img src="/@img/other/ddd1.jpg" width="350px">
</template><template v-slot:last>
<img src="/@img/other/ddd2.jpg" width="350px">
</template></v-two>

<ul class="list-point">
    <li>Есть домен, котрый является определенной бизнес-задачей</li>
    <li>Далее идёт разбиение на поддомены - те действующий элементы проекта, который составляют основной функционал</li>
</ul>

<ul class="list-point">
	<b>Поддомены</b>
    <li>1. Core Domain (Ядро домена) - основной бизнес-процесс. Основная задача DDD - вычленить его</li>
    <li>2. Supporting Domain - от них зависит бизнес, но которые не имеют прямого отношения к ядру. Что-то помогающее бизнес-процессу</li>
</ul>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Архитектурные решения</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
    <li><u-text-underline>Model-Driven Design</u-text-underline> - Проектирование от модели</li>
    <li><u-text-underline>CQRS</u-text-underline> - архитектурный подход. Разделение представления данных как со сторный БД, так и внутри самого приложения</li>
</ul>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Шаблоны проектирования, которые часто используются с DDD</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<!------------------------------------------------------------->
<h4>1. Entity</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li>Описывает индивидуально существующие элементы домена</li>
    <li>Определяется по идентификатору, а не по значению атрибутов</li>
    <li>Непрерывно и однозначно определяется на всем протяжении существования</li>
</ul>

<!------------------------------------------------------------->
<h4>2. Value Object</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li>Не обладается идентификатором</li>
    <li>Описывает элементы домена, полностью определяемые свойствами</li>
    <li>Неизменяемый после создания</li>
    <li>Используется для типизации и структурирования данных</li>
</ul>

<!------------------------------------------------------------->
<h4>3. Aggregate</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li>Собирательная сущность, которая считаетмя единым целым</li>
    <li>Состоит из Value Object и Entity</li>
    <li>Определяется по идентификатору</li>
    <li>Является границей транзакции при изменении данных</li>
    <li>Другие элементы домена не могут ссылаться на внтренности агрегата</li>
</ul>

<!------------------------------------------------------------->
<h4>4. Respository</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li>+ Описывается интерфейсом</li>
    <li>+ Объекты не зависят от структуры БД и типов полей</li>
    <li>+ В рамках доменного слоя реализация не важна</li>
    <li>+ Может быть реализован для разных хранилищ</li>
    <li>+ Удобно тестировать</li>
    <li>+ Хорошо ложится в DDD</li>
    <li>- Сложно со старта</li>
    <li>- Входной порог существенно выше</li>
    <li>- Придётся писать гидраторы</li>
</ul>

<!------------------------------------------------------------->
<h4>5. Service</h4>
<!------------------------------------------------------------->
