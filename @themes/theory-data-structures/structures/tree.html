<!-- TODO:
<f-search>Структуры данных -> Tree (Дерево)</f-search>
-->

<h2>Tree (Дерево)</h2>

<u-link-wrapper>
    <a href="https://www.youtube.com/watch?v=wtgLQE9hjuk" target="_blank">[YouTube] Алгоритмы и структуры данных. Деревья</a>
</u-link-wrapper>

<ul class="list-point">
    <li><u-text-define>Деревья</u-text-define> - эмулирует древовидную структуру в виде набора связанных узлов (вершин) и ребер</li>
    <li>Дерево должно начинаться с единственного родителя, «корня» дерева</li>
    <li>Дерево считается ориентированным, если в корень не заходит ни одно ребро</li>
    <li><b>Определяющее свойство дерева</b> - существование только одного пути, соединяющего любые два узла</li>

    <br>
    <li><u-text-define>Двоичные деревья поиска</u-text-define> позволяют быстро находить, добавлять и удалять элементы. Они устроены так, что время каждой операции пропорционально логарифму общего числа элементов в дереве</li>
</ul>

<!------------------------------------------------------------->
<h4>Определения</h4>
<!------------------------------------------------------------->
<v-two><template v-slot:first>
<ul class="list-point">
    <li><u>Вершина (узел)</u> - простой объект</li>
    <li><u>Ребро</u> - связь между двумя верщинами</li>
    <li><u>Путь в дереве</u> - список отдельных вершин, в котором следующие друг за другом вершины соединяются ребрами дерева</li>
    <li><u>Корневой узел</u> - самый верхний узел дерева (узел 8 на примере)</li>
    <li><u>Корень</u> - одна из вершин, по желанию наблюдателя</li>
    <li><u>Лист, листовой или терминальный узел</u> - узел, не имеющий дочерних элементов (узлы 1, 4, 7, 13)</li>
    <li><u>Внутренний узел</u> - любой узел дерева, имеющий потомков, и таким образом, не являющийся листовым узлом (3, 6, 10, 14)</li>
</ul>
</template><template v-slot:last>
<img src="/@img/structure/tree1.png" width="200px">
</template></v-two>

<!------------------------------------------------------------->
<h4>Представление дерева</h4>
<!------------------------------------------------------------->
<img src="/@img/structure/tree2.jpg">

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Операции</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<!------------------------------------------------------------->
<h4>Общие операции</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li>Вставка нового элемента в определённую позицию</li>
    <li>Вставка поддерева</li>
    <li>Добавление ветви дерева</li>
    <li>Нахождение корневого элемента для любого узла</li>
    <li>Нахождение наименьшего общего предка двух вершин</li>
    <li>Перебор всех элементов дерева</li>
    <li>Перебор элементов ветви дерева</li>
    <li>Поиск изоморфного поддерева</li>
    <li>Поиск элемента;</li>
    <li>Удаление ветви дерева</li>
    <li>Удаление поддерева</li>
    <li>Удаление элемента</li>
</ul>

<!------------------------------------------------------------->
<h4>Обход дерева</h4>
<!------------------------------------------------------------->
<img class="img-margin" src="/@img/structure/tree3.jpg" height="200px">

<!------------------------------------------------------------->
<h4>Обход двоичного дерева в глубину (DFS - Depth First Search)</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li>Используется стек</li>
</ul>
<ol class="list-num">
    <li>Обработка узла поддерева</li>
    <li>Рекурсивный обход левого поддерева</li>
    <li>Рекурсивный обход правого поддерева</li>
</ol>

<ul class="list-point">
    <u>Прямой обход (сверху-вниз, pre-order)</u>
    <li>вначале обрабатывается узел, затем посещается левое и правое поддерево</li>
</ul>
<v-code lang="bash" title="">
E, D, B, A, C, H, F, G
</v-code>

<ul class="list-point">
    <u>Обратный обход (снизу вверх, post-order)</u>
    <li>вначале посещается левое и правое поддерево, затем обрабатывается узел</li>
</ul>
<v-code lang="bash" title="">
A, C, B, D, G, F, H, E
</v-code>

<ul class="list-point">
    <u>Поперечный обход (слева-направо, in-order)</u>
    <li>вначале посещается левое поддерево, затем узел и правое поддерево</li>
</ul>
<v-code lang="bash" title="">
A, B, C, D, E, F, G, H
</v-code>

<!------------------------------------------------------------->
<h4>Обход двоичного дерева в ширину (BFS - Breadth First Search)</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li>Используется очередь, содержащая вершины, требующие просмотра</li>
    <li>Выполняется по слоям начиная от корня</li>
</ul>
<ol class="list-num">
    За одну итерацию алгоритма:
    <li>если очередь не пуста, извлекается вершина из очереди</li>
    <li>обрабатывается извлеченная вершина</li>
    <li>в очередь помещаются все дочерние</li>
</ol>
<v-code lang="bash" title="">
E, D, H, B, F, A, C, G
</v-code>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Сложность алгоритма</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<v-code lang="bash" title="Временная сложность двоичного дерева поиска ">
║ Алгоритм  ║Среднее значение ║Худший случай ║
║ Space     ║ O(n)            ║ O(n)         ║
║ Search    ║ O(log n)        ║ O(n)         ║
║ Insert    ║ O(log n)        ║ O(n)         ║
║ Delete    ║ O(log n)        ║ O(n)         ║
</v-code>
