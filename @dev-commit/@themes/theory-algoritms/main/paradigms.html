<h2>Algorithm Design Paradigms (Методы разработки алгоритмов)</h2>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Методы</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
    <li>1. Метод грубой силы / полный перебор / исчерпывающий поиск (Brute-Force)</li>
    <li>2. Разделяй и властвуй / метод декомпозиции (Divide and Conquer)</li>
    <li>3. Динамическое программирование (Dynamic Programming)</li>
    <li>4. Жадный алгоритм (Greedy Algorithm)</li>
    <li>5. Поиск с возвратом (Backtracking)</li>
    <li>6. Локальный поиск (Local Search)</li>
</ul>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>1. Метод грубой силы / полный перебор / исчерпывающий поиск (Brute-Force)</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
    <li>Сложность полного перебора зависит от количества всех возможных решений задачи. Если пространство решений очень велико, то полный перебор может не дать результатов в течение нескольких лет или даже столетий</li>
</ul>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>2. Разделяй и властвуй / метод декомпозиции (Divide and Conquer)</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->

<!------------------------------------------------------------->
<h4>Принцип работы</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li>Разделить задачу на поздадачи</li>
    <li>Решить подзадачи</li>
    <li>Скомбинировать результаты решений, если это требуется</li>
</ul>

<!------------------------------------------------------------->
<h4>Примеры</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <b>Пример с комбинированием: Сортировка слиянием (Merge Sort)</b>
    <li>Делим массив пополам</li>
    <li>Решаем задачу рекурсивно для обоих половин</li>
    <li>Объединяем решение с помощью алгоритма слияния</li>
    
    <hr>
    <b>Пример без комбинирования: Binary Search (Бинарный поиск)</b>
</ul>

<!------------------------------------------------------------->
<h4>Примеры алгоритмов</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li>Quick Sort, Merge Sort</li>
    <li>Median of Medians (поиск медианы с помощью алгоритма выбора)</li>
    <li>Fast Fourier Trnasform (алгоритм быстрых преобразований Фурье)</li>
    <li>Алгоритм в обработке сигнала (н-р в аудиокодеках)</li>
</ul>

<i>В качестве разновижности применяется алгоритм "Уменьшай и властвуй / Метод уменьшения размера задачи" (Decrease and Conquer)</i>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>3. Динамическое программирование (Dynamic Programming)</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
    <li>Разделение задачи на подзадачи, но подзадачи должны пересекаться: у разных подзадач может быть одна и та же под-под-задача и вместо того чтобы вычислять ее много раз, ее можно вычислить 1 раз, положить в кеш и использовать в дальнейшем</li>
    <li>Похож на "Резделяй и властвуй"</li>
</ul>

<!------------------------------------------------------------->
<h4>Подходы</h4>
<!------------------------------------------------------------->
<ul class="list-point">
	<b>1. Сверху вниз / Мемоизация (Top-down / Memoization)</b>
    <li>Каждый раз, когда требуется выполнить подзадачу, которую мы еще не решили - мы решаем ее и записываем ответ в таблицу, которую потом будем переиспользовать</li>
    <li>+ не нужно заранее знать порядок заполнения таблицы</li>
    <li>+ таблицу не обязательно заполнять целиком - в ней будет минимальное, необходимое для решения задачи</li>

	<hr>
    <b>2. Снизу вверх / Табуляция (Bottom-up / Tabulation)</b>
    <li>Необходимо заранее определить порядок заполнения таблицы и заполнить ее целиком</li>
    <li>Решение основной задачи заключается в чтении конкретной ячейки таблицы</li>
</ul>

<!------------------------------------------------------------->
<h4>Использование</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li>Сравнение данных, н-р исходников программ для определения наболее длинных общих последовательностей текст</li>
    <li>Алгоритмы на графах, н-р поиск кратчайшего расстояния</li>
    <li>Машинной обучение, н-р нейронные сети</li>
</ul>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>4. Жадный алгоритм (Greedy Algorithm)</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
    <li>Метод для задачь оптимизации: сначала сортируем данные по определенному принципу, а дальше циелически выбираем лучший вариант</li>
</ul>

<!------------------------------------------------------------->
<h4>Применение</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li>Алгоритм Хаффмана — жадный алгоритм оптимального префиксного кодирования алфавита с минимальной избыточностью (сжатие jpeg, mp3, gzip)</li>
    <li>Анализ данных, алгоритмы кластеризации</li>
    <li>Алгоритмы на графах, раскраска графов</li>
</ul>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>5. Поиск с возвратом (Backtracking)</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
    <li> Перебор частичных решений и каждый раз когда попадается плохое частичное решение, которое не ведет к решению основной задачи, мы отменяем его и пробуем другое частичное решение</li>
    <li>Модификация метода: <b>Метод ветвей и границ (Branch and Bound)</b></li>
</ul>

<!------------------------------------------------------------->
<h4>Применение</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li>Задачи с маршрутизацией</li>
    <li>Задачи с компьютерным зрением и т.д.</li>
</ul>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>6. Локальный поиск (Local Search)</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
    <li>Есть множество решений задачи</li>
    <li>Определяем какое есть отношение между этими решениями (связываем решения между собой если они не сильно отличаются - находятся в некоторой окрестности)</li>
    <li>Двигаемся в рамках окрестности от решения к решению, каждый раз выбирая решение не хуже предыдущего</li>
</ul>
    
<!------------------------------------------------------------->
<h4>Применение</h4>
<!-------------------------------------------------------------> 
<ul class="list-point">
    <li>Градиентный подъем / спуск</li>
</ul>


<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>7. Преобразуй и властвуй / метод преобразования (Transform and Conquer)</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
    <li>Преобразование имеющейся задачи в другую задачу, н-р более простую, а потом решить ее</li>
</ul>

<!------------------------------------------------------------->
<h4>Применение</h4>
<!------------------------------------------------------------->
<ul class="list-point">
    <li>СУБД при запросах к БД</li>
</ul>
