//--------------------------------------------------------------------

OBS 22.0.2

- Назначение структур данных: представление системы в удобном для работы виде

//--------------------------------------------------------------------

Замыкание
- В момент создания функции определяется ее лексическое окружение
- Скоуп скрытое свойство замененено на Энвайрмент

//--------------------------------------------------------------------

ПРОТОТИПЫ

Foo.prototype = {a: 2}; // тоже самое что и строка ниже
Foo.prototype.a = 2;    // тоже самое что и строка выше
function Foo() {}

const foo = new Foo();
console.log(foo); // => Foo {__proto__: { a:2 }}


-------

Person.__proto__ -> Function.prototype
Person.prototype.constructor.__proto__ -> Function.prototype


//--------------------------------------------------------------------

Написать функцию, считающее число своих вызовов

const func = function() {
    func.counter = func.counter || 0;
    return ++func.counter;
};

console.log(func()); // 1
console.log(func()); // 2
console.log(func()); // 3


//--------------------------------------------------------------------

число фибаначи
принимаем номер элемента последовательности, возвращаем значение

// 0 1 1 2 3 5 8 13 21 34 55

console.log(fibonacci(10) === 55); 

// рекурсивное решение (сложность 2 в степени n)
const fibonacci = n => {
    return n < 2 ? n : fibonacci(n-1) + fibonacci(n-2);
}

// оптимальное решение (сложность единичная, линейная)
const fibArr = [0, 1];
const fibonacci = n => {    
    while(fibArr.length < n) {
        fibArr.push(fibArr[fibArr.length-1] + fibArr[fibArr.length-2])
    }
    return fibArr[n];
}


//--------------------------------------------------------------------

const fibArr = [0, 1];
const fibMap = {
    0: 0,
    1: 1,
}
- значение массивов хранятся в памяти последовательно, поэтому обращение будет быстрее
- объект может хранить свои значение по ссылке, придётся переходить по ссылке чтобы получить доступ к значению

//--------------------------------------------------------------------

js виртуальная машина - одна пространство памяти 
dom служба - другой пространство памяти

если запрашивать свойство у ДОМа, то в службу передается идентификатор элемента, там ищется адрес в памяти элемента,
читаются его свойства, передаются в обратную сторону, сериализуются в какой-то вид, после чего создается js-обертка
и получаем ответ

любое обращение к ДОМу даже на чтение это дополнительная нагрузка
виртуал дом оптимизирует не только запись, но и чтение, храня в себе информацию об объектах

узлы в дереве виртуал дом иммутабельны, когда поменяли стиль на одном узле поменялась ссылка у этого объекта
идёт сравнение ссылок


//--------------------------------------------------------------------

function foo() {
	return function bar() {
		// когда bar вызывается, this указывает на объект { x: 10 }
		// стрелочная функция порождается когда bar был вызван в контексте объекта { x: 10 }
		// стрелка запоминает объект { x: 10 }
		return () => console.log(this);
	}
}

// если foo вызвана обычным способом, this ссылается на window или undefuned в строгом режиме
function foo() {
	// если bar стрелка
	// стрелка создавалась в тот момент, когда у foo this == window, поэтому у стрелки тоже window
	return () => {
		// при создании стрелки у нее по замыканию this == window
		return () => console.log(this);
	}
}

const bar = foo().call();
bar.call({ y: 20 }); // call вызывает bar 

//--------------------------------------------------------------------

ЗАДАЧИ

1. Замыкание

1.1
- Исправить ошибку. Проверка должна возвращать истину
- Решение: поменять "var" на "let"

function closure() {
	return (function() {
		const arr = [];
		
		for (var i=0; i<10; i++) {
			arr.push(function() {
				return i
			});
		}
		
		return arr;
	})();
}

console.log(closure()[3]() === 3); // => должно быть "true"


