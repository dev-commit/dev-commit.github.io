
console.log(sumSequence(1, 3)); // 1 + 2 + 3 = 6
console.log(sumSequence(2, 3)); // 2 + 3 = 5
console.log(sumSequence(2, 2)); // 2 = 2
console.log(sumSequence(1, 2)); // 1 + 2 = 3

// function sumSequence(start, end) {
//   if (start === end) {
//     return start;
//   } else {
//     const sum = start + end;
//     sumSequence(start+1, end);
//   }
// }

// 1 iteration - 1 + sumSequecen(?, ?)
// 2 iteration - 1 + 2 = 3

// 1 iteration 3 + sumsequence(1, 2)
// 2 iteration 2 + sumsequence(1, 1)

function sumSequence(start, end) {
  if (start === end) {
    return end;
  } else {
    return end + sumSequence(start, end - 1);
  }
}

//-------------------------------


var p = Promise.resolve(4);

p
.then(data => {
  console.log(data); // 4
  throw new Error('');
})
.catch(err => {
  console.log('err'); // err
})
.finally((data) => {
  console.log(data); // undefined
  return 1;
})
.then((data) => {
  console.log(data); // undefined
})


//-----------------------------------------


// // reconcilattion

var add = (a, b) => a + b;

var memoAdd = memo(add);
console.log(memoAdd(2, 3)); // 5
console.log(memoAdd(2, 2)); // 4
console.log(memoAdd(2, 2)); // 4, console.log('returned cached value');

function memo(add) {
  var data = {};
  
  return function(...arg) {
    const key = JSON.stringify(arg);
    
    if (data[key]) {
      console.log('returned cached value');
    } else {
      data[key] = add.apply(null, arg);
    }
    
    return data[key];
  }
}



// Store - state - store data
// Reducers -> state1 => state2 - change state - change data
// Action => dispatch => trigger reducer - ???


// FETCH_USERS


// 1 Actions - snapshots - history
// 2 Actions  - metaknowledge





//--------------------------------------------------------------------

OBS 22.0.2

- Назначение структур данных: представление системы в удобном для работы виде

//--------------------------------------------------------------------

Замыкание
- В момент создания функции определяется ее лексическое окружение
- Скоуп скрытое свойство замененено на Энвайрмент

//--------------------------------------------------------------------

ПРОТОТИПЫ

Foo.prototype = {a: 2}; // тоже самое что и строка ниже
Foo.prototype.a = 2;    // тоже самое что и строка выше
function Foo() {}

const foo = new Foo();
console.log(foo); // => Foo {__proto__: { a:2 }}


-------

Person.__proto__ -> Function.prototype
Person.prototype.constructor.__proto__ -> Function.prototype


//--------------------------------------------------------------------

Написать функцию, считающее число своих вызовов

const func = function() {
    func.counter = func.counter || 0;
    return ++func.counter;
};

console.log(func()); // 1
console.log(func()); // 2
console.log(func()); // 3


//--------------------------------------------------------------------

число фибаначи
принимаем номер элемента последовательности, возвращаем значение

// 0 1 1 2 3 5 8 13 21 34 55

console.log(fibonacci(10) === 55); 

// рекурсивное решение (сложность 2 в степени n)
const fibonacci = n => {
    return n < 2 ? n : fibonacci(n-1) + fibonacci(n-2);
}

// оптимальное решение (сложность единичная, линейная)
const fibArr = [0, 1];
const fibonacci = n => {    
    while(fibArr.length < n) {
        fibArr.push(fibArr[fibArr.length-1] + fibArr[fibArr.length-2])
    }
    return fibArr[n];
}


//--------------------------------------------------------------------

const fibArr = [0, 1];
const fibMap = {
    0: 0,
    1: 1,
}
- значение массивов хранятся в памяти последовательно, поэтому обращение будет быстрее
- объект может хранить свои значение по ссылке, придётся переходить по ссылке чтобы получить доступ к значению

//--------------------------------------------------------------------

js виртуальная машина - одна пространство памяти 
dom служба - другой пространство памяти

если запрашивать свойство у ДОМа, то в службу передается идентификатор элемента, там ищется адрес в памяти элемента,
читаются его свойства, передаются в обратную сторону, сериализуются в какой-то вид, после чего создается js-обертка
и получаем ответ

любое обращение к ДОМу даже на чтение это дополнительная нагрузка
виртуал дом оптимизирует не только запись, но и чтение, храня в себе информацию об объектах

узлы в дереве виртуал дом иммутабельны, когда поменяли стиль на одном узле поменялась ссылка у этого объекта
идёт сравнение ссылок


//--------------------------------------------------------------------

function foo() {
	return function bar() {
		// когда bar вызывается, this указывает на объект { x: 10 }
		// стрелочная функция порождается когда bar был вызван в контексте объекта { x: 10 }
		// стрелка запоминает объект { x: 10 }
		return () => console.log(this);
	}
}

// если foo вызвана обычным способом, this ссылается на window или undefuned в строгом режиме
function foo() {
	// если bar стрелка
	// стрелка создавалась в тот момент, когда у foo this == window, поэтому у стрелки тоже window
	return () => {
		// при создании стрелки у нее по замыканию this == window
		return () => console.log(this);
	}
}

const bar = foo().call();
bar.call({ y: 20 }); // call вызывает bar 

//--------------------------------------------------------------------

ЗАДАЧИ

1. Замыкание

1.1
- Исправить ошибку. Проверка должна возвращать истину
- Решение: поменять "var" на "let"

function closure() {
	return (function() {
		const arr = [];
		
		for (var i=0; i<10; i++) {
			arr.push(function() {
				return i
			});
		}
		
		return arr;
	})();
}

console.log(closure()[3]() === 3); // => должно быть "true"


